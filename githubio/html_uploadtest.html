<!DOCTYPE html> <html><head>
		<title>HTML_UploadTest</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="너부리 저장소 - HTML_UploadTest">
		<meta property="og:title" content="HTML_UploadTest">
		<meta property="og:description" content="너부리 저장소 - HTML_UploadTest">
		<meta property="og:type" content="website">
		<meta property="og:url" content="githubio/html_uploadtest.html">
		<meta property="og:image" content="lib\media\whens_biking_attack_1.png">
		<meta property="og:site_name" content="너부리 저장소">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="view-content"><style id="MJX-CHTML-styles"></style><div class="canvas-wrapper node-insert-event" tabindex="-1" data-ignore-swipe="true" style="--zoom-multiplier: 1;"><svg class="canvas-background"><pattern id="200fe9b08a186ea7" patternUnits="userSpaceOnUse" x="450" y="0" width="20" height="20"><circle cx="0.7" cy="0.7" r="0.7"></circle></pattern><rect x="0" y="0" width="100%" height="100%" fill="url(#200fe9b08a186ea7)"></rect></svg><div class="canvas-card-menu" style="z-index: 15;"><div class="canvas-card-menu-button mod-draggable" aria-label="드래그로 카드 추가" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-sticky-note"><path d="M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z"></path><path d="M15 3v6h6"></path></svg></div><div class="canvas-card-menu-button mod-draggable" aria-label="드래그로 보관소의 노트 추가" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-file-text"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg></div><div class="canvas-card-menu-button mod-draggable" aria-label="드래그로 보관소의 미디어 추가" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-file-image"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><circle cx="10" cy="13" r="2"></circle><path d="m20 17-1.09-1.09a2 2 0 0 0-2.82 0L10 22"></path></svg></div></div><div class="canvas-controls" style="z-index: 15;"><div class="canvas-control-group"><div class="canvas-control-item" aria-label="캔버스 설정" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-settings"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg></div></div><div class="canvas-control-group"><div class="canvas-control-item" aria-label="확대" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-plus"><path d="M5 12h14"></path><path d="M12 5v14"></path></svg></div><div class="canvas-control-item" aria-label="확대 초기화" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-rotate-cw"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path></svg></div><div class="canvas-control-item" aria-label="화면 맞춤 확대
(Shift + 1)" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-maximize"><path d="M8 3H5a2 2 0 0 0-2 2v3"></path><path d="M21 8V5a2 2 0 0 0-2-2h-3"></path><path d="M3 16v3a2 2 0 0 0 2 2h3"></path><path d="M16 21h3a2 2 0 0 0 2-2v-3"></path></svg></div><div class="canvas-control-item" aria-label="축소" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-minus"><path d="M5 12h14"></path></svg></div></div><div class="canvas-control-group"><div class="canvas-control-item is-disabled" aria-label="실행 취소" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-undo-2"><path d="M9 14 4 9l5-5"></path><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"></path></svg></div><div class="canvas-control-item is-disabled" aria-label="다시 실행" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-redo-2"><path d="m15 14 5-5-5-5"></path><path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"></path></svg></div></div><div class="canvas-control-group"><div class="canvas-control-item" aria-label="캔버스 도움말" data-tooltip-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><path d="M12 17h.01"></path></svg></div></div></div><div class="canvas" style="transform: translate(450px, 0px) scale(1) translate(0px, 0px);"><svg class="canvas-edges"><g><path class="canvas-interaction-path" d="M1280 896 L1280 903 M1280,903 C1280,1053 1280,137 1280,-13"></path><path class="canvas-display-path" d="M1280 896 L1280 903 M1280,903 C1280,1053 1280,137 1280,-13"></path></g><g><path class="canvas-interaction-path" d="M-1140 -720 L-1140 -713 M-1140,-713 C-1140,-563 -1853.5,-557 -1853.5,-407"></path><path class="canvas-display-path" d="M-1140 -720 L-1140 -713 M-1140,-713 C-1140,-563 -1853.5,-557 -1853.5,-407"></path></g><g><path class="canvas-interaction-path" d="M-1140 -720 L-1140 -713 M-1140,-713 C-1140,-563 -983,850 -1133,850"></path><path class="canvas-display-path" d="M-1140 -720 L-1140 -713 M-1140,-713 C-1140,-563 -983,850 -1133,850"></path></g><g><path class="canvas-interaction-path" d="M-1140 -720 L-1140 -713 M-1140,-713 C-1140,-563 -3937,-260.5 -3787,-260.5"></path><path class="canvas-display-path" d="M-1140 -720 L-1140 -713 M-1140,-713 C-1140,-563 -3937,-260.5 -3787,-260.5"></path></g><g><path class="canvas-interaction-path" d="M443 68 L450 68 M450,68 C600,68 663,-340 813,-340"></path><path class="canvas-display-path" d="M443 68 L450 68 M450,68 C600,68 663,-340 813,-340"></path></g><g><path class="canvas-interaction-path" d="M443 68 L450 68 M450,68 C600,68 663,620 813,620"></path><path class="canvas-display-path" d="M443 68 L450 68 M450,68 C600,68 663,620 813,620"></path></g><g><path class="canvas-interaction-path" d="M-1950 1560 L-1943 1560 M-1943,1560 C-1858.045232623472,1560 -1890.954767376528,1660.5 -1806,1660.5"></path><path class="canvas-display-path" d="M-1950 1560 L-1943 1560 M-1943,1560 C-1858.045232623472,1560 -1890.954767376528,1660.5 -1806,1660.5"></path></g></svg><svg class="canvas-edges"><g><g style="transform: translate(1280px, -20px) rotate(0deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g><g><g style="transform: translate(-1853.5px, -400px) rotate(180deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g><g><g style="transform: translate(-1140px, 850px) rotate(270deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g><g><g style="transform: translate(-3780px, -260.5px) rotate(90deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g><g><g style="transform: translate(820px, -340px) rotate(90deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g><g><g style="transform: translate(820px, 620px) rotate(90deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g><g><g style="transform: translate(-1799px, 1660.5px) rotate(90deg);"><polygon class="canvas-path-end" points="0,0 6.5,10.4 -6.5,10.4"></polygon></g></g></svg><div class="canvas-node canvas-node-group is-themed mod-canvas-color-2" style="z-index: -8298300; transform: translate(-3900px, -800px); width: 2985px; height: 2780px; --canvas-node-width: 2985px; --canvas-node-height: 2780px;"><div class="canvas-node-container"><div class="canvas-node-content"></div></div><div class="canvas-group-label" spellcheck="false">Canvas 내부로 임베디드 되는 케이스</div></div><div class="canvas-node canvas-node-group" style="z-index: -3775200; transform: translate(-440px, -800px); width: 2200px; height: 1716px; --canvas-node-width: 2200px; --canvas-node-height: 1716px;"><div class="canvas-node-container"><div class="canvas-node-content"></div></div><div class="canvas-group-label" spellcheck="false">웹 페이지로 임베디드 안됨</div></div><div class="canvas-node is-themed mod-canvas-color-3" style="z-index: 2; transform: translate(-1320px, -770px); width: 360px; height: 50px; --canvas-node-width: 360px; --canvas-node-height: 50px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">title</span><span class="token punctuation">:</span> 멀티플레이어 게임 프로그래밍
<span class="token key atrule">created</span><span class="token punctuation">:</span> 2024<span class="token punctuation">-</span>02<span class="token punctuation">-</span>24 21<span class="token punctuation">:</span><span class="token number">28</span>
<span class="token key atrule">state</span><span class="token punctuation">:</span> 읽는 중
<span class="token key atrule">rating</span><span class="token punctuation">:</span> ★★★★
<span class="token key atrule">author</span><span class="token punctuation">:</span> 
<span class="token key atrule">book cover</span><span class="token punctuation">:</span> 
<span class="token key atrule">link</span><span class="token punctuation">:</span> <span class="token string">"[[- 전체 독서노트 -|- 전체 독서노트 -]]"</span>
<span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> 프로그래밍
review<span class="token punctuation">:</span></code><button class="copy-code-button">복사</button></pre><div class="markdown-preview-sizer markdown-preview-section"><div class="heading-wrapper"><h1 data-heading="Github 업로드 테스트" class="heading" id="Github_업로드_테스트">Github 업로드 테스트</h1><div class="heading-children"></div></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div></div><div class="canvas-node" style="z-index: 3; transform: translate(-2513px, -400px); width: 1319px; height: 760px; --canvas-node-width: 1319px; --canvas-node-height: 760px;"><div class="canvas-node-container"><div class="canvas-node-content media-embed image-embed is-loaded"><img src="lib/media/whens_biking_attack_1.png" draggable="false"></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">Whens_Biking_Attack_1.png</div></div><div class="canvas-node" style="z-index: 4; transform: translate(-3920px, -2320px); width: 880px; height: 240px; --canvas-node-width: 880px; --canvas-node-height: 240px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><div class="markdown-preview-sizer markdown-preview-section"><div class="heading-wrapper"><h2 data-heading="필요한 파일" class="heading" id="필요한_파일"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>필요한 파일</h2><div class="heading-children"><div><ul>
<li data-line="0">index.html</li>
</ul></div></div></div><div class="heading-wrapper"><h2 data-heading="업로드시" class="heading" id="업로드시"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>업로드시</h2><div class="heading-children"><div><ul>
<li data-line="0">Export시 online webserver 옵션 선택 &lt;-- 그래야 링크가 잘됨</li>
</ul></div></div></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div></div><div class="canvas-node" style="z-index: 5; transform: translate(-1854px, 450px); width: 714px; height: 800px; --canvas-node-width: 714px; --canvas-node-height: 800px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed is-loaded"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><div class="markdown-preview-sizer markdown-preview-section"><div class="mod-header"></div><div class="heading-wrapper"><h2 data-heading="BookInfo" class="heading" id="BookInfo"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>BookInfo</h2><div class="heading-children"><div><ul>
<li data-line="0">BookTitle : 멀티플레이어 게임 프로그래밍</li>
<li data-line="1">AuthorName : 산제이 마드하브,조슈아 글레이저</li>
<li data-line="2">LastReadDate : 2024-03-19 00:15:59</li>
</ul></div><div><hr></div></div></div><div class="heading-wrapper"><h2 data-heading="독후감" class="heading" id="독후감"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>독후감</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="하이라이트" class="heading" id="하이라이트"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>하이라이트</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="1장 네트워크 게임의 개요" class="heading" id="1장_네트워크_게임의_개요"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1장 네트워크 게임의 개요</h3><div class="heading-children"><div><ul>
<li data-line="0">
<p>(4%) 로컬 멀티플레이라는 것을 지원했는데, 한 대의 컴퓨터에 둘 이상의 플레이어가 같이 즐길 수 있게 고안된 것</p>
</li>
<li data-line="2">
<p>(4%) 로컬 멀티플레이 구현에 필요한 기술은 거의 모든 부분에서 싱글 플레이어 게임을 프로그래밍하는 기술과 같다.</p>
</li>
<li data-line="4">
<p>(4%) 직렬 포트는 데이터를 한 번에 1비트씩 보낼 수 있는 연결 장치</p>
</li>
<li data-line="6">
<p>(4%) 데이지 체인(daisy chain) 구조</p>
</li>
<li data-line="8">
<p>(4%) 멀티 유저 던전(Multi-User Dungeon, MUD)형 게임</p>
</li>
<li data-line="10">
<p>(4%) BBS(Bulletin Board System, 전자 게시판 시스템)</p>
</li>
<li data-line="12">
<p>(4%) 이더넷(Ethernet)</p>
</li>
<li data-line="14">
<p>(4%) 대형 통신망을 통해 지리적으로 멀리 떨어진 컴퓨터끼리 연결하여 플레이하는 것을 온라인 게임이라 한다</p>
</li>
<li data-line="16">
<p>(4%) 레이턴시(latency), 즉 네트워크로 데이터를 전송하면서 발생하는 시간 지연</p>
</li>
<li data-line="18">
<p>(4%) 네트워크 멀티플레이어 게임은 둘 이상의 컴퓨터가 각각 연결되어 게임 세션을 이룬다는 점에서 로컬 멀티플레이어 게임과 구별된다.</p>
</li>
<li data-line="20">
<p>(4%) 초창기 네트워크 게임으로 꼽을 수 있는 턴제 전략 게임 엠파이어(Empire)(1973)</p>
</li>
<li data-line="22">
<p>(4%) 근거리 통신망(Local Area Network), 줄여서 랜(LAN)은 상대적으로 가까운 지역 내에서 서로 연결된 컴퓨터의 네트워크를 뜻한다</p>
</li>
<li data-line="24">
<p>(4%) 사람들이 각자 자기 컴퓨터를 들고와 한 장소에 모여서 컴퓨터를 서로 연결해 랜 파티를 즐기며 플레이하는 풍경도 흔했다.</p>
</li>
<li data-line="26">
<p>(4%) MMO(Massively Multiplayer Online, 대규모 다중 사용자 온라인) 게임은 하나의 게임 세션에 수백 명, 아니 수천수만의 플레이어가 동시에 참여할 수 있다</p>
</li>
<li data-line="28">
<p>(4%) MMO를 설계할 땐 여러 가지 고도의 기술적 난제에 직면하게 되는데, 이 중 몇몇은 9장 규모 확장에 대응하기에서 다룬다</p>
</li>
</ul></div><div class="heading-wrapper"><h4 data-heading="1.1 멀티플레이어 게임의 간추린 역사" class="heading" id="1.1_멀티플레이어_게임의_간추린_역사"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 멀티플레이어 게임의 간추린 역사</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="1.1.1 로컬 멀티플레이어 게임" class="heading" id="1.1.1_로컬_멀티플레이어_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 로컬 멀티플레이어 게임</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.1.2 초기 네트워크 멀티플레이어 게임" class="heading" id="1.1.2_초기_네트워크_멀티플레이어_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 초기 네트워크 멀티플레이어 게임</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.1.3 MUD: 멀티 유저 던전" class="heading" id="1.1.3_MUD:_멀티_유저_던전"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3 MUD: 멀티 유저 던전</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.1.4 랜 게임" class="heading" id="1.1.4_랜_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.4 랜 게임</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.1.5 온라인 게임" class="heading" id="1.1.5_온라인_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.5 온라인 게임</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.1.6 MMO 게임" class="heading" id="1.1.6_MMO_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.6 MMO 게임</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.1.7 모바일 네트워크 게임" class="heading" id="1.1.7_모바일_네트워크_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.7 모바일 네트워크 게임</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(5%) 비동기식(asynchronous)으로 구현</p>
</li>
<li data-line="2">
<p>(5%) 보통 턴제 방식으로 기획된 게임이 비동기식 멀티플레이를 채용하는데, 비동기식 멀티플레이 모델에선 데이터를 실시간으로 전송할 필요가 없다</p>
</li>
<li data-line="4">
<p>(5%) 기술 면에서 볼 때 비동기 네트워크 게임은 실시간 네트워크 게임보다 구현하기가 쉬운 편이다. 특히 모바일의 경우 플랫폼 API5 단에서 이미 비동기 통신 수단을 구비하여 제공하기 때문에 훨씬 더 수월하다.</p>
</li>
<li data-line="6">
<p>(4%) 최신 상태 데이터. 최신 상태가 아니면 전달할 의미가 없는 성격의 데이터이다.</p>
</li>
<li data-line="8">
<p>(5%) 스타시즈: 트라이브스(Starsiege: Tribes)는 1998년 말에 출시된 SF 장르 FPS</p>
</li>
<li data-line="10">
<p>(5%) 네트워크 게임을 설계할 때 가장 먼저 정해둘 것은 통신 프로토콜</p>
</li>
<li data-line="12">
<p>(5%) 트라이브스는 효율성 문제로 비신뢰성 프로토콜을 사용한다는 정도만 알아두자. 이 말인즉슨 네트워크로 보낸 데이터가 수신자에게 반드시 도착한다는 보장이 없다는 뜻이다.</p>
</li>
<li data-line="14">
<p>(5%) 개발할 때 데이터의 종류에 따라 어떻게 보낼지를 구분해 두어야 한다</p>
</li>
<li data-line="16">
<p>(5%) 전달 보장 데이터. 수신이 보장되어야 하며 나아가 데이터가 보낸 순서대로 도착하는 것도 보장되어야 하는 데이터</p>
</li>
<li data-line="18">
<p>(5%) 전달 미보장 데이터. 말 그대로 게임에 있어 그다지 중요하지는 않은 데이터를 지칭</p>
</li>
<li data-line="20">
<p>(5%) P2P 모델은 O(n2)의 대역폭이 필요하다. 이는 사용자 수의 제곱에 비례하여 대역폭이 소모된다는 뜻</p>
</li>
<li data-line="22">
<p>(5%) 클라이언트-서버로 구성하면 각 플레이어에 할당되는 대역은 상수로 고정되며, 서버만 O(n) 대역폭을 처리</p>
</li>
<li data-line="24">
<p>(5%) 패킷(packet)이란 네트워크로 보내기 위해 데이터를 묶어 놓은 한 단위</p>
</li>
<li data-line="26">
<p>(5%) 다양한 패킷 형식을 조립하고 전송하려는 목적으로 래핑한 것</p>
</li>
<li data-line="28">
<p>(5%) 연결 관리자(connection manager)의 역할은 두 컴퓨터 사이의 연결을 추상화하는 것</p>
</li>
<li data-line="30">
<p>(5%) 연결 관리자는 DSN(Delivery Status Notification, 배달 상태 통지)을 보장하는데, 쉬운 말로 하자면 맡긴 패킷이 전달되었는지 여부까지만 연결 관리자가 확실히 알려준다는 뜻</p>
</li>
<li data-line="32">
<p>(5%) 배달 상태 통지는 수신 측의 확인응답(acknowledge)에 따라 비트 필드를 이용한 슬라이딩 윈도(sliding window) 기법으로 구현</p>
</li>
<li data-line="34">
<p>(5%) 당시 기술로 이 인원을 수용한다는 것은 실로 엄청나게 어려운 일이었는데, 단적인 예로 대부분 플레이어가 인터넷을 전화 접속으로 하던 시절이다</p>
</li>
<li data-line="36">
<p>(5%) 전화 연결에 있어 애로 사항은 레이턴시가 높다는, 즉 응답 지연이 크다는 것으로, 수백 밀리초대 레이턴시면 양호한 편일 지경이었다.</p>
</li>
<li data-line="38">
<p>(5%) 특급 전달 보장 데이터. 최우선으로 보내야 하며 아울러 전달이 보장되어야 하는 데이터가 여기에 속한다.</p>
</li>
<li data-line="40">
<p>(5%) 즉 사용자 수가 128이라면 P2P 연결 시 각각의 플레이어는 주어진 대역폭을 n 제곱인 16,384로 나눠 써야 하는 셈이다</p>
</li>
<li data-line="42">
<p>(5%) 트라이브스의 네트워킹 모델은 ‘시루떡처럼 쌓아 올린’ 모양, 즉 스택(stack)이라 보면 되는데</p>
</li>
<li data-line="44">
<p>(5%) 트라이브스 개발자들은 신뢰성(reliable) 계층을 직접 구현하기로 했다. 그렇다고 이 처리를 플랫폼 패킷 모듈에서 다 하는 건 아니다. 보다 상위 계층의 고스트 관리자, 이동 관리자, 이벤트 관리자가 신뢰성 관련된 처리를 나누어 담당한다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="1.2 스타시즈: 트라이브스" class="heading" id="1.2_스타시즈:_트라이브스"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 스타시즈: 트라이브스</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="1.2.1 플랫폼 패킷 모듈" class="heading" id="1.2.1_플랫폼_패킷_모듈"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.1 플랫폼 패킷 모듈</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.2.2 연결 관리자" class="heading" id="1.2.2_연결_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2 연결 관리자</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(6%) 스트림 관리자(stream manager)가 주로 하는 일은 다른 여러 상위 관리자를 대신하여 데이터를 연결 관리자에 보내는 것</p>
</li>
<li data-line="2">
<p>(6%) 중요한 처리는 바로 허용 최대 데이터 전송률을 조절하는 것</p>
</li>
<li data-line="4">
<p>(6%) 최대 전송 빈도와 크기는 서버에 접속할 때 클라이언트가 알려주는데, 서버가 데이터를 너무 많이 보내 과부하를 주지 않도록 하기 위함</p>
</li>
<li data-line="6">
<p>(6%) 요청의 우선순위를 관리</p>
</li>
<li data-line="8">
<p>(6%) 스트림 관리자는 어떤 데이터를 보낼지 결정한 다음 패킷을 꾸려 연결 관리자에 내려보낸다.</p>
</li>
<li data-line="10">
<p>(6%) 이벤트 관리자(event manager)는 게임 시뮬레이션 중 발생하는 이벤트의 대기열을 관리</p>
</li>
<li data-line="12">
<p>(6%) RPC란 호출 시 원격 머신에서 실행되는 함수 또는 프로시저를 뜻한다</p>
</li>
<li data-line="14">
<p>(6%) 특정 조건이 되면 처리를 중단한다. 구체적으로는 패킷이 꽉 차거나 이벤트 큐가 비었을 때 혹은 현재 계류 중인 이벤트가 너무 많은 경우</p>
</li>
<li data-line="16">
<p>(6%) 상위 수준에서 고스트 관리자가 하는 일은 바로 특정 클라이언트에게 유의미하다고 여겨지는 동적 객체를 복제 혹은 ‘고스트’ 사본을 만드는 것</p>
</li>
<li data-line="18">
<p>(6%) 모든 클라이언트가 가장 최신의 상태로 업데이트되어 있게끔 보장하는 것은 고스트 매니저의 중요한 책무</p>
</li>
<li data-line="20">
<p>(6%) 고유 ID, 상태 마스크, 우선순위, 상태 변경 여부(</p>
</li>
<li data-line="22">
<p>(6%) 이동 관리자는 초당 30프레임7의 빠른 속도로 입력 캡처를 수행하여 데이터를 생성하는데, 이 데이터에는 높은 우선순위가 부여된다.</p>
</li>
<li data-line="24">
<p>(6%) 이동 데이터를 내려보내면 스트림 관리자는 다른 것보다 가장 먼저 이동 데이터를 챙겨 내보낼 패킷 앞에 끼워 보내는데, 이동 데이터의 우선순위가 가장 높기 때문에 이렇게 동작하는 것</p>
</li>
<li data-line="26">
<p>(6%) 전송 주기와 패킷 크기를 스트림 관리자가 결정하므로, 한 패킷에 여러 종류의 데이터를 섞어 보내는 경우가 다반사이다. 이를테면 패킷 하나를 열었을 때 이동 관리자의 데이터가 일부, 이벤트 관리자의 데이터도 일부, 거기에 고스트 관리자의 데이터도 약간, 이런 식이다</p>
</li>
<li data-line="28">
<p>(6%) 이벤트 관리자는 각 이벤트의 전송 기록을 추적하여 이벤트의 확실한 전달을 보장한다</p>
</li>
<li data-line="30">
<p>(6%) 클라이언트가 서버에서 받아둔 여러 객체 정보를 일컬어 클라이언트상 서버 객체의 ‘고스트’라 칭하는데, 이 고스트를 전송 또는 수신하는 것이 고스트 관리자의 역할이다</p>
</li>
<li data-line="32">
<p>(6%) 어떤 객체가 클라이언트의 인지 범위에 포함되는지, 즉 스코프(scope)에 포함되는지 여부를 판정하는 데는 몇 가지 서로 다른 접근 방법이 있다</p>
</li>
<li data-line="34">
<p>(6%) 어떤 방식으로든 유의미한 객체 집합을 일단 계산하고 난 다음에 고스트 관리자가 하는 일은 서버에서 클라이언트로 가능한 많은 객체 상태를 전송하는 것이다</p>
</li>
<li data-line="36">
<p>(6%) 고스트 레코드의 전송 순서는 일차로 객체의 상태가 변경된 것 먼저, 그다음으로 레코드 자체의 우선순위에 따른다</p>
</li>
<li data-line="38">
<p>(6%) 이동 관리자(move manager)의 역할은 플레이어의 이동 데이터를 최대한 빨리 전송하는 것이</p>
</li>
<li data-line="40">
<p>(6%) 데이터블록 관리자(datablock manager)가 그 예인데, 비교적 정적인 편에 속하는 게임 객체의 전송을 취급한다. 이와 구별하여 보다 동적인 객체는 고스트 관리자가 담당한다</p>
</li>
<li data-line="42">
<p>(6%) 포탑이 바로 정적인 객체의 좋은 예로, 실제 이동하는 일은 없으므로 동적인 객체로 구분하지는 않지만, 플레이어가 상호작용하여 상태 갱신이 일어나는 객체다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="1.2.3 스트림 관리자" class="heading" id="1.2.3_스트림_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.3 스트림 관리자</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.2.4 이벤트 관리자" class="heading" id="1.2.4_이벤트_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.4 이벤트 관리자</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.2.5 고스트 관리자" class="heading" id="1.2.5_고스트_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.5 고스트 관리자</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.2.6 이동 관리자" class="heading" id="1.2.6_이동_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.6 이동 관리자</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.2.7 기타 시스템" class="heading" id="1.2.7_기타_시스템"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.7 기타 시스템</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(6%) 에이지 오브 엠파이어는 결정론적 락스텝(deterministic lockstep)8 모델을 채택</p>
</li>
<li data-line="2">
<p>(6%) 결정론이 보장되는 게임에선 모든 피어가 각각 동시에 병행하여 시뮬레이션을 진행한다. 그리고 게임이 진행되는 내내 모든 피어의 동기화를 맞추기 위해 통신에 락스텝을 사용한다</p>
</li>
<li data-line="4">
<p>(6%) RTS 멀티플레이어 게임을 네트워킹으로 구현하는 데 있어 FPS와 비교해 가장 큰 차이점은 플레이어의 가시권에 포함되는 유닛의 개수가 많다는 점</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="1.3 에이지 오브 엠파이어" class="heading" id="1.3_에이지_오브_엠파이어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3 에이지 오브 엠파이어</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(7%) 가시권 판정을 절묘하게 하는 알고리즘이 있어서 동기화할 유닛의 숫자를 효율적으로 다룰 수 있다 치더라도, 최악의 경우를 따져볼 필요가 있다.</p>
</li>
<li data-line="2">
<p>(7%) 에이지 오브 엠파이어 개발자들은 개별 유닛을 하나하나 동기화하는 대신 플레이어가 입력한 명령을 동기화</p>
</li>
<li data-line="4">
<p>(7%) 극단적인 경우라도 게임 시스템이 플레이어마다 초당 몇 회 정도의 명령만 전송할 수 있으면 충분</p>
</li>
<li data-line="6">
<p>(7%) 유닛 정보를 네트워크를 통해 보내지 않으므로 모든 플레이어의 게임 인스턴스는 명령을 받으면 그 명령대로, 스스로 게임 시뮬레이션을 진행해야 한다.</p>
</li>
<li data-line="8">
<p>(7%) 각 인스턴스를 다른 인스턴스와 정확히 동기화할 수 있는지가 극도로 중요</p>
</li>
<li data-line="10">
<p>(7%) A가 명령을 내릴 때 곧바로 적용해 버리는 대신, 명령을 잠깐 대기시켜 둔 채로 일단 B, C, D에 보내어 모두가 준비되었을 때 비로소 동시에 적용하는 것</p>
</li>
<li data-line="12">
<p>(7%) 턴 타이머(turn timer)를 추가하여 일정 기간마다 명령을 쌓아두는 것</p>
</li>
<li data-line="14">
<p>(7%) 수신 측이 명령 대기열을 받는 즉시 처리하지 않고, 이후 두 번의 턴이 지난 다음에 처리한다는 것</p>
</li>
<li data-line="16">
<p>(7%) 200밀리초짜리 타이머의 경우 인풋 랙(input lag), 즉 입력 후 화면에 반영하기까지 지연시간이 모두 합쳐 최대 600밀리초가 되는 셈</p>
</li>
<li data-line="18">
<p>(7%) 플레이어 한 명에게 심한 랙이 발생하여 200밀리초 타이머조차도 따라가지 못하는 경우엔 어떻게 처리해야 할까</p>
</li>
<li data-line="20">
<p>(7%) 렌더링 프레임 레이트를 때에 따라 동적으로 조절하는 메커니즘</p>
</li>
<li data-line="22">
<p>(7%) 항상 같은 결과로 수렴토록 보장하는 장치가 절대적으로 중요</p>
</li>
<li data-line="24">
<p>(7%) 유사 난수 발생기(pseudo-random number generator, PRNG)의 동작 원리에 주목</p>
</li>
<li data-line="26">
<p>(7%) 시드 값을 통일해 두어도 단 한 번이라도 서로 다른 횟수로 호출하면 더 이상 회차마다 같은 값이 나오지 않게 된다는 점</p>
</li>
<li data-line="28">
<p>(7%) 동기화 시스템은 보여주어선 안 될 정보를 드러내 버리는 종류의 치트에는 무방비하다는 단점이 있다. 소위 ‘맵핵(map hack)’이라 불리는 치트 프로그램은 맵 전체를 다 훔쳐볼 수 있게 해 주는데, 이는 RTS 게임에 있어 오늘날에도 흔한 골칫거리</p>
</li>
<li data-line="30">
<p>(7%) 각 게임 인스턴스마다 독립적으로 시뮬레이션을 수행하므로 P2P 형태의 토폴로지가 잘 어울린다</p>
</li>
<li data-line="32">
<p>(7%) P2P 모델에선 컴퓨터 사이에 데이터가 비교적 빠르게 오갈 수 있다는 장점이 있다. 서버가 중간에서 데이터를 중개할 필요가 없기 때문이다. 하지만 각 플레이어가 각자의 정보를 서버 하나에 보내는 데 그치지 않고 다른 모든 플레이어에게 전송해야 한다는 단점이 있다.</p>
</li>
<li data-line="34">
<p>(7%) A의 피어는 다른 모든 피어에 정보를 보내야 하고, 모두 정확히 같은 시점에 이 명령을 처리해야 한다.</p>
</li>
<li data-line="36">
<p>(7%) 먼저 턴의 길이를 정해 두어야 한다</p>
</li>
<li data-line="38">
<p>(7%) 지연시간에도 불구하고 딱 두 턴만 기다려 주면 모든 플레이어가 명령을 받아 동시에 그 턴을 처리하는 데 큰 문제가 없게 된다.</p>
</li>
<li data-line="40">
<p>(7%) 이렇게 클라이언트가 입력한 명령을 모아 보내는 방식엔 또 한 가지 장점이 있다. 경기 진행 내내 처리된 모든 입력을 모아 저장해 두더라도 메모리 용량이나 그 처리 부담이 적다는 점이다.</p>
</li>
<li data-line="42">
<p>(7%) “동기화가 어긋나는 오류를 찾기 어려운 이유는 피어마다 미세한 오차가 누적될 수 있다는 데서 비롯된다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="1.3.1 턴 타이머" class="heading" id="1.3.1_턴_타이머"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.1 턴 타이머</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="1.3.2 동기화" class="heading" id="1.3.2_동기화"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.2 동기화</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="1.4 요약" class="heading" id="1.4_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4 요약</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(8%) 플랫폼 패킷 모듈은 네트워크상 패킷 전송 작업을 추상화한다.</p>
</li>
<li data-line="2">
<p>(8%) 연결 관리자는 플레이어와 서버 사이의 연결을 관리하며 배달 여부 통지 또한 발행한다.</p>
</li>
<li data-line="4">
<p>(8%) 스트림 관리자는 상위 수준 여러(이벤트, 고스트, 이동 등) 관리자의 데이터를 받아서 각각을 우선순위에 따라 처리하여 내보낼 패킷을 가공한다.</p>
</li>
<li data-line="6">
<p>(8%) 이벤트 관리자는 ‘플레이어가 사격함’ 등의 중요 이벤트를 관할하여 관련 시스템이 이를 반드시 받을 수 있게 보장한다.</p>
</li>
<li data-line="8">
<p>(8%) 고스트 매니저는 객체 상태의 업데이트를 처리하며 특정 플레이어에게 유의미한 객체 집합이 어떤 것인지 판별한다.</p>
</li>
<li data-line="10">
<p>(8%) 이동 관리자는 각 플레이어의 가장 최신 이동 정보를 송신한다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="2장 인터넷" class="heading" id="2장_인터넷"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2장 인터넷</h3><div class="heading-children"><div><ul>
<li data-line="0">
<p>(8%) 패킷 스위칭</p>
</li>
<li data-line="2">
<p>(8%) 서킷 스위칭 시스템은 정보를 송수신하는 과정에서 송수신 단말 사이에 회로(circuit) 연결을 해두고 정보 전달을 수행하는데, 이때 이 회로는 보다 작은 단위의 회선(line)을 길게 짜 맞추어 연결한 것으로 송수신이 일어나는 동안 연결이 유지되는 방식</p>
</li>
</ul></div><div class="heading-wrapper"><h4 data-heading="2.1 패킷 스위칭의 기원" class="heading" id="2.1_패킷_스위칭의_기원"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 패킷 스위칭의 기원</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(9%) 회선은 모두 송수신이 끝날 때까지 그 연결 전용으로만 사용해야 한다</p>
</li>
<li data-line="2">
<p>(9%) 한 번에 하나의 통신 전용으로만 회선을 사용해야 하므로 가용성 면에서 이 방식은 제한적일 수밖에 없다.</p>
</li>
<li data-line="4">
<p>(9%) 패킷 스위칭은 하나의 송수신에 회선을 전용으로 할당해야 할 필요가 없으므로 가용성을 한층 높일 수 있다. 회선 자체는 공유하되, 송수신 내용을 패킷이라는 작은 뭉치로 나눈 뒤 저장 후 전달(store and forward) 절차를 사용</p>
</li>
<li data-line="6">
<p>(9%) 서킷 스위칭과 비교해 가장 중요한 차이점은 같은 회선을 이용해 여러 전화 통화가 동시에 진행될 수 있다는 점</p>
</li>
<li data-line="8">
<p>(9%) TCP/IP 스택(stack)</p>
</li>
<li data-line="10">
<p>(9%) 각기 독립된 계층이 다른 계층을 뒷받침하고 데이터를 적절히 연계할 수 있다는 면</p>
</li>
<li data-line="12">
<p>(9%) 지저분한 면은 기껏 이렇게 추상화를 잘해놓고선 프로토콜 작성자마다 성능이니 확장성이니 하는 핑계로, 쓸모 있긴 하지만 설계 철학에 반하는 복잡한 예외사항으로 범벅을 해 두었다는 면</p>
</li>
<li data-line="14">
<p>(9%) 초기 인터넷 호스트 요구 사항을 정의한 RFC 1122에선 링크 계층, IP 계층, 전송 계층, 응용 계층, 이렇게 네 개의 계층으로 구분한다</p>
</li>
<li data-line="16">
<p>(9%) OSI(Open Systems Interconnection) 모형에서는 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층, 이렇게 일곱 계층으로 구분</p>
</li>
<li data-line="18">
<p>(9%) 각 계층은 저마다 자기 윗단 계층을 지원하기 위해 수행해야 하는 역할이 있다.</p>
</li>
<li data-line="20">
<p>(9%) 계층을 인터페이스라 여기고, 각 프로토콜이나 프로토콜 집합은 그 인터페이스를 구체화한 구현물이라 생각해도 좋다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="2.2 TCP/IP 스택의 계층 구조" class="heading" id="2.2_TCP/IP_스택의_계층_구조"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 TCP/IP 스택의 계층 구조</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(9%) 물리 계층의 역할은 네트워크로 연결된 컴퓨터, 즉 호스트 사이의 물리적 연결을 책임지는 것</p>
</li>
<li data-line="2">
<p>(9%) 전파 역시 정보를 전송하는 데 유용한 물리 매체로 활용된다</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="2.3 물리 계층" class="heading" id="2.3_물리_계층"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 물리 계층</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(9%) 물리적으로 연결된 호스트 사이의 통신 수단을 제공하는 것</p>
</li>
<li data-line="2">
<p>(9%) 다시 말해 송신 호스트가 정보를 꾸려 물리 계층을 통해 정보를 보낼 수 있는 수단, 그리고 수신 호스트가 높은 확률로 그 정보를 수신하여 안에 담긴 정보를 꺼낼 수 있게 하는 수단을 링크 계층이 제공한다는 뜻</p>
</li>
<li data-line="4">
<p>(9%) 호스트를 식별할 수단 제공</p>
</li>
<li data-line="6">
<p>(9%) 수신 측 주소와 데이터를 담을 수 있는 프레임 포맷 정의</p>
</li>
<li data-line="8">
<p>(9%) 프레임의 최대 길이를 정의</p>
</li>
<li data-line="10">
<p>(9%) 물리적인 전기 신호로 변환하는 방법을 정의</p>
</li>
<li data-line="12">
<p>(9%) 링크 계층의 송수신 단위는 프레임(frame)이라 한다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="2.4 링크 계층" class="heading" id="2.4_링크_계층"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4 링크 계층</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(10%) 의도된 호스트에 프레임이 전달될지 아닐지는 확률적으로 결정되며 항상 보장되는 것은 아니라는 점에 유념</p>
</li>
<li data-line="2">
<p>(10%) 링크 계층에선 프레임이 도착하였는지 확인하거나 실패하였을 때 다시 보내는 등 시도를 전혀 하지 않는다</p>
</li>
<li data-line="4">
<p>(10%) 네트워크 컴퓨터 게임을 하면서 발생하는 데이터를 송신하는 과정에서, 위의 표에 등장한 다양한 링크 계층 프로토콜이 두루 이용될 수 있다.</p>
</li>
<li data-line="6">
<p>(10%) 오늘날 이더넷 프로토콜은 IEEE 802.3 표준으로 정의하고 있다.</p>
</li>
<li data-line="8">
<p>(10%) 여러 호스트를 식별하기 위해 이더넷에선 매체 접근 제어 주소(Media Access Control address, MAC address), 줄여서 MAC 주소를 사용한다</p>
</li>
<li data-line="10">
<p>(10%) 네트워크 인터페이스 컨트롤러</p>
</li>
<li data-line="12">
<p>(10%) 프리앰블(preamble)과 SFD(start frame delimiter)라 한다.</p>
</li>
<li data-line="14">
<p>(10%) 프리앰블과 SFD는 보통 NIC 하드웨어가 걸러내며, 프레임을 구성하는 나머지 바이트 열을 이더넷 모듈에 넘겨 처리한다.</p>
</li>
<li data-line="16">
<p>(10%) 길이/종류 필드는 오버로드하여 길이나 종류 둘 중 하나로 사용</p>
</li>
<li data-line="18">
<p>(10%) 이더넷 모듈이 이 필드를 처리할 때 정확하게 해석할 수 있게, 이더넷 표준은 페이로드의 최대 길이를 1,500바이트로 정의해 두었다. 이를 최대 전송 유닛(maximum transmission unit) 혹은 MTU라 하며, 한 번 전송에 최대한 담을 수 있는 데이터의 양을 뜻한다.</p>
</li>
<li data-line="20">
<p>(10%) 길이/종류 필드 값이 1500 이하인 경우엔 ‘길이’로 해석하면 되고, 1536 이상인 경우엔 프로토콜 ‘종류’로 판단하면 된다</p>
</li>
<li data-line="22">
<p>(10%) 페이로드(payload)란 프레임에 담겨 전송되는 데이터 그 자체를 뜻한다</p>
</li>
<li data-line="24">
<p>(10%) 이더넷 하드웨어가 데이터 수신 시 이 값을 검사하여 전송된 데이터가 손상되었는지 판단하고, 만일 손상된 경우 프레임을 폐기해 버린다</p>
</li>
<li data-line="26">
<p>(10%) 네트워크상 호스트 중 하나가 해당 프레임을 받으면 호스트가 프레임을 읽어보고 그 수신자가 마침 자신일 때, 길이/종류 필드의 값에 따라 페이로드에서 데이터를 꺼내어 처리한다,</p>
</li>
<li data-line="28">
<p>(10%) 최신 네트워크에선 스위치(switch)라는 장비로 여러 호스트를 연결한다. 스위치의 포트에 호스트를 연결해 두면 스위치는 그 호스트의 MAC 주소, 혹은 IP도 같이 기억해 두었다가 그 주소로 패킷을 전달할 일이 있을 때, 연결된 여러 호스트에 일일이 보내지 않고도 해당 호스트를 특정하여 최단 경로로 보낼 수 있다.</p>
</li>
<li data-line="30">
<p>(10%) 프리앰블(preamble)과 SFD(start frame delimiter)라 한다. 밑단 하드웨어는 이러한 이진수 패턴을 체크하여 동기화를 맞추고 새 프레임을 받을 준비를 한다.</p>
</li>
<li data-line="32">
<p>(10%) 길이/종류 필드는 오버로드하여 길이나 종류 둘 중 하나로 사용한다. 길이 필드로 사용하는 경우, 프레임에 포함된 페이로드의 길이를 바이트 단위로 나타낸다. 만일 종류 필드로 사용한 경우, 이더타입(EtherType) 고유 식별자 값을 기록해 페이로드 내 데이터를 어떻게 해석해야 하는지 표시한다.</p>
</li>
<li data-line="34">
<p>(10%) 이더넷 표준은 페이로드의 최대 길이를 1,500바이트로 정의해 두었다. 이를 최대 전송 유닛(maximum transmission unit) 혹은 MTU라 하며, 한 번 전송에 최대한 담을 수 있는 데이터의 양을 뜻한다</p>
</li>
<li data-line="36">
<p>(10%) 페이로드(payload)란 프레임에 담겨 전송되는 데이터 그 자체를 뜻한다. 대개 원하는 호스트로 전달하고 싶은 네트워크 계층 패킷이 담겨 있다.</p>
</li>
<li data-line="38">
<p>(10%) 네트워크상 호스트 중 하나가 해당 프레임을 받으면 호스트가 프레임을 읽어보고 그 수신자가 마침 자신일 때, 길이/종류 필드의 값에 따라 페이로드에서 데이터를 꺼내어 처리한다,</p>
</li>
<li data-line="40">
<p>(10%) 네트워크에선 스위치(switch)라는 장비로 여러 호스트를 연결한다. 스위치의 포트에 호스트를 연결해 두면 스위치는 그 호스트의 MAC 주소, 혹은 IP도 같이 기억해 두었다가 그 주소로 패킷을 전달할 일이 있을 때, 연결된 여러 호스트에 일일이 보내지 않고도 해당 호스트를 특정하여 최단 경로로 보낼 수 있다</p>
</li>
<li data-line="42">
<p>(10%) 프레임 체크 시퀀스(frame check sequence, FCS)</p>
</li>
<li data-line="44">
<p>(10%) 물리 계층을 구현하고자 하는 물리적 연결 매체마다, 대응되는 하나 이상의 프로토콜이 링크 계층에 존재한다</p>
</li>
<li data-line="46">
<p>(10%) 24비트는 OUI(organizationally unique identifier), 즉 제조업체 식별 코드로 IEEE가 제조사마다 고유한 번호를 할당해 준다</p>
</li>
<li data-line="48">
<p>(10%) 나머지 24비트를 고유하게 할당하는 일은 제조업체의 책임으로, 제조사는 자신이 생산하는 하드웨어 하나마다 고윳값을 부여해야 한다</p>
</li>
</ul></div><div class="heading-wrapper"><h6 data-heading="2.4.1 이더넷/802.3" class="heading" id="2.4.1_이더넷/802.3"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.1 이더넷/802.3</h6><div class="heading-children"><div><ul>
<li data-line="0">
<p>(10%) 새 카드의 MAC 주소는 이전과 다를 테니 사용자는 더 이상 이전 주소로 접속할 수 없게 된다. 따라서 확실히 뭔가 쉽게 설정할 수 있는 주소 체계가 MAC 주소 위에 병행하여 필요하다.</p>
</li>
<li data-line="2">
<p>(10%) 인터넷의 연결 수단으로 이러한 이더넷만 사용한다면, 프레임 하나하나를 보낼 때마다 지구상 연결된 모든 호스트로 일일이 전달해야 할 것이다</p>
</li>
<li data-line="4">
<p>(10%) 네트워크 계층의 역할 수행을 위해 IPv4에선 논리 주소 체계로 각 호스트마다 개별적인 주소를 부여하며, 서브넷(subnet) 체계로 주소 공간의 논리적 부분 집합을 나누어 물리적 서브네트워크를 정의하는 데 사용한다. 아울러 라우팅 체계로 서브넷 사이에서 데이터를 서로 전달한다.</p>
</li>
<li data-line="6">
<p>(10%) 인터넷상 호스트마다 고유한 IP 주소를 부여해 두면, 발신 호스트가 패킷을 보낼 때 패킷 헤더에 목적 호스트의 IP 주소를 기록하기만 하면 된다</p>
</li>
<li data-line="8">
<p>(10%) IP 헤더 뒷부분에 옵션 필드가 여럿 붙을 수 있으므로 헤더의 길이는 가변적</p>
</li>
<li data-line="10">
<p>(10%) IP 헤더의 최소 길이는 20바이트이므로, IPv4 패킷에서 페이로드가 담을 수 있는 최대 길이는 65,515바이트로 환산된다.</p>
</li>
<li data-line="12">
<p>(11%) 대역폭을 줄이기 위한 노력의 일환</p>
</li>
<li data-line="14">
<p>(11%) 링크 계층이 패킷을 전달케 하려면 먼저 IP 주소를 링크 계층이 이해할 수 있는 주소 형태로 바꿔 프레임에 포함해 주어야 한다</p>
</li>
<li data-line="16">
<p>(11%) 이론상으로는 네트워크 계층에서 패킷을 링크 계층으로 전달하면 실제 전달이 일어나야겠지만, 유감스럽게도 이더넷 모듈은 IP 주소만으로는 패킷을 전달할 수 없다.</p>
</li>
<li data-line="18">
<p>(11%) 주소 결정 프로토콜(address resolution protocol, ARP)</p>
</li>
<li data-line="20">
<p>(11%) IP 주소 18.19.0.2를 이에 대응하는 MAC 주소로 변환하는 방법</p>
</li>
<li data-line="22">
<p>(11%) 하나는 NIC가 어느 MAC 주소에 대응되는지 질의하는 패킷 구조이고, 또 하나는 짝을 이루는 여러 NIC와 MAC 주소 쌍을 정리해둔 표이다.</p>
</li>
<li data-line="24">
<p>(11%) 이더넷 브로드캐스트 주소 FF:FF:FF:FF:FF:FF로 발신</p>
</li>
<li data-line="26">
<p>(11%) 호스트 A가 ARP 요청을 네트워크상 모든 호스트에 처음 브로드캐스트할 때, 호스트 A 자신의 MAC 주소와 IP 주소를 포함해서 보낸다. 이렇게 하면 네트워크에 연결된 다른 호스트들이 호스트 A의 정보로 미리 ARP 테이블를 갱신해 둘 수 있다.</p>
</li>
<li data-line="28">
<p>(11%) 이 시스템으로 인해 흥미로운 보안상 약점 또한 노출되는 것을 간파할 수 있을 것이다. 악성 호스트가 모든 IP를 자기 것인 양 조작한 ARP 패킷을 뿌릴 수 있다.</p>
</li>
<li data-line="30">
<p>(11%) 네트워크 알파와 브라보를 링크 계층 수준에서 연결하면 이제껏 100대의 호스트에 전달되던 이더넷 패킷이 이제 200대의 호스트로 전달되어, 전체 네트워크 트래픽이 두 배로 증가하게 된다.</p>
</li>
<li data-line="32">
<p>(11%) 네트워크 사이의 이 같은 상호작용을 실현하는 것이 네트워크 계층의 역할</p>
</li>
<li data-line="34">
<p>(11%) 호스트 R은 라우터라 불리는 특수 형태의 호스트이다. 라우터 한 대에 NIC가 여러 개 장착되며, 각 NIC마다 고유 IP 주소가 배정되어 있다. 이 경우 네트워크 알파용으로 하나가 연결되어 있고, 다른 하나는 네트워크 브라보에 연결되어 있다.</p>
</li>
<li data-line="36">
<p>(11%) 두 호스트의 IP 주소를 각각 서브넷 마스크와 비트 AND 연산하여 그 결과가 같으면, 두 호스트는 같은 서브넷에 있다고 친다</p>
</li>
<li data-line="38">
<p>(11%) 테이블에서 MAC 주소를 찾았다면 IP 모듈은 해당 MAC 주소를 포함한 링크 계층 프레임을 만들어 이를 링크 계층 모듈에 전달하여 발신한다. 테이블에서 찾지 못한 경우, ARP 모듈이 링크 계층 네트워크에서 도달 가능한 모든 호스트에 그림 2-7과 같은 ARP 패킷을 발신하여 올바른 MAC 주소를 찾고자 시도하게 된다.</p>
</li>
<li data-line="40">
<p>(11%) 네트워크망을 지역마다 서로 다른 보안 영역으로 구분해 둘 수단이 없는 것도 단점이다.</p>
</li>
<li data-line="42">
<p>(11%) 인터넷상 호스트마다 고유한 IP 주소를 부여해 두면, 발신 호스트가 패킷을 보낼 때 패킷 헤더에 목적 호스트의 IP 주소를 기록하기만 하면 된다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="2.5 네트워크 계층" class="heading" id="2.5_네트워크_계층"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.5 네트워크 계층</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="2.5.1 IPv4" class="heading" id="2.5.1_IPv4"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.5.1 IPv4</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(12%) 서브넷마다 두 개의 주소는 예약되어 있어 호스트에 할당할 수 없음에 유의하자. 하나는 네트워크 주소로, 서브넷 내 유효 IP 주소를 마스크와 비트 AND 연산한 값이다.9 또 하나는 브로드캐스트 주소로, 서브넷 마스크의 보수를 네트워크 주소와 비트 OR 연산한 값이다. 즉, 네트워크 주소상 서브넷 마스크 영역 외의 비트를 모두 1로 한 값이다.</p>
</li>
<li data-line="2">
<p>(12%) 서브넷이란 말의 정의 자체가 ‘서브넷 마스크로 비트 AND 연산 시, 같은 값이 나오는 IP 주소로 할당된 호스트의 그룹’</p>
</li>
<li data-line="4">
<p>(12%) CIDR(classless inter-domain routing) 표기법</p>
</li>
<li data-line="6">
<p>(12%) 도메인 간 라우팅과 주소 블록 할당에 사용하던 특정 서브넷 마스크의 네트워크 클래스에서 비롯되었다.</p>
</li>
<li data-line="8">
<p>(12%) 먼저 IP 모듈은 ARP 테이블을 써서 직접 라우팅할지, 아니면 간접 라우팅할지부터 결정해야 한다.</p>
</li>
<li data-line="10">
<p>(12%) 목적지 서브넷 열은 대상 IP 주소가 포함된 서브넷을 가리킨다. 게이트웨이 열은 다른 서브넷의 링크 계층으로 패킷을 전달하기 위해 거쳐야 할 현재 서브넷상 다음 호스트의 IP 주소를 가리킨다.</p>
</li>
<li data-line="12">
<p>(12%) 제2행에 등록된 게이트웨이 주소는 18.19.100.1이다. 따라서 호스트 A1은 ARP와 이더넷 모듈을 이용해 패킷을 이더넷 프레임으로 꾸려, IP 주소 18.19.100.1에 해당하는 MAC 주소를 가진 호스트로 발신한다. 이 패킷은 곧 호스트 R에 도착한다.</p>
</li>
<li data-line="14">
<p>(12%) 인터넷 서비스 공급자(internet service provider, ISP)로부터 공인 IP와 게이트웨이를 제공받아야 한다.</p>
</li>
<li data-line="16">
<p>(12%) 보안상 문제도 있는데, 네트워크 알파의 패킷을 네트워크 브라보의 특정 호스트에만 전달하고 싶어도 패킷이 브라보의 다른 호스트를 두루 거치게 되고 만다.</p>
</li>
<li data-line="18">
<p>(12%) 서브넷을 표기할 때 먼저 네트워크 주소를 쓰고 슬래시(/)로 구분한 뒤 서브넷 마스크의 1인 비트 개수를 적는 식으로 쓸 수 있다</p>
</li>
<li data-line="20">
<p>(13%) 목적지 서브넷 주소 0.0.0.0/0은 기본 주소(default address)라 하는데, 모든 IP가 이 서브넷에 포함되기 때문이다. 호스트 R이 패킷을 받았는데 그 대상 주소가 1열부터 3열까지 어느 것에도 해당하지 않는 경우라도, 마지막의 기본 주소에는 항상 대응된다.</p>
</li>
<li data-line="22">
<p>(13%) 게이트웨이가 패킷을 받아 전달할 때마다, IPv4 헤더의 TTL 필드 값이 하나씩 차감된다. TTL 값이 0이 되면, 패킷이 어디에 체류 중이었건 상관없이 마지막으로 차감했던 호스트의 IP 모듈이 패킷을 폐기한다.</p>
</li>
<li data-line="24">
<p>(13%) 많은 양의 패킷이 라우터의 NIC에 소화할 수 없을 정도로 쏟아져 들어오면 NIC가 패킷을 그냥 무시해 버릴 수도 있다</p>
</li>
<li data-line="26">
<p>(13%) NIC 중 하나가 이들 패킷 전부를 외부로 전달하여야 하는 경우, 그 NIC가 처리를 감당할 수 있을 정도로 빠르지 않다면 패킷 중 일부가 누락될 수 있다.</p>
</li>
<li data-line="28">
<p>(13%) IPv4를 포함, 네트워크 계층의 모든 프로토콜은 비신뢰성 프로토콜로 취급한다. 이는 IPv4 패킷이 발신되었다 하여 목적한바 수신자에게 반드시 전달된다는 보장이 없다는 뜻이다</p>
</li>
<li data-line="30">
<p>(13%) 비신뢰성 프로토콜은 전달 여부 및 전달 순서를 보장해주지 않는다.</p>
</li>
<li data-line="32">
<p>(13%) 패킷을 127.0.0.1로 보내려 하면 IP 모듈은 외부로 패킷을 내보내지 않는다. 대신 IP 모듈은 이 패킷을 고스란히 다시 받은 것처럼 만들어 윗단 계층이 처리하게 올려보낸다.</p>
</li>
<li data-line="34">
<p>(13%) 두 번째는 255.255.255.255로, 제로 네트워크 브로드캐스트 주소(zero network broadcast address)라 한다. 패킷을 현재 로컬 링크 계층 네트워크의 모든 호스트로 브로드캐스트하지만, 라우터를 거쳐 외부로 나가지는 못하게 한다는 의미이다.</p>
</li>
<li data-line="36">
<p>(13%) 링크 계층의 MTU 보다도 큰 패킷을 처리할 수 있을까 하는 것이다. 이에 대한 해답은 바로 패킷을 분열하는 것(fragmentation)</p>
</li>
<li data-line="38">
<p>(13%) 분열에 사용되는 헤더 필드로는 분열 식별자, 분열 플래그, 분열 오프셋 필드가 있다.</p>
</li>
<li data-line="40">
<p>(13%) MF 플래그(more fragments flag)라 하는데, 아직 남은 조각이 더 있다는 뜻이다. 이 플래그가 켜진 패킷을 받은 호스트는 남아있는 다른 조각을 모두 받을 때까지 처리를 미뤄두었다가 다 받은 후에서야 패킷을 다시 조립해 윗단 계층으로 넘겨야 한다.</p>
</li>
<li data-line="42">
<p>(13%) 0x02로 정하면 DF(don’t fragment), 즉 분열 금지 플래그가 된다. 분열 금지는 어떤 상황에서건 패킷을 분열해선 안 된다는 뜻이다.</p>
</li>
<li data-line="44">
<p>(13%) 0x04</p>
</li>
<li data-line="46"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(14%) IPv4 패킷의 분열 예제</p>
<ul>
<li data-line="47">Memo :길이총합 = 헤더길이 + 페이로드</li>
</ul>
</li>
<li data-line="49">
<p>(14%) 255.255.255.255로, 제로 네트워크 브로드캐스트 주소(zero network broadcast address)라 한다. 패킷을 현재 로컬 링크 계층 네트워크의 모든 호스트로 브로드캐스트하지만, 라우터를 거쳐 외부로 나가지는 못하게 한다는 의미이다</p>
</li>
<li data-line="51">
<p>(14%) MTU 혹은 최대 페이로드 크기는 이더넷 프레임에서 1,500바이트</p>
</li>
<li data-line="53">
<p>(14%) IPv4 패킷의 최대 크기는 위에서 본 대로 65,535바이트이다</p>
</li>
<li data-line="55">
<p>(14%) IP 모듈이 목표 링크 계층의 MTU 보다 큰 패킷을 송신해야 할 때, IP 모듈은 패킷을 MTU 크기의 여러 조각으로 패킷을 분열한다</p>
</li>
<li data-line="57">
<p>(14%) 분열 식별자 필드 값은 모두 12로, 세 조각이 모두 같은 패킷에서 비롯되었음을 나타낸다. 12라는 숫자 자체는 임의로 정한 것이지만, 아마도 이 호스트가 쪼갠 패킷 중 12번째라는 뜻일 가능성이 크다</p>
</li>
<li data-line="59">
<p>(14%) IP 모듈은 조각 수를 줄이기 위해 조각을 나눌 때 가능한 한 크게 나눈다</p>
</li>
<li data-line="61">
<p>(14%) 분열 오프셋 필드는 8바이트 블록 단위로 기재해야 하므로, 1480 나누기 8은 185, 즉 실제 기록되는 값은 185가 된다</p>
</li>
<li data-line="63">
<p>(14%) 수신자가 패킷을 받아 올바르게 처리하려면, 패킷 조각 하나하나가 최종 호스트까지 전달되어 원래의 쪼개지기 전 패킷으로 재조립되어야 한다. 네트워크 혼잡이나 라우팅 테이블 변동 또는 기타 이유로, 패킷 조각이 순서대로 도착하지 않고, 그 호스트나 여타 호스트가 보낸 완전히 다른 내용의 패킷과 뒤섞여 올 가능성도 있다.</p>
</li>
<li data-line="65">
<p>(14%) 패킷 조각은 MF 플래그가 설정되어 있거나 분열 오프셋 필드 값이 0이 아닐 터이다. 이렇게 패킷 조각을 받으면, 수신자 IP 모듈은 64kB(IP 패킷의 최대 크기) 버퍼를 만들고 조각의 데이터를 버퍼상 정확한 오프셋 위치에 복사해 넣는다</p>
</li>
<li data-line="67">
<p>(14%) MF 플래그가 꺼져 있는 조각을 받으면 원래 패킷의 길이를 계산할 수 있는데, 조각의 길이에 조각의 오프셋을 더하면 된다.</p>
</li>
<li data-line="69">
<p>(14%) IP 패킷 분열을 이용하면 거대한 패킷을 보내는 것이 가능하긴 하지만 두 가지 비효율적인 면이 있다</p>
</li>
<li data-line="71">
<p>(14%) 첫째, 네트워크로 실제 보내는 데이터양이 증가한다. 표 2-11의 3,020바이트짜리 패킷은 두 개의 1,500바이트 패킷과 60바이트 패킷으로 쪼개지는데, 이를 합치면 3,060바이트가 된다.</p>
</li>
<li data-line="73">
<p>(14%) 둘째, 조각 중 하나라도 잃어버리면 다른 조각 전체를 몽땅 버려야 한다. 조각 수가 많은 커다란 패킷일수록 잃어버릴 확률이 높다</p>
</li>
<li data-line="75">
<p>(14%) 패킷이 뉴욕에서 일본으로 간다고 상상해 보자. 패킷이 거쳐 가는 링크 계층 중 적어도 하나는 이더넷일 테니, 게임 설계 시 전체 패킷 경로의 최소 MTU를 1,500바이트로 잡아야 한다. 이 1,500바이트를 전부 IP 페이로드에 쓸 수 있는 것도 아니고 20바이트는 IP 헤더에, 또 몇 바이트는 VPN이나 IPSec 등 여타 프로토콜이 필요로하는 데이터와 나눠 써야 한다. 그러므로 IP 페이로드는 1,300바이트 내외로 잡아야 안전하다.</p>
</li>
<li data-line="77">
<p>(14%) 최대 100바이트 길이로 패킷을 보내는 게임은 대역폭의 20%를 오로지 IP 헤더에만 낭비하는 셈으로 매우 비효율적이다</p>
</li>
<li data-line="79">
<p>(14%) IP 주소를 배당하는 방식의 비효율성 그리고 PC, 모바일 기기, 사물 인터넷 등 무수히 많은 수요로 인해 32비트 고유 IP 주소는 이미 고갈된 지 오래다</p>
</li>
<li data-line="81">
<p>(14%) IPv4 보급 이래로 오랜 시간 동안 드러난 주소 고갈 문제 및 비효율성 해소14를 위해 IPv6가 고안되었다</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="2.5.2 IPv6" class="heading" id="2.5.2_IPv6"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.5.2 IPv6</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(15%) IPv6의 가장 두드러지는 특징은 바로 IP 주소의 길이가 128비트라는 점이다.</p>
</li>
<li data-line="2">
<p>(15%) IPv6 주소는 여덟 묶음의 네 글자 16진수로 표현하며, 묶음마다 콜론으로 구분한다.</p>
</li>
<li data-line="4">
<p>(15%) IPv6를 적을 때, 각 16진수 묶음(hextet)의 앞자리 0은 생략해도 된다.</p>
</li>
<li data-line="6">
<p>(15%) 첫 64비트는 보통 네트워크를 나타내며 네트워크 접두사(network prefix)라 칭한다. 나머지 64비트는 개별 호스트를 나타내어 인터페이스 식별자(interface identifier)라 한다</p>
</li>
<li data-line="8">
<p>(15%) 서버로 쓰려는 등 IP 주소를 같은 값으로 계속 유지해야 할 때는 네트워크 운영자가 인터페이스 식별자를 수동으로 지정해 주면 된다</p>
</li>
<li data-line="10">
<p>(15%) 기존 ARP에서 하던 역할은 IPv6의 NDP(neighbor discovery protocol, 인접 노드 발견 프로토콜)가 대체하는데, NDP는 뒤에서 다룰 DHCP의 기능도 일부 포함하고 있다.</p>
</li>
<li data-line="12">
<p>(15%) NDP를 이용해, 라우터는 네트워크 접두사와 라우팅 정보를 선전하고, 호스트는 각자의 IP 주소와 링크 계층 주소를 질의하고 공시한다</p>
</li>
<li data-line="14">
<p>(15%) 라우터 레벨에서는 패킷 분열을 더 이상 지원하지 않는 것도 IPv6의 개선 사항 중 하나다. 이로써 모든 분열 관련 필드를 IP 헤더에서 제거하여, 패킷의 대역폭을 절약할 수 있게 되었다.</p>
</li>
<li data-line="16">
<p>(15%) 네트워크 계층의 역할이 원격 네트워크상 서로 멀리 떨어진 호스트 사이의 통신을 촉진하는 것이라면, 전송 계층(transport layer)의 역할은 이들 호스트상 개별 프로세스 사이의 통신을 가능케 하는 것이다.</p>
</li>
<li data-line="18">
<p>(15%) 호스트 B가 IP 패킷을 받았을 때 이를 어느 프로세스에 넘겨야 계속 처리할 수 있는지 알아야 한다. 전송 계층에선 이를 위해 포트(port)라는 개념을 도입한다.</p>
</li>
<li data-line="20">
<p>(15%) IP 주소가 거리의 건물 주소라면, 포트는 건물 내 입주한 사무실 번호에 비유할 수 있다.</p>
</li>
<li data-line="22">
<p>(15%) 어떤 프로세스가 특정 포트를 바인딩(binding)해 두면, 전송 계층 모듈은 이후 그 포트로 전달되는 모든 택배를 그 프로세스에 전달해 준다.</p>
</li>
<li data-line="24">
<p>(15%) 대부분의 운영체제에서 여러 프로세스가 같은 포트에 바인딩하려 할 때 특별한 플래그를 설정해야만 이를 허용한다</p>
</li>
<li data-line="26">
<p>(15%) 포트 번호 1024부터 49151까지는 사용자 포트(user port) 또는 등록 포트(registered port)라 하는데, 프로토콜 개발자 또는 응용프로그램 개발자는 공식으로 IANA에 이 범위 내의 포트 번호를 요청할 수 있다</p>
</li>
<li data-line="28">
<p>(15%) 포트 번호 0부터 1023까지는 시스템 포트(system port) 또는 예약 포트(reserverd port)라 한다</p>
</li>
<li data-line="30">
<p>(15%) 나머지 포트 번호 49152부터 65535를 가리켜 동적 포트(dynamic port)라 한다. 동적 포트는 IANA 관할 밖이며 어느 프로세스가 쓰던 제약이 없다</p>
</li>
<li data-line="32">
<p>(15%) UDP 데이터그램은 페이로드 앞에 8바이트 헤더를 붙여서 만든다</p>
</li>
<li data-line="34">
<p>(15%) UDP는 군더더기 없는 프로토콜이다. 각 데이터그램은 자체로 완결된 것으로, 두 호스트 간 어떤 공유 상태에도 의존하지 않는다. 우체통에 일단 집어넣으면 신경 쓰지 않아도 되는 엽서에 비유해도 되겠다.</p>
</li>
<li data-line="36">
<p>(15%) UDP는 네트워크가 지척거린다고 트래픽을 제한해 주지도 않고, 데이터를 순서대로 전달해 주지도 않고, 데이터의 전달을 보장해 주지도 않는다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="2.6 전송 계층" class="heading" id="2.6_전송_계층"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.6 전송 계층</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="2.6.1 UDP" class="heading" id="2.6.1_UDP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.6.1 UDP</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(16%) UDP로 호스트 사이에 불연속적인 데이터그램만 주고받을 수 있다면, TCP(transmission control protocol)로는 양쪽의 호스트 사이에 연결을 계속 유지한 채로 신뢰성 있게 데이터의 스트림을 주고받을 수 있다.</p>
</li>
<li data-line="2">
<p>(16%) TCP는 의도된 수신자에게 모든 데이터를 순서대로 전달하려 최선을 다한다</p>
</li>
<li data-line="4">
<p>(16%) 연결된 호스트마다 간단치 않은 연결 상태 추적 메커니즘이 돌아간다. 덕분에 수신자는 데이터를 받았는지 여부를 발신자에게 ACK(acknowledgment, 확인응답)20 할 수 있으며, 발신자는 ACK가 없는 부분의 데이터를 다시 보낼 수 있다.</p>
</li>
<li data-line="6">
<p>(16%) TCP의 데이터 전송 단위를 일컬어 TCP 세그먼트(segment)라 한다</p>
</li>
<li data-line="8">
<p>(16%) ACK 번호(32비트): 발신자가 응답받기를 기다리는 다음 시퀀스 번호이다. TCP는 데이터를 모두 순서를 지켜 전송하므로 호스트가 매번 기다리는 시퀀스 번호는 그전에 받은 번호에 항상 1을 더한 값이 된다. 수신자가 ACK 번호를 보내면 그 ACK 번호에 해당하는 시퀀스뿐만 아니라 그 아래 모든 시퀀스를 받았다는 뜻이므로 주의하자.</p>
</li>
<li data-line="10">
<p>(16%) 수신 윈도(16비트): 발신자가 데이터 전송에 사용하는 버퍼 용량이 얼마나 남아있는지 알려주는 역할이다. 나중에 다루겠지만, 흐름 제어에 사용된다</p>
</li>
<li data-line="12">
<p>(16%) 고유하게 식별할 수 있는 패킷을 발신 호스트가 수신 호스트에 보내놓고 확인응답, 즉 ACK를 기다리며, 수신 호스트는 ACK를 기재한 패킷으로 응답한다. 한참 동안 ACK가 오지 않으면, 송신 호스트는 원래 패킷을 다시 보내 본다. 모든 데이터를 보내고 ACK를 받을 때까지 이 절차를 반복한다</p>
</li>
<li data-line="14">
<p>(16%) TCP가 신뢰성 전달을 하기 위해 채택한 구현 전략에선 시퀀스 번호 추적과 데이터 재전송이 필요하므로, 각 호스트는 열려 있는 모든 TCP 연결에 대해 상태 변수를 유지해야 한다.</p>
</li>
<li data-line="16">
<p>(16%) 호스트 B가 연결을 받아줄 수 있는 상황이면, SYN 플래그와 ACK 플래그 둘 다 켜진 패킷으로 응답한다. 이때 응답 패킷의 ACK 번호는 호스트 A가 처음 보내준 시퀀스 번호 더하기 1로 한다. 1000번 세그먼트는 잘 받았으니 이제 그 뒤의 세그먼트를 호스트 B가 기다리겠노라는 뜻이다</p>
</li>
<li data-line="18">
<p>(16%) 호스트 A와 B 사이의 연결에 두 개의 스트림이 한 쌍으로 존재하는데, 하나는 A에서 B로, 또 하나는 B에서 A로 가는 스트림이다</p>
</li>
<li data-line="20">
<p>(16%) 각 스트림의 시퀀스 번호 체계가 서로 다르다는 점을 유념하자. A에서 B로 가는 스트림은 호스트 A가 랜덤으로 정하고, 반대쪽은 호스트 B가 정한다.</p>
</li>
<li data-line="22">
<p>(16%) 호스트 A가 B에게서 이 세그먼트를 확인응답으로 받고나면 지금 당장은 더 보낼 데이터가 없으므로, 호스트 B가 보내준 첫 번째 시퀀스 번호를 잘 받았다고 응답만 해주면 된다. 따라서 SYN 플래그는 끄고 ACK만 켜서 호스트 B가 보내준 시퀀스 번호에 1을 더한 3001을 ACK 번호로 하여 응답한다</p>
</li>
<li data-line="24">
<p>(16%) TCP 세그먼트에 SYN이나 FIN 플래그가 들어가면, 플래그 자체를 한 바이트로 쳐서 시퀀스 번호를 하나 더 올려준다. 이를 가리켜 TCP 팬텀 바이트(TCP phantom byte)라 부르기도 한다</p>
</li>
<li data-line="26">
<p>(16%) 시간이 초과되어 호스트 A가 SYN-ACK 세그먼트를 받지 못한 경우, 호스트 A는 두 가지를 가정할 수 있다. 첫째 호스트 B가 SYN 세그먼트를 못 받았던지, 둘째 B가 응답은 보냈지만 이를 못 받았을 것이다. 두 경우 모두 호스트 A는 처음 세그먼트를 다시 보낸다.</p>
</li>
<li data-line="28">
<p>(16%) 바이트마다 연속적인 시퀀스 번호가 붙어 있으므로, 세그먼트의 시퀀스 번호는 이전 세그먼트 번호 더하기 데이터 길이와 같다</p>
</li>
<li data-line="30">
<p>(16%) 수신자는 세그먼트를 받을 때마다 ACK 패킷에 그 ACK 필드 값을 다음번 받아야 할 시퀀스 번호로 기재하여 응답한다. 이 값은 곧 가장 마지막으로 받은 세그먼트 번호 더하기 데이터 길이와 같다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="2.6.2 TCP" class="heading" id="2.6.2_TCP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.6.2 TCP</h5><div class="heading-children"><div><ul>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(17%) TCP는 데이터가 순서대로 도착하는 것도 보장한다. 기다리던 시퀀스 번호와는 다른 패킷을 호스트가 받을 경우 두 가지 처리 방법이 있다. 간단한 방법으로 순서가 안 맞는 패킷은 그냥 소각해 버리면서 원래 순서의 패킷이 도착하길 기다리는 것이다. 다른 방법은 일단 버퍼에 저장해 놓지만 ACK도 주지 않고, 응용 계층에 넘기지도 않고 그대로 갖고 있는 것이다. 이때 시퀀스 번호를 토대로 로컬 스트림 버퍼상 저장할 위치를 계산할 수 있다. 비어있던 앞쪽 세그먼트를 빠짐없이 모두 받았다면 그때 비로소 맨 마지막 세그먼트로 ACK를 날리고 통째로 응용 계층에 넘겨 계속 처리하게 한다. ACK는 그 앞의 데이터를 모두 받았다는 뜻이므로, 발신자는 마지막 ACK만 받았다고 해서 앞의 내용을 다시 보낼 필요가 없다.</p>
<ul>
<li data-line="1">Memo :서버입장에서, 많은 클라에 패킷 브로드캐스트시에도<br>
ACK 대기를 위해 임시 버퍼 유지?<br>
스트림 크기에 따라 부하 발생 여부</li>
</ul>
</li>
<li data-line="5"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(17%) CPU에서 돌아가는 복잡한 프로세스가 있으면 데이터를 소비하는 속도가 도착하는 속도를 따라가지 못하는 경우가 발생한다. 이렇게 되면 버퍼가 곧 가득 차서 추가로 수신되는 데이터는 버려진다</p>
<ul>
<li data-line="6">Memo :생산자 vs 소비자 문제</li>
</ul>
</li>
<li data-line="7">
<p>TCP에선 흐름제어로 처리</p>
</li>
<li data-line="8">
<p>생산자가 쉬어줌</p>
</li>
<li data-line="10">
<p>(17%) 다시 보내려면 원래 데이터의 사본을 들고 있어야 하는데, TCP 동작에서 매우 중요한 부분이 바로 이것이다. TCP 모듈은 데이터를 모두 보낸 것을 확인응답받을 때까지 그 데이터를 한 바이트도 빠트리지 않고 들고 있다</p>
</li>
<li data-line="12">
<p>(17%) MSS(maximum segment size, 최대 세그먼트 길이)라 한다.</p>
</li>
<li data-line="14">
<p>(17%) 발신자가 세그먼트를 보내 수신자가 받는데 걸리는 시간, 그리고 수신자가 ACK를 보내 발신자가 받는 시간을 더한 것을 왕복 시간(round trip time), 줄여서 RTT</p>
</li>
<li data-line="16">
<p>(17%) MSS를 RTT로 나누면 대역폭이 나오는데, 1500바이트/0.03초=50kbps가 된다</p>
</li>
<li data-line="18">
<p>(17%) 아무리 고속의 회선을 깔아도 중간에 이더넷 링크가 하나 끼어 있다면 고작 1993년 당시 모뎀 속도밖에 나오지 않게 되는 셈이다.</p>
<p>이 문제를 피하기 위해, TCP는 연결 중에 ACK 없이도 여러 세그먼트를 한꺼번에 보낼 수 있다. 그렇다고 무제한으로 보내면 또 문제가 발생한다</p>
</li>
<li data-line="22">
<p>(17%) 전송 계층의 데이터가 호스트에 도착하면 해당 포트에 바인딩한 프로세스가 데이터를 소비할 때까지 버퍼에 머무르게 된다. 호스트에 메모리가 아무리 많아도, 버퍼 자체는 고정된 크기로 만들어진다.</p>
</li>
<li data-line="24">
<p>(17%) TCP는 흐름 제어(flow control) 기법을 사용한다. 빠른 송신 호스트가 느린 수신 호스트를 압도하지 못하게 제어하는 기법이다.</p>
</li>
<li data-line="26">
<p>(17%) TCP 헤더엔 수신 윈도(receive window) 필드가 있어 패킷을 보낸 호스트의 수신 버퍼 여유량을 기재하게 되어 있다. 이는 곧 상대 호스트에게 말하길 “내가 이만큼의 데이터를 받을 수 있으니 그 이상 보내려면 ACK를 기다렸다가 보내라”는 의미가 된다</p>
</li>
<li data-line="28">
<p>(17%) 흐름 제어가 계속되어, 호스트 B는 항상 데이터를 받을 수 있는 여유가 얼마나 있는지 호스트 A에게 알려주어, 버퍼에 담을 수 있는 이상으로 과도한 데이터를 보내지 못하게 한다.</p>
</li>
<li data-line="30">
<p>(17%) 수신 윈도를 너무 작게 잡으면 TCP 송신에 병목 현상이 발생한다. 이를 피하려면 이론상 대역폭 최대치가 호스트 사이 링크 계층의 최대 전송률을 넘어서도록 수신 윈도를 충분히 큰 값으로 잡아야 한다</p>
</li>
<li data-line="32">
<p>(17%) 두 번째 ACK 패킷의 ACK 번호가 첫 번째 ACK를 내포하므로 앞의 것은 굳이 필요치 않기 때문이다.</p>
</li>
<li data-line="34">
<p>(17%) 비효율적으로 헤더에 낭비하는 것을 줄이고자 TCP에 지연 ACK(delayed acknowledgment)라는 규정을 두었다. 명세서에 따르면 TCP 세그먼트를 받는 호스트는 즉각 응답할 필요가 없으며 최대 500밀리초까지 기다려보고, 시간 내에 다음 세그먼트가 오지 않는 경우에만 ACK를 보내도 상관없다</p>
</li>
<li data-line="36">
<p>(17%) 흐름 제어를 통해 TCP가 느린 단말 호스트를 많은 데이터로 압도해 버리는 상황은 막을 수 있지만, 느린 네트워크나 라우터에 과부하가 걸리는 것은 어쩌지 못한다</p>
</li>
<li data-line="38">
<p>(17%) 불필요하게 네트워크 흐름이 한쪽으로 몰리는 것을 방지하고자, TCP엔 혼잡 제어(congestion control) 기법이 사용되는데, 이는 고속도로 진입로에 신호등을 두어 교통량을 통제하는 것과 유사하다. TCP 모듈은 혼잡을 줄이기 위해 ACK 없이 보낼 수 있는 데이터의 한도를 자발적으로 제한한다</p>
</li>
<li data-line="40">
<p>(17%) 송신자 자체적으로 패킷의 확인응답률 및 누락율을 집계하여 한도를 정하는 것이 차이점이다.</p>
</li>
<li data-line="42">
<p>(17%) 망 속도가 무제한인 연결이 있다고 가정하면 매 왕복 주기마다 임계치에 육박하는 패킷과 ACK를 주고받으면서 임계치는 지속해서 두 배씩 늘어나게 된다. 그러나 만일 패킷이 하나라도 누락되면, TCP 모듈은 네트워크 혼잡을 우려하여 즉시 임계치를 절반으로 줄여버린다</p>
</li>
<li data-line="44">
<p>(17%) 처음 연결을 맺을 때 TCP 모듈의 혼잡 임계치를 최대 세그먼트 길이의 낮은 배수 값으로 잡는데, 보통 두 배 정도로 한다. 이후 세그먼트의 ACK를 받을 때마다 임계치를 최대 세그먼트 길이 만큼 더해나간다</p>
</li>
<li data-line="46">
<p>(18%) 패킷의 크기를 최대 세그먼트 길이에 가능한 한 가깝게 맞추어 네트워크 혼잡을 줄이는 기법도 있다</p>
</li>
<li data-line="48">
<p>(18%) 합쳐 보내려면 TCP 모듈에 송신 데이터용 버퍼를 설치해서 윗단 계층에서 넘겨주는 데이터를 쌓아둘 필요가 있다</p>
</li>
<li data-line="50">
<p>(18%) 운영체제에서 네이글 알고리즘(Nagle’s algorithm)을 적용하여 세그먼트를 보내기 전 데이터를 쌓아두도록 규정한다. 알고리즘을 간략히 설명하면 이미 전송 중인(아직 ACK를 받지 못한) 데이터가 있을 때 이후 보낼 예정인 데이터는 쌓아두는데, 쌓인 양이 한계치를 넘어서면 그때 세그먼트로 만들어 보낸다</p>
</li>
<li data-line="52">
<p>(18%) 네이글 알고리즘은 TCP를 전송 계층 프로토콜로 하는 게임에 있어서는 그다지 달갑지 않은 존재이다. 대역폭은 절약해 주지만, 데이터를 보내는데 지연이 훨씬 커지기 때문이다</p>
</li>
<li data-line="54">
<p>(18%) 연결을 종료하기 원하는 호스트는 FIN 패킷을 보내 데이터 전송이 끝났다는 걸 알려준다.</p>
</li>
<li data-line="56">
<p>(18%) 이후 송신용 버퍼에 있는 모든 데이터를 비롯해 FIN 패킷까지 정상적인 절차로 전송하고, ACK를 받을 때까지 재전송도 통상과 같이 수행한다</p>
</li>
<li data-line="58">
<p>(18%) TCP 모듈은 더 이상 윗단 계층이 주는 데이터는 추가로 보내지 않는다. 또한, 상대편 호스트가 보내는 데이터를 받기는 하지만 모두 위에 넘기지 않고 그냥 ACK만 보낸다</p>
</li>
<li data-line="60">
<p>(18%) DHCP(dynamic host configuration protocol, 동적 호스트 설정 프로토콜)를 사용하면 기기를 네트워크에 물리기만 하면 DHCP가 설정을 자동으로 관리해 준다.</p>
</li>
<li data-line="62">
<p>(18%) DHCP 클라이언트가 호스트의 MAC 주소를 DHCPDISCOVER 메시지에 담아 UDP 주소 255.255.255.255:67에 브로드캐스트한다</p>
</li>
<li data-line="64">
<p>(18%) 새 클라이언트에 할당해 줄 IP 주소가 있다면 DHCP 서버는 DHCPOFFER 패킷을 보내준다</p>
</li>
<li data-line="66">
<p>(18%) 클라이언트가 메시지를 받으면, 할당된 IP 주소를 확인하여 이 주소를 받아들일지 결정한다. 받아들이기로 했다면 DHCPREQUEST에 제공된 주소를 담아 다시 브로드캐스트한다</p>
</li>
<li data-line="68">
<p>(18%) 아직 요청이 유용하다면 서버는 다시 브로드캐스트로 DHCPACK 메시지를 보낸다</p>
</li>
<li data-line="70">
<p>(18%) DNS(domain name system, 도메인 네임 시스템) 프로토콜은 도메인과 서브도메인 네임을 IP 주소로 해석하는 데 사용한다</p>
</li>
<li data-line="72">
<p>(18%) 도메인 네임을 IP 주소로 해석하기 위해, 브라우저는 먼저 미리 컴퓨터에 설정된 네임 서버의 IP 주소로 DNS 질의를 날린다.</p>
</li>
<li data-line="74">
<p>(18%) 네임 서버(name server)는 여러 도메인 네임에 대응되는 IP 주소 목록을 가지고 있다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="2.7 응용 계층" class="heading" id="2.7_응용_계층"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.7 응용 계층</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="2.7.1 DHCP" class="heading" id="2.7.1_DHCP"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.7.1 DHCP</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="2.7.2 DNS" class="heading" id="2.7.2_DNS"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.7.2 DNS</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(18%) 공인 IP(public IP)란 공개적으로 라우팅할 수 있다는 말로, 전 세계 인터넷상 어디서건 공인 IP로 패킷을 보내면 이 패킷이 인터넷의 여러 라우터를 거쳐 해당 호스트에 도달할 수 있다는 뜻이다.</p>
</li>
<li data-line="2">
<p>(18%) 공인 IP 주소를 고유하게 배정할 수 있게, ICANN 및 그 산하 기구는 IP 주소 공간을 큰 단위의 블록으로 나누어 이를 대기업, 대학, 인터넷 서비스 공급자 같은 대형 조직에 할당한다</p>
</li>
<li data-line="4">
<p>(18%) 다행히도 인터넷 공유기 같은 장비가 있으면 서브넷 전체 호스트를 단 하나의 공인 IP로 연결할 수 있다. 이때 사용하는 기술이 네트워크 주소 변환(network address translation), 곧 NAT다</p>
</li>
<li data-line="6">
<p>(18%) 네트워크를 NAT로 구성하려면, 서브넷의 각 호스트마다 공인 IP 대신 사설 IP(private IP)를 할당해야 한다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="2.8 NAT" class="heading" id="2.8_NAT"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.8 NAT</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(19%) 사설 IP를 사용하는 NIC는 로컬 네트워크에 연결되므로 LAN(Local Area Network) 포트라 하기도 한다</p>
</li>
<li data-line="2">
<p>(19%) 인터넷용 NIC는 전 세계에 연결할 수 있으므로, 광역 네트워크 포트 또는 WAN(Wide Area Network) 포트라 한다.</p>
</li>
<li data-line="4">
<p>(19%) 먼저 공유기의 NAT를 꺼 두었다고 가정해 보자. 게임기가 보낸 데이터그램이 공유기의 랜 포트에 전달되면, 공유기는 WAN 포트를 거쳐 인터넷으로 보낸다. 패킷은 여차여차하여 서버에 도착할 것이다.</p>
</li>
<li data-line="6">
<p>(19%) 이제 서버가 응답할 차례인데, 여기서 문제가 생긴다. IP 패킷의 발신처가 192.168.1.2이므로, 서버는 응답 패킷을 보낼 수 없다. 192.168.1.2는 사설 IP 대역인데, 인터넷의 어떤 공개 라우터도 사설 IP에는 접근할 수 없다.</p>
</li>
<li data-line="8">
<p>(19%) 이 문제를 해결하기 위해 공유기의 NAT 모듈은 통과하는 IP 패킷 발신지의 사설 IP를 공유기 자신의 공인 IP 주소로 재기입한다</p>
</li>
<li data-line="10">
<p>(19%) 서버가 받은 데이터그램은 마치 공인 IP의 공유기가 직접 보낸 것처럼 보이는데, 서버가 응답 데이터그램을 그 공유기에게 보내면 앞서 사설 IP와 달리 잘 도착한다</p>
</li>
<li data-line="12">
<p>(19%) 내부 호스트에 응답을 올바로 전달하려면, 외부에서 수신한 패킷을 어디로 전해줘야 할지 판단하는 메커니즘이 공유기에 있어야 한다</p>
</li>
<li data-line="14">
<p>(19%) 최신 공유기의 NAT 모듈은 네트워크 계층과 전송 계층의 추상화 경계를 넘나들며 이 문제에 대응한다. IP 헤더의 IP 주소뿐만 아니라, 전송 계층 헤더의 포트 번호까지 고쳐 쓰는 것이다. 이렇게 하면 앞서 매핑 메커니즘을 더 정교하게 만들 수 있다</p>
</li>
<li data-line="16">
<p>(19%) 여러 내부 호스트가 같은 외부 호스트로 패킷을 보내는 경우 또 문제가 생기기 때문이다. 외부 호스트 주소 하나에 여러 내부 호스트가 매핑되므로, 그중 어느 것인지 판단할 수 없다.</p>
</li>
<li data-line="18">
<p>(19%) 게임기의 패킷이 외부로 나가기 전 공유기에 도달하면 NAT 모듈이 그 발신자 IP 주소와 포트 번호를 NAT 테이블에 새 항목으로 추가한다. 그런 다음 아직 사용한 적 없는 포트 번호 하나를 임의로 골라 금방 추가한 항목에 같이 기재해 둔다</p>
</li>
<li data-line="20">
<p>(19%) 플레이어 A가 NAT A에 연결된 호스트 A에 서버를 띄워두고 친구인 플레이어 B를 초대한다. 플레이어 B는 NAT B에 연결된 호스트 B로 접속하려는데, NAT 때문에 B가 호스트 A에 접속할 방법이 없다. 호스트 B가 패킷을 호스트 A에 보내 접속하려 하면 B의 정보가 A의 NAT 테이블에 없기 때문에, 그 패킷은 그냥 폐기처리 된다.</p>
</li>
<li data-line="22">
<p>(19%) 첫째는 플레이어 A가 직접 공유기를 건드려 포트 포워딩 설정을 해 주는 것이다.</p>
</li>
<li data-line="24">
<p>(19%) 둘째는 훨씬 세련되고 교묘한 방법으로, 바로 STUN(simple traversal of UDP through NAT)26이라 부르는 기법이다.</p>
</li>
<li data-line="26">
<p>(19%) STUN을 쓰려면 각 플레이어의 호스트는 공인 IP로 공개된 중개 호스트, 즉 Xbox 라이브나 플레이스테이션 네트워크 서버에 연결해야 한다. 중개 호스트는, 여러 호스트가 서로 직접 연결하기 위해 필요한 작업을 중개해 주는데, 이를테면 라우터 테이블에 항목을 개설하는 방법 등을 알려준다.</p>
</li>
<li data-line="28">
<p>(19%) 대부분 라우터는 패킷의 발신자를 검사하여 원래의 발신자가 아닌 경우에는 차단한다. 라우터 A는 이 포트를 통해 들어오는 패킷 중 오로지 호스트 N의 것만 통과시킨다. 호스트 B가 이 포트로 호스트 A에 접속하려 하면 라우터 A는 그 포트로 호스트 B와 통신한 적이 없으므로 패킷을 막아버린다.</p>
</li>
<li data-line="30">
<p>(19%) 호스트 A는 게임 서버요 호스트 B는 클라이언트인데, 클라이언트가 서버에 접속하는 대신, 게임 서버가 클라이언트에 접속하다니 말이다. 게다가 라우터 B는 호스트 A를 아직 모르고 있으므로 패킷을 보내보았자 막혀버릴 것이 뻔하다. 쓸데없는 패킷을 왜 보내는 걸까. 이런 작업을 하는 이유는 바로 이 과정을 거치며 라우터 A가 테이블에 항목 하나를 만들기 때문이다.</p>
</li>
<li data-line="32">
<p>(19%) 라우터 A의 NAT 테이블에는 이미 192.168.10.2:200 항목이 외부 포트 60000에 매핑되어 있다. 그래서 패킷을 내보낼 때 60000번 포트로 내보낸다. 그리고 그 항목에 추가로 호스트 B의 정보 12.12.6.5:62000 항목을 하나 더 매핑한다. 매핑 항목을 이렇게 추가하게 만드는 것이 이 기법의 핵심이다.</p>
</li>
<li data-line="34">
<p>(19%) NAT에 관해 몇 가지 더 알아두어야 할 것이 있다. 첫째, 앞에서 설명한 기법이 모든 NAT에서 동작하는 건 아니다. 일부 NAT는 할당한 포트 번호를 계속 유지하지 않는 것도 있는데, 이를 대칭형 NAT(symmetric NAT)라 한다. 대칭형 NAT는 밖으로 나가는 요청마다 고유한 외부 포트를 할당한다. 해당 IP 주소와 포트가 이미 NAT 테이블에 있을 경우라도 그렇다. 이 때문에 STUN 메커니즘이 깨지는데, 라우터 A가 첫 패킷을 호스트 B에 보내려 할 때 새로운 외부 포트를 할당하기 때문이다. 호스트 N이 썼던 외부 포트로 호스트 B가 라우터 A와 접촉해 호스트 A에 접근하려 할 때, NAT 테이블에 해당 정보가 없으므로 패킷이 버려진다.</p>
</li>
<li data-line="36">
<p>(19%) 대칭형 NAT 중 보안이 강하지 않은 것도 있어 이들 NAT는 예측 가능한 순서로 외부 포트를 할당하는데, 이 점을 노려 포트 할당 예측(port assignment prediction)이라는 기법으로 STUN과 비슷한 트릭을 써서 대칭형 NAT를 투과하기도 한다.</p>
</li>
<li data-line="38">
<p>(19%) STUN은 UDP에서만 동작한다. 3장 버클리 소켓에서 설명하겠지만, TCP는 포트 할당 체계가 다르고 접속을 리스닝하는 포트와 데이터를 주고받는 포트가 다르므로 다른 방법을 써야 한다.</p>
</li>
<li data-line="40">
<p>(19%) NAT 라우터를 투과하는 데 많이 쓰는 방법이 또 있다. IGDP(Internet gateway device protocol)라는 방법으로, 일부 UPnP(Universal Plug and Play) 라우터가 채용하여 랜 호스트로 하여금 외부와 내부 포트 사이에 매핑을 수동으로 설정토록 하는 프로토콜이다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="2.8.1 NAT 투과" class="heading" id="2.8.1_NAT_투과"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.8.1 NAT 투과</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(20%) 링크 계층은 연결된 호스트 사이의 통신 수단을 제공하는데, 각 호스트를 고유하게 식별할 수 있는 하드웨어 주소 체계, 한 덩어리로 전송할 수 있는 최대 전송 단위를 의미하는 MTU 등이 그것이다.</p>
</li>
<li data-line="2">
<p>(20%) 네트워크 계층은 링크 계층의 하드웨어 주소 위에 논리 주소 체계를 구축하는데, 이 주소 체계로 여러 다른 링크 계층의 네트워크에 물려 있는 호스트들이 서로 통신할 수 있다.</p>
</li>
<li data-line="4">
<p>(20%) 네트워크 계층 프로토콜은 IPv4로, 직접/간접 라우팅 시스템 및 패킷 분열 기능 등을 제공한다.</p>
</li>
<li data-line="6">
<p>(20%) 전송 계층은 ‘포트’라는 개념을 통해 원격 호스트 프로세스 사이의 종단 간 통신을 지원한다. TCP와 UDP가 전송 계층에서 가장 주요한 프로토콜인데, 이 둘은 근본적으로 다른 특성을 지닌다.</p>
</li>
<li data-line="8">
<p>(20%) 사설 네트워크를 구축할 때 필요한 관리 수고를 최소화할 수 있게, 공유기의 NAT 모듈은 공인 IP 주소 하나를 네트워크 전체가 공유하여 쓸 수 있게 해 준다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="2.9 요약" class="heading" id="2.9_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.9 요약</h4><div class="heading-children"><div><ul>
<li data-line="0">(21%) 다.</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="3장 버클리 소켓" class="heading" id="3장_버클리_소켓"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3장 버클리 소켓</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="3.1 소켓 만들기" class="heading" id="3.1_소켓_만들기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 소켓 만들기</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(22%) af 파라미터는 주소 패밀리(address family)를 뜻하는데, 소켓에 사용할 네트워크 계층 프로토콜을 지정하는 데 쓴다</p>
</li>
<li data-line="2">
<p>(22%) AF_INET</p>
<pre><code>    인터넷 프로토콜(버전 4)
</code><button class="copy-code-button">복사</button></pre>
</li>
<li data-line="8">
<p>(22%) 프로세스는 실행 도중 하나 이상의 소켓(socket)을 만들고 초기화하여 소켓 API로 제어하는데, 이렇게 만든 소켓을 통해 데이터를 읽고 쓰게 된다</p>
</li>
<li data-line="10">
<p>(22%) 소켓으로 주고받을 패킷의 종류는 type 파라미터로 지정한다. 이 값에 따라 소켓이 사용하는 전송 계층 프로토콜이 패킷을 처리하는 방식이 달라진다</p>
</li>
<li data-line="12">
<p>(22%) 소켓 타입을 SOCK_STREAM으로 하면 운영체제가 소켓을 만들 때 상태유지형(stateful) 연결을 만들게 된다.</p>
</li>
<li data-line="14">
<p>(22%) SOCK_DGRAM으로 하면 연결 상태를 유지할 필요가 없으므로 최소한의 리소스만 할당하여, 개별 데이터그램 단위로만 주고받을 수 있게 된다</p>
</li>
<li data-line="16">
<p>(22%) SOCKET socket(int af, int type, int protocol);</p>
</li>
<li data-line="18">
<p>(22%) protocol 파라미터는 소켓이 데이터 전송에 실제로 사용할 프로토콜의 종류를 명시하는 데 쓴다.</p>
</li>
<li data-line="20">
<p>(22%) 보편적으로 protocol 파라미터에 지정한 값은 외부로 나가는 IP 헤더의 프로토콜 필드에 직접 기록된다.</p>
</li>
<li data-line="22">
<p>(22%) 알아두면 편리한 것은 프로토콜을 0으로 지정하면 운영체제가 알아서 소켓 형식에 맞는 디폴트 프로토콜을 골라준다는 점이다</p>
</li>
<li data-line="24">
<p>(22%) TCP 소켓을 해제할 땐 나가고 들어오는 잔여 데이터 전부가 전송이 완료되고 확인응답까지 마친 상태에서 끝내도록 하는 것이 중요하다.</p>
</li>
<li data-line="26">
<p>(22%) 소켓을 닫기 전에 전송과 수신을 중단하려면 shutdown() 함수를 호출한다.</p>
</li>
<li data-line="28">
<p>(22%) 소켓 형식을 SOCK_RAW로 하고 protocol에 0을 지정한 경우, 운영체제 대신 사용자가 직접 IP 및 전송 계층 헤더를 임의로 작성할 수 있다. 즉, 정상적인 방법으로는 수정할 수 없는 헤더 필드 값을 임의로 넣을 수 있는 것이다. 예를 들어 외부로 나가는 패킷의 TTL 값을 사용자가 원하는 대로 직접 기록할 수 있는데, Traceroute 유틸리티가 하는 일이 바로 이것이다. 여러 헤더 필드에 고의로 잘못된 값을 수작업으로 기입하고 싶다면 SOCK_RAW를 써야만 하는데, 서버에 퍼즈 테스트(fuzz test)를 하고자 할 때 이런 기법이 필요하다</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="3.2 운영체제별 API 차이" class="heading" id="3.2_운영체제별_API_차이"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 운영체제별 API 차이</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(22%) 첫째 차이점은 소켓 자체를 나타내는 자료형이 무엇인가 하는 것이다</p>
</li>
<li data-line="2">
<p>(22%) 윈도 헤더 파일을 조금 파보면 SOCKET이 UINT_PTR에 대한 typedef인 것을 알 수 있는데, 이 포인터는 소켓의 상태와 데이터를 저장하는 메모리 영역을 가리키는 것이다.</p>
</li>
<li data-line="4">
<p>(22%) POSIX 기반 플랫폼인 리눅스, macOS, 플레이스테이션에선 소켓은 그냥 int 값 하나에 불과하다.</p>
</li>
<li data-line="6">
<p>(22%) 소켓은 POSIX 파일 디스크립터(file descriptor)와도 매우 유사하다</p>
</li>
<li data-line="8">
<p>(22%) 다만 socket() 함수가 정수를 리턴하는 것에는 큰 단점이 하나 있는데, 자료형 안전성이 많이 부족하다는 것이다. 즉, 함수의 인자로 아무 정숫값이나(5×4 같이) 집어넣어도 컴파일러가 전혀 알아채지 못한다</p>
</li>
<li data-line="10">
<p>(22%) 둘째 큰 차이점은 라이브러리를 쓰기 위해 사용하는 헤더 파일이 다르다는 것이다</p>
</li>
<li data-line="12">
<p>(22%) 구식 Winsock 라이브러리는 기능도 부족하고 최적화도 덜 되어있으므로 Winsock2를 사용하는 게 좋은데, 구식 헤더 파일에서 소켓 기본 함수의 이름을 선점해 버리므로 이름이 서로 충돌한다</p>
</li>
<li data-line="14">
<p>(23%) Windows.h를 인클루드하기 전에 WinSock2.h를 먼저 <a href="?query=tag:include%ED%95%98%EA%B1%B0%EB%82%98" class="tag" target="_blank" rel="noopener">#include하거나</a>, Windows.h를 인클루드 하기에 앞서 WIN32_LEAN_AND_MEAN 매크로를 <a href="?query=tag:define%ED%95%B4%EC%95%BC" class="tag" target="_blank" rel="noopener">#define해야</a> 한다</p>
</li>
<li data-line="16">
<p>(23%) 소켓 라이브러리를 초기화하고 마무리하는 방법도 플랫폼마다 다르다. POSIX 플랫폼에선 라이브러리가 항상 활성화 상태로, 소켓을 사용하기 위해 딱히 뭔가를 먼저 해 줄 필요가 없다. 하지만 Winsock2는 명시적으로 초기화와 마무리를 해 주어야 한다</p>
</li>
<li data-line="18">
<p>(23%) WSAStartup() 호출이 실패한 경우 이후 대부분의 Winsock2 함수가 제대로 동작하지 않으니 유의하자.</p>
</li>
<li data-line="20">
<p>(23%) 프로세스가 WSACleanup()을 호출하면 현재 진행 중이던 모든 소켓 동작이 강제 종료되고 소켓 리소스는 모두 소멸된다. 따라서 Winsock을 마무리할 때 모든 소켓이 닫혀있고 사용이 끝났는지 확실히 해 두는 것이 좋다</p>
</li>
<li data-line="22">
<p>(23%) WSAStartup()은 레퍼런스 카운트되므로 WSAStartup()을 호출한 횟수만큼 WSACleanup()을 호출해야 실제 마무리 작업이 일어난다.</p>
</li>
<li data-line="24">
<p>(23%) 소켓 라이브러리에서 대부분 플랫폼 독립적인 함수 이름은 소문자로만 되어 있다. 이를테면 socket() 함수가 그렇다</p>
</li>
<li data-line="26">
<p>(23%) 윈도 전용 Winsock2 함수는 대문자로 시작하고 어떤 경우엔 WSA를 접두사로 붙여 이것이 비표준 함수라는 걸 드러낸다.</p>
</li>
<li data-line="28">
<p>(23%) 윈도용으로 개발할 때, 대문자를 쓰는 Winsock2 함수를 쓰는 부분을 따로 분리해 두면 나중에 크로스 플랫폼화할 때 POSIX 플랫폼으로 포팅하기가 수월해진다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="3.3 소켓 주소" class="heading" id="3.3_소켓_주소"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3 소켓 주소</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(23%) 모든 네트워크 계층 패킷에는 발신지 주소와 목적지 주소가 필요하다. 전송 계층 패킷은 여기에 더해 발신지 포트와 목적지 포트가 필요하다.</p>
</li>
<li data-line="2">
<p>(23%) 소켓 주소를 소켓에 사용하려면 sa_family 값이 소켓을 만들 때 썼던 af 파라미터와 일치해야 한다.</p>
</li>
<li data-line="4">
<p>(23%) 소켓 API는 클래스나 다형성, 상속 같은 객체 지향 개념이 도입되기 전에 개발되었으므로, 주소를 요구하는 소켓 API 함수에 이들 자료형을 넘기려면 sockaddr형으로 직접 캐스팅해 주어야 한다. IPv4 패킷용 주소를 만들려면 sockaddr_in형을 사용한다.</p>
</li>
<li data-line="6">
<p>(23%) in_addr 자료형은 소켓 라이브러리마다 조금씩 다르다. 어떤 플랫폼에선 그냥 4바이트 정수이다. 하지만 IPv4는 보통 4바이트 정수로 쓰기보다는, 마침표로 구분된 각 숫자를 네 개의 바이트로 쓰는 경우가 많다. 이 때문에</p>
</li>
<li data-line="8">
<p>(23%) 보통 BSD 소켓 구조체 중 하나를 초기화할 땐 항상 그 멤버를 0으로 memset()해 두는 것이 좋다.2 이렇게 하면 어떤 플랫폼에선 사용하지 않는 값이 다른 플랫폼에서 사용되면서 발생할 수 있는 이상한 문제를 미연에 방지할 수 있다.</p>
</li>
<li data-line="10">
<p>(23%) IP 주소를 4바이트 정수로 지정하거나 포트 번호를 지정할 때, 이렇게 여러 바이트를 묶어서 쓰려면 TCP/IP 스택과 호스트 컴퓨터의 바이트 순서 체계가 서로 다를 수도 있다는 점에 유의해야 한다.</p>
</li>
<li data-line="12">
<p>(23%) 소켓 API에서 제공하는 htons()와 htonl() 함수를 사용한다.</p>
</li>
<li data-line="14">
<p>(23%) ntohs()와 ntohl()를 호출해 도로 호스트 바이트 순서로 변환해 주어야 한다.</p>
</li>
<li data-line="16">
<p>(23%) 소켓 라이브러리는 자료형 안전성(type safety)에 대해선 처음부터 별다른 고민 없이 구현된 상태이다. 따라서 소켓 기본 자료형과 함수를 객체 지향 형태로 감싸두도록 애플리케이션 수준에서 구현해 두면 유용하다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="3.3.1 자료형 안전성" class="heading" id="3.3.1_자료형_안전성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.1 자료형 안전성</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="3.3.2 문자열로 sockaddr 초기화하기" class="heading" id="3.3.2_문자열로_sockaddr_초기화하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.2 문자열로 sockaddr 초기화하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(24%) 문자열을 sockaddr로 변환해야 하는 경우 POSIX 계열 시스템은 inet_pton() 함수를, 윈도에선 InetPton() 함수를 쓰면 이 작업을 편하게 할 수 있다.</p>
</li>
<li data-line="2">
<p>(24%) inet_pton() 함수는 사람이 읽을 수 있는 IP 주소 문자열을 이진 IP 주소로 변환해 주기는 하지만, 오직 IP 주소 형태의 문자열만 처리할 수 있다. 즉, 도메인 네임이나 DNS 조회(lookup) 등은 수행하지 않는다.</p>
</li>
<li data-line="4">
<p>(24%) DNS 질의(query)를 수행해 도메인 네임을 IP 주소로 변환하고 싶다면 getaddrinfo() 함수를 사용한다.</p>
</li>
<li data-line="6">
<p>(24%) getaddrinfo()가 addrinfo 구조체를 반환할 때, 자체적으로 메모리를 할당해 주므로, 반환된 연결 리스트의 내용을 다 꺼내 쓴 다음엔 호출자가 직접 freeaddrinfo()를 호출해 메모리를 해제해 주어야 한다.</p>
</li>
<li data-line="8">
<p>(24%) 몇 밀리초 내에 끝나는 경우도 있지만, 대개의 경우 초 단위의 지연이 수반될 수 있다. getaddrinfo()에는 비동기 동작을 하게끔 하는 옵션이 없으므로 호출 스레드는 응답을 받을 때까지 마냥 블로킹되어야 있어야 한다.</p>
</li>
<li data-line="10">
<p>(24%) SocketAddress 생성자 대신 이렇게 별도의 스태틱 멤버 함수로 구현하면 이같이 잘못된 경우에 예외를 던지지 않고도 적절히 처리하는 것이 가능하다. 즉, CreateIPv4FromString()이 널이 아닌 포인터를 리턴한다면 이것은 확실히 유효한 SocketAddress 객체인 셈이며, 어떤 경우에도 잘못 초기화된 객체가 존재할 가능성이 없는 것이다.</p>
</li>
<li data-line="12">
<p>(24%) 운영체제에 어떤 소켓이 특정 주소와 전송 계층 포트를 쓰겠다고 알려주는 절차를 일컬어 바인딩(binding)이라 한다.</p>
</li>
<li data-line="14">
<p>(24%) address는 소켓을 바인딩할 주소이다. 이는 패킷을 보낼 주소와는 전혀 상관이 없음을 알아두자. 목적지를 가리키는 것이 아니라 이 소켓으로 보내는 패킷의 발신지, 즉 회신 주소를 밝혀 두는 것이라 생각하면 된다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="3.3.3 소켓 바인딩하기" class="heading" id="3.3.3_소켓_바인딩하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.3 소켓 바인딩하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(25%) 바인딩 시 특정 주소를 지정하면 소켓이 어느 네트워크 인터페이스를 사용할지 명시할 수 있다. 이는 호스트가 라우터나 네트워크 사이의 브릿지로 사용되는 경우 유용하다.</p>
</li>
<li data-line="2">
<p>(25%) 호스트에 장착된 모든 네트워크 인터페이스의 IP 주소의 해당 포트에 몽땅 바인딩하는 것이 바람직할 때가 많다. 이렇게 하려면 바인딩할 주소로 sockaddr_in의 sin_addr 필드에 INADDR_ANY 매크로 값6을 넣어주면 된다.</p>
</li>
<li data-line="4">
<p>(25%) 소켓에 sockaddr을 바인딩하는 건 두 가지를 의미한다. 첫째, 운영체제가 이 주소와 포트를 목적지로 발신된 패킷을 수신하면 운영체제는 이제 이 소켓으로 넘겨준다. 둘째, bind()에서 지정한 주소 및 포트를 이 소켓을 통해 나가는 패킷의 네트워크 계층과 전송 계층 헤더의 발신 주소와 포트로 운영체제가 쓰게 된다.</p>
</li>
<li data-line="6">
<p>(25%) 데이터를 전송하거나 수신하려면 반드시 소켓이 바인딩되어 있어야 한다. 만일 아직 바인딩되지 않은 소켓으로 데이터를 보내려 하면 네트워크 라이브러리는 먼저 자동으로 남아 있는 포트에 소켓을 바인딩해 준다. 따라서 주소와 포트를 확실히 고정해두려는 것이 아니라면 굳이 바인딩할 필요가 없다. 단, 외부에 공표한 주소와 포트로 패킷을 받아야 하는 서버를 만들 때는 바인딩이 필요할 것이다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="3.4 UDP 소켓" class="heading" id="3.4_UDP_소켓"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.4 UDP 소켓</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="3.4.1 자료형 안전성을 보강한 UDP 소켓" class="heading" id="3.4.1_자료형_안전성을_보강한_UDP_소켓"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.4.1 자료형 안전성을 보강한 UDP 소켓</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(26%) UDP 소켓은 만든 즉시 데이터를 보낼 수 있다</p>
</li>
<li data-line="2">
<p>(26%) 데이터를 보내려면 sendto() 함수를 사용한다.<br>
int sendto(SOCKET sock, const char<em> buf, int len, int flags,<br>
const sockaddr</em> to, int tolen);</p>
</li>
<li data-line="6">
<p>(26%) sock은 데이터그램을 보낼 소켓</p>
</li>
<li data-line="8">
<p>(26%) buf는 보낼 데이터의 시작 주소를 가리키는 포인터</p>
</li>
<li data-line="10">
<p>(26%) len은 데이터의 길이다</p>
</li>
<li data-line="12">
<p>(26%) flags는 데이터 전송을 제어하는 비트 플래그이다. 대부분 게임 코드에선 0으로 둔다.</p>
</li>
<li data-line="14">
<p>(26%) 분열을 피하려면 데이터그램의 길이는 1,300바이트 이내로 해야 한다</p>
</li>
<li data-line="16">
<p>(26%) to는 수신자의 목적지를 가리키는 sockaddr이다.</p>
</li>
<li data-line="18">
<p>(26%) 여기의 주소 패밀리는 소켓을 만들 때 지정한 주소 패밀리와 일치해야 한다</p>
</li>
<li data-line="20">
<p>(26%) tolen은 sockaddr의 길이를 지정</p>
</li>
<li data-line="22">
<p>(26%) UDP 소켓으로 데이터를 받으려면 별다른 절차 없이 recvfrom() 함수를 호출한다.</p>
</li>
<li data-line="24">
<p>(26%) MSG_PEEK 플래그</p>
</li>
<li data-line="26">
<p>(26%) 이 플래그를 지정하면 수신된 데이터그램을 buf에 복사한 다음 데이터그램을 입력 대기열에서 제거하지 않는다. 이렇게 하면 다음번 recvfrom() 호출에서 더 큰 버퍼를 할당해 같은 데이터그램을 다시 받아볼 수 있다.</p>
</li>
<li data-line="28">
<p>(26%) from은 sockaddr 구조체의 포인터로, recvfrom() 함수가 데이터를 받았을 때 그 발신자의 주소와 포트를 채워줄 곳을 가리킨다.</p>
</li>
<li data-line="30">
<p>(26%) 여기에 주소를 넣어서 호출해도 그 주소에다 데이터를 보내 달라고 요청하는 것이 아니다.</p>
</li>
<li data-line="32">
<p>(26%) UDP는 여러 발신자가 하나의 주소와 포트 조합에 패킷을 보낼 수 있으므로, 각각의 데이터그램이 어느 발신자로부터 수신되었는지 확인하는 용도로 이 파라미터에 주소와 포트를 채워 주는 것</p>
</li>
<li data-line="34">
<p>(26%) UDPSocket을 friend 클래스로 선언해 두어야 한다. 이 방식으로 구현하면 모듈 외부에서는 sockaddr을 직접 수정할 수 없지만 모듈 안에서는 자유롭게 이용이 가능하며, 구현도 편해지고 종속성이나 잠재적인 오류도 줄일 수 있어서 좋다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="3.5 TCP 소켓" class="heading" id="3.5_TCP_소켓"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5 TCP 소켓</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="3.5.1 연결된 소켓으로 데이터 보내고 받기" class="heading" id="3.5.1_연결된_소켓으로_데이터_보내고_받기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.1 연결된 소켓으로 데이터 보내고 받기</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="3.5.2 자료형 안전성을 보강한 TCP 소켓" class="heading" id="3.5.2_자료형_안전성을_보강한_TCP_소켓"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5.2 자료형 안전성을 보강한 TCP 소켓</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(27%) UDP는 내부 상태가 없고 연결을 유지하지 않으며 신뢰성을 보장하지 않는다. 따라서 호스트마다 하나의 소켓만 있으면 데이터그램을 보내고 받기를 다 할 수 있다</p>
</li>
<li data-line="2">
<p>(27%) TCP는 신뢰성을 보장하며, 데이터를 주고받기 위해 두 호스트 사이에 연결을 맺어 두어야 한다. 추가로, 누락된 패킷을 재전송하기 위해 상태 정보를 유지하고 이를 어딘가 저장해 두어야 한다.</p>
</li>
<li data-line="4">
<p>(27%) 서버가 핸드셰이킹 첫 단계를 받으려면, 먼저 소켓을 만들어 두고 이 소켓을 특정 포트에 바인딩한 뒤 들어오는 핸드셰이킹을 리스닝(listening)해야 한다.</p>
</li>
<li data-line="6">
<p>(27%) backlog에는 들어오는 연결을 대기열에 둘 최대 숫자를 지정한다.</p>
</li>
<li data-line="8">
<p>(27%) accept()가 성공하면 내부적으로 새 소켓이 만들어져 리턴되며 이 소켓은 이후 그 원격 호스트와 통신하는 용도로 쓸 수 있다</p>
</li>
<li data-line="10">
<p>(27%) 새 소켓은 리스닝 소켓과 같은 포트에 바인딩된다. 한 포트에 여러 소켓이 바인딩되는 셈인데, 운영체제가 그 포트를 목적지로 하는 패킷을 받으면 그 발신자 주소와 포트를 보고 어느 소켓으로 보낼지 결정한다</p>
</li>
<li data-line="12">
<p>(27%) accept()가 리턴한 새 소켓은 연결이 수립된 원격 호스트에 대응된다. 여기에 원격 호스트의 주소와 포트가 기록되어 있고, 이 호스트로 보내는 패킷 전부가 저장되어 있어 나중에 누락이 발생한 경우 재전송 용도로 사용된다.</p>
</li>
<li data-line="14">
<p>(27%) 리스닝 소켓은 새로 들어오는 연결 요청을 마중하여 이를 전담해 줄 새로운 소켓을 만들어 주는 역할만 할 뿐이다.</p>
</li>
<li data-line="16">
<p>(27%) 서버는 listen() 상태에서 accept()를 호출해 접속을 기다려야 하지만 클라이언트는 소켓을 만든 다음 connect()만 호출하면 된다</p>
</li>
<li data-line="18">
<p>(27%) connect()를 호출하면 최초 SYN 패킷을 대상 호스트에 전송하여 TCP 핸드셰이킹을 개시한다.</p>
</li>
<li data-line="20">
<p>(27%) 데이터는 소켓의 외부 전송용 버퍼에 추가되었다가 이후 소켓 라이브러리에 의해 적당한 시기에 전송된다.</p>
</li>
<li data-line="22">
<p>(27%) len은 전송할 데이터의 바이트 수이다. UDP와는 달리 이 값을 링크 계층의 MTU보다 작게 잡을 필요가 전혀 없다. 소켓의 전송 버퍼에 자리가 있는 한 네트워크 라이브러리는 데이터를 모두 보낼 수 있으며, 이를 위해 데이터를 적당한 크기의 덩어리로 잘라서 보내게 될 것이다.</p>
</li>
<li data-line="24">
<p>(27%) TCP로 연결된 소켓에 sendto()나 recvfrom()을 쓸 수도 있다. 하지만 호출자가 지정한 address 인자가 무시되어 헷갈릴 것이다.</p>
</li>
<li data-line="26">
<p>(27%) UDP 소켓에 connect()를 호출하는 걸 허용하기도 하는데, 이렇게 하면 원격 호스트의 주소와 포트를 소켓 내부의 연결 데이터에 각인시키는 효과가 있다</p>
</li>
<li data-line="28">
<p>(27%) 대신 send() 함수로 데이터를 보낼 때 매번 주소를 넘겨줄 필요가 없게 된다</p>
</li>
<li data-line="30">
<p>(27%) 들어오는 데이터그램 중 connect()에 지정하지 않은 주소 포트 조합의 것은 무시하게 만드는 효과도 있다.</p>
</li>
<li data-line="32">
<p>(27%) 소켓이 논블로킹 모드로 설정되면 블로킹을 거는 대신 즉시 리턴하며, 그 결과는 -1이 된다.</p>
</li>
<li data-line="34">
<p>(27%) 플랫폼마다 errno에서 EAGAIN, WSAGetLastError()에서 WSAEWOULDBLOCK이 된다. 이 코드의 뜻은 앞서 소켓 동작이 원래 블로킹되었어야 하는데 그러지 않고 빠져나왔다는 뜻이다.</p>
</li>
<li data-line="36">
<p>(27%) 윈도에서 소켓을 논블로킹 모드로 만들려면 ioctlsocket() 함수를 사용한다.</p>
</li>
<li data-line="38">
<p>(27%) argp는 파라미터에 설정하려는 값이다. 0이 아닌 값을 넣으면 논블로킹 모드가 되고, 0을 넣으면 블로킹 모드가 된다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="3.6 블로킹 I/O와 논블로킹 I/O" class="heading" id="3.6_블로킹_I/O와_논블로킹_I/O"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.6 블로킹 I/O와 논블로킹 I/O</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="3.6.1 멀티스레딩" class="heading" id="3.6.1_멀티스레딩"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.6.1 멀티스레딩</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="3.6.2 논블로킹 I/O" class="heading" id="3.6.2_논블로킹_I/O"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.6.2 논블로킹 I/O</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(28%) 소켓 관련 함수는 대부분 블로킹(blocking) 호출이다</p>
</li>
<li data-line="2">
<p>(28%) 메인 스레드에서 패킷을 처리하려 한다면 이는 바람직하지 않다. 게임과 같은 실시간 응용프로그램에서 이렇게 블로킹되는 호출은 문제를 야기하는데, 프레임 레이트를 유지한 채로 네트워크를 처리할 수 없기 때문이다</p>
</li>
<li data-line="4">
<p>(28%) 블로킹 I/O의 단점을 극복하는 한 가지 방법은 블로킹 가능성이 있는 각 함수의 호출을 별도의 스레드에서 수행하는 것이다.</p>
</li>
<li data-line="6">
<p>(28%) 클라이언트 데이터가 병렬적으로 한꺼번에 여러 스레드에서 들어올 수 있으므로 시뮬레이션에 데이터를 안전하게 전달하기 까다로운 문제도 있다</p>
</li>
<li data-line="8">
<p>(28%) 스레드가 데이터를 받는 도중, 메인 스레드가 같은 소켓에 데이터를 보내려 하면 여전히 블로킹될 수밖에 없는 맹점이 있다</p>
</li>
<li data-line="10">
<p>(28%) 클라이언트마다 하나씩 스레드를 할당해야 한다는 단점이 있다. 그러면 클라이언트 수가 증가할수록 대처하기 힘들어진다</p>
</li>
<li data-line="12">
<p>(28%) 프레임당 처리할 데이터그램 개수에 제약을 꼭 두어야 한다. 그러지 않으면 서버가 처리할 수 있는 능력 이상으로 악성 클라이언트가 1바이트짜리 데이터그램을 반복해 쏟아부어 서버가 게임 시뮬레이션을 하지 못하게 만들 수 있기 때문이다.</p>
</li>
<li data-line="14">
<p>(28%) 폴링해야 할 소켓의 수가 상당히 많다면 이 방법도 효율이 떨어지게 된다. 이에 대한 대안으로 소켓 라이브러리에는 여러 소켓을 한꺼번에 확인하고 그중 하나라도 준비되면 즉시 대응할 수 있는 방법이 마련되어 있다. 바로 select() 함수가 그것이다.</p>
</li>
<li data-line="16">
<p>(28%) readfds는 소켓 컬렉션을 가리키는 포인터이며 fd_set형이다.</p>
</li>
<li data-line="18">
<p>(28%) select()가 리턴하였을 때 아직 readfds 집합에 남아있는 소켓은 읽을 데이터가 있는 상태이며, 여기서 데이터를 읽으면 블로킹되지 않고 읽을 수 있다.</p>
</li>
<li data-line="20">
<p>(28%) writefds는 쓰기용으로 체크하고 싶은 소켓을 담은 fd_set이다. select()가 리턴한 뒤 writefds에 아직 남아있는 소켓은 쓰기 작업을 해도 호출 스레드가 블로킹 걸리지 않는다.</p>
</li>
<li data-line="22">
<p>(28%) select() 함수는 리턴하는 시점에서 readfds, writefds, exceptfds에 남아있는 소켓의 개수를 리턴한다.</p>
</li>
<li data-line="24">
<p>(28%) fd_set을 그대로 쓰지 않고 vector로 래핑하는 이유는 리턴된 집합 내에 포함된 소켓을 쉽게 순회하기 위해서다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="3.6.3 select() 함수" class="heading" id="3.6.3_select()_함수"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.6.3 select() 함수</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(29%) Select()를 호출해 readBlockSockets의 소켓 중 하나에 패킷이 수신될 때까지 블로킹 상태에 빠진다. Select() 결과 readableSockets에는 실제 데이터가 수신된 소켓만 남게 된다. 이후 이들 읽을거리가 있는 소켓을 순회하여 데이터를 읽어 들인다.</p>
</li>
<li data-line="2">
<p>(29%) 소켓에 옵션을 지정하려면 setsockopt()를 호출한다.</p>
</li>
<li data-line="4">
<p>(29%) level과 optname을 쌍으로 하여 옵션의 종류를 지정한다. 레벨은 옵션의 범주를 나타내는 정숫값이고, optname은 개별 옵션을 뜻한다.</p>
</li>
<li data-line="6">
<p>(29%) SO_RCVBUF</p>
</li>
<li data-line="8">
<p>(29%) 이 소켓이 수신용으로 쓸 버퍼의 크기를 지정한다.</p>
</li>
<li data-line="10">
<p>(29%) TCP 대역폭은 수신 윈도의 크기에 좌우되며, 소켓의 수신 버퍼 크기보다 결코 커질 수 없으므로, 이 값을 바꾸면 대역폭에 큰 영향을 미치게 된다.</p>
</li>
<li data-line="12">
<p>(29%) SO_REUSEADDR</p>
</li>
<li data-line="14">
<p>(29%) 네트워크 계층이 다른 소켓에 이미 할당된 IP 주소와 포트 쌍에 중복하여 바인딩하는 것을 허용할지를 결정한다.</p>
</li>
<li data-line="16">
<p>(29%) 디버깅 또는 패킷 스니핑 프로그램을 만들 때 유용하다. 어떤 운영체제에선 관리자 권한이 있어야 이 옵션을 실행할 수 있다.</p>
</li>
<li data-line="18">
<p>(29%) SO_RECVTIMEO</p>
</li>
<li data-line="20">
<p>(29%) 수신 동작의 블로킹 호출 제한 시간을 설정한다.</p>
</li>
<li data-line="22">
<p>(29%) SO_SNDBUF</p>
</li>
<li data-line="24">
<p>(29%) 이 소켓이 송신용으로 쓸 버퍼의 크기를 지정한다. 송신 대역폭은 링크 계층에 좌우된다.</p>
</li>
<li data-line="26">
<p>(29%) SO_SNDTIMEO</p>
</li>
<li data-line="28">
<p>(29%) 송신 동작의 블로킹 호출 제한 시간을 설정한다.</p>
</li>
<li data-line="30">
<p>(29%) SO_KEEPALIVE</p>
</li>
<li data-line="32">
<p>(29%) TCP같이 연결 지향형 프로토콜에만 유용하다. 이 옵션은 소켓이 주기적으로 연결 유지(keep alive) 패킷을 상대편에 보낼지를 지정한다.</p>
</li>
<li data-line="34">
<p>(29%) 이 옵션은 연결이 끊어졌는지 판단하는 데만 쓰는 것이 아니라, 주기적으로 패킷을 보내는 속성 때문에 연결에 시간제한을 두는 방화벽 또는 NAT 하에서 연결을 유지토록 만드는 데도 도움이 된다.</p>
</li>
<li data-line="36">
<p>(29%) TCP_NODELAY</p>
</li>
<li data-line="38">
<p>(29%) 이 소켓에 네이글 알고리즘을 사용할지 여부를 지정한다. true로 지정하면 네이글을 사용하지 않도록 하여, 데이터 전송 요청 이후 실제 전송이 일어나기까지 지연 시간이 줄어든다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="3.7 소켓 부가 옵션" class="heading" id="3.7_소켓_부가_옵션"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.7 소켓 부가 옵션</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(29%) 라이브러리의 핵심 자료형은 sockaddr로, 이것으로 여러 네트워크 계층 프로토콜의 주소를 나타낼 수 있다.</p>
</li>
<li data-line="2">
<p>(29%) UDP 소켓은 연결이 유지되지 않고 내부 상태도 없다. SOCK_DGRAM으로 socket() 함수를 호출해 UDP 소켓을 만들고 여기에 sendto()로 데이터그램을 보내면 된다. UDP 소켓에서 UDP 패킷을 받으려면 먼저 운영체제가 포트 하나를 배정해 주도록 bind() 함수를 호출한 다음, recvfrom()을 호출해 들어오는 데이터를 받으면 된다.</p>
</li>
<li data-line="4">
<p>(29%) TCP 소켓은 내부 상태가 있으며, 데이터를 전송하기 전에 먼저 연결을 맺어야 한다. 연결을 맺으려면 connect() 함수를 호출한다. 연결을 받기 위해 리스닝하려면 listen() 함수를 호출한다. 리스닝 중인 소켓에 연결이 들어오면 accept() 함수를 호출해 새 소켓을 만들어 이쪽의 종단점으로 삼는다. 연결된 소켓에 데이터를 보내려면 send() 함수를, 읽으려면 recv() 함수를 호출한다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="3.8 요약" class="heading" id="3.8_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.8 요약</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(30%) select( ) 예제에서 수천 개의 연결을 처리한다고 하면, 매 프레임마다 벡터에 수천 개씩 넣어서 폴링하고, 그 결과를 리턴하기 위해 또 수천 개씩 첨삭하는 작업을 반복해야 한다.</p>
</li>
<li data-line="2">
<p>(30%) 이에 반해 IOCP는 비동기식 이벤트 주도형이라는 것이 주된 차이점이다. IOCP는 어떤 소켓에 데이터가 오면 콜백으로 알려주므로, 애당초 데이터가 왔는지 매번 들여다볼 필요가 없다.</p>
</li>
<li data-line="4">
<p>(30%) IOCP와 유사한 것으로 macOS엔 kqueue나 GCD, 리눅스엔 e-poll 등이 있는데,</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="4장 객체 직렬화" class="heading" id="4장_객체_직렬화"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4장 객체 직렬화</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="4.1 직렬화가 필요한 이유" class="heading" id="4.1_직렬화가_필요한_이유"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 직렬화가 필요한 이유</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(31%) 직렬화(serialization)란 어떤 객체가 랜덤 액세스(random access) 가능한 형태로 메모리상에 존재할 때, 이를 일련의 여러 비트로 변환하여 길게 나열하는 것</p>
</li>
<li data-line="2">
<p>(31%) 함수를 호출할 땐 전송할 데이터의 위치를 가리키는 포인터를 인자로 넣어준다</p>
</li>
<li data-line="4">
<p>(31%) 호출자에게 돌려줄 RoboCat 포인터를 char*로 캐스팅하는데, 이렇게 하면 수신할 구조체의 포인터 위치에 소켓 함수가 직접 데이터를 기록하게 된다.</p>
</li>
<li data-line="6">
<p>(32%) RoboCat의 첫 4바이트는 가상 함수 테이블(virtual function table)을 가리키는 포인터가 되었다</p>
</li>
<li data-line="8">
<p>(32%) RoboCat에 가상 함수 RoboCat::Update()가 추가되었으므로</p>
</li>
<li data-line="10">
<p>(32%) 이 포인터 값을 나이브하게 송수신하면 제대로 동작하지 않는데 왜냐하면 실행되는 프로세스마다 가상 함수 테이블의 위치가 같다는 보장이 없기 때문이다</p>
</li>
<li data-line="12">
<p>(32%) 포인터를 다른 프로세스에 무작정 전송해 놓고선 그쪽 메모리에도 정확히 해당 위치에 같은 값이 있겠거니 기대해선 곤란하다.</p>
</li>
<li data-line="14">
<p>(32%) 대역폭 절약은 네트워크 담당 프로그래머의 필수 덕목으로, 불필요한 데이터는 가능한 직렬화하지 않아야 좋은 직렬화 시스템이라 하겠다</p>
</li>
<li data-line="16">
<p>(32%) mName 필드가 C 표준 널 종료 문자열이므로 문자열을 널 표시까지만(표시 포함) 전송하면 대역폭을 절약할 수 있다.</p>
</li>
<li data-line="18">
<p>(32%) 블랙박스화된 대부분 데이터 구조체는 나이브하게 직렬화하는 것이 불가능하다.</p>
</li>
<li data-line="20">
<p>(32%) RoboCat 하나 분량의 데이터를 보내고자 할 때 각 필드를 제각기 직렬화하여 보내는 것</p>
</li>
<li data-line="22">
<p>(32%) 객체 하나를 전송할 때 그 객체와 관련된 데이터를 버퍼 하나에 모아두었다가 그 버퍼를 통째로 전송하는 게 낫다</p>
</li>
<li data-line="24">
<p>(31%) 메모리 스트림은 메모리 버퍼를 감싸둔 것이다. 이때 메모리 버퍼는 힙(heap)에 동적으로 할당한다.</p>
</li>
<li data-line="26">
<p>(31%) 출력 메모리 스트림에는 순차적으로 버퍼에 기록하는 함수가 있는데, 기록된 내용을 나중에 읽어볼 수 있게끔 접근하는 멤버 함수도 있다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="4.2 스트림" class="heading" id="4.2_스트림"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 스트림</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="4.2.1 메모리 스트림" class="heading" id="4.2.1_메모리_스트림"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 메모리 스트림</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(32%) 스트림(stream)이란 순서가 있는 데이터 원소의 집합을 캡슐화하여 유저가 그 데이터를 읽거나 쓸 수 있게 해 주는 자료구조이다.</p>
</li>
<li data-line="2">
<p>(32%) 스트림은 출력 스트림이거나 입력 스트림, 혹은 입출력 스트림 셋 중 하나이다</p>
</li>
<li data-line="4">
<p>(32%) 데이터 구조체나 컴퓨팅 자원을 내부에 감싸두고, 스트림을 이에 접근하는 인터페이스로 제공하는 경우도 많다.</p>
</li>
<li data-line="6">
<p>(32%) 네트워크 스트림으로 소켓의 send()와 recv() 함수를 감싸두면 사용자에게 필요한 특정 자료형을 간편하게 읽거나 쓸 수 있다.</p>
</li>
<li data-line="8">
<p>(32%) // 원시 자료형인지 여부를 컴파일 타임에 검사<br>
static_assert<span class="dataview inline-field"><span class="dataview inline-field-standalone-value" id="dataview-inline-field-0"><span></span></span></span>;</p>
</li>
<li data-line="14">
<p>(32%) 데이터를 기록하는 도중 mBuffer의 용량이 모자라게 되는 경우, 버퍼가 두 배 또는 기록에 필요한 만큼 확장된다. 이는 흔한 메모리 확장 기법으로, 몇 배수로 확장할지는 필요한 목적에 따라 달리한다.</p>
</li>
<li data-line="16">
<p>(32%) GetBufferPtr() 함수가 제공되어 스트림의 내부 버퍼의 포인트에 접근할 수 있지만, 이 버퍼의 소유권은 스트림이 갖고 있으니 주의하자. 다시 말해 스트림이 해제되면 이 포인터도 무효가 된다.</p>
</li>
<li data-line="18">
<p>(32%) 이 방법을 본격적인 게임 개발에 도입할 때 주의할 점은, 스트림용 메모리를 최대 가능한 용량으로 미리 할당해 두어야 한다는 것이다. 패킷이 도착할 때마다 메모리를 할당해선 안 된다. 메모리 할당 작업이 느린 경우도 있기 때문이다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="4.2.2 엔디언 호환성" class="heading" id="4.2.2_엔디언_호환성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 엔디언 호환성</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(33%) 리틀 엔디언 플랫폼에선 여러 바이트로 구성되는 숫자를 가장 작은 자리의 바이트부터 먼저 기재한다.</p>
</li>
<li data-line="2">
<p>(33%) 빅 엔디언은 반대로 최상위 바이트3를 가장 먼저 저장한다.</p>
</li>
<li data-line="4">
<p>(33%) 최하위 바이트2 0x78이 메모리 앞부분에 저장되었다.</p>
</li>
<li data-line="6">
<p>(33%) 엔디언이 다른 플랫폼으로 데이터를 전송해야 하거나 포팅할 때는 반드시 고려해야 할 중요한 사항이다</p>
</li>
<li data-line="8">
<p>(33%) 스트림으로 데이터를 전송할 때 좋은 전략 중 하나는 스트림 자체에서 엔디언 검사를 하는 것이다</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="4.2.3 비트 스트림" class="heading" id="4.2.3_비트_스트림"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3 비트 스트림</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(34%) 바이트 스와핑(byte swapping), 즉 순서 뒤집기용 알고리즘이 제공</p>
</li>
<li data-line="2">
<p>(34%) 자료형 별칭(type aliaser) 클래스</p>
</li>
<li data-line="4">
<p>(34%) 플랫폼의 엔디언이 스트림과 다를 때, 바이트 스와핑을 해야 하는 경우가 있고 그렇지 않은 경우가 있다. 일례로 MBCS나 UTF-16 이상 유니코드의 경우, 문자열의 각 문자마다 스와핑해야 하지만 단일 바이트 단위 문자열이면 그럴 필요가 없다</p>
</li>
<li data-line="6">
<p>(34%) 네트워크 코드를 작성하다 보면 비트 수를 최대한 절약하는 것이 바람직하므로 비트 단위로 읽거나 쓰고 싶을 때가 있다.</p>
</li>
<li data-line="8">
<p>(35%) 바이트 하나를 매개변수로 받아 지정된 비트 수만큼 비트를 추출하여 스트림에 기록한다</p>
</li>
<li data-line="10">
<p>(35%) mBitHead는 다음번 스트림에 기록할 비트 위치를 나타내는 역할</p>
</li>
<li data-line="12">
<p>(35%) mBitHead를 바이트 인덱스와 그 바이트에서의 비트 인덱스로 쪼갠다</p>
</li>
<li data-line="14">
<p>(35%) 1바이트는 8비트이므로 mBitHead를<br>
8로 나누면 바이트 인덱스를 얻을 수 있다.</p>
</li>
<li data-line="17">
<p>(35%) 바이트 내 비트 인덱스는 8에 대한 나머지, 또는 시프트하다 버려지는 3비트를 구하면 된다</p>
</li>
<li data-line="19">
<p>(35%) 앞서 왼쪽으로 시프트할 때 오버플로 되어버렸던 상위 비트들이, 오른쪽으로 시프트하면 이제 하위 비트가 된다.</p>
</li>
<li data-line="21">
<p>(35%) 기록하려는 데이터마다 비트 수를 기재해 주어야 하기 때문이다. 대부분의 경우 비트 수의 상한선은 기록하려는 자료형에 따라 결정된다</p>
</li>
<li data-line="23">
<p>(35%) Write()를 템플릿으로 하더라도 특정 오버로드, 예를 들어 bool 같은 건 따로 구현해 두는 편이 좋은데 왜냐하면, bool의 비트 수를 위의 코드로 계산하면 sizeof(bool) * 8, 즉 8비트가 나오는데 bool은 1비트이지 8비트가 아니므로 틀린 계산</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="4.3 참조된 데이터 처리" class="heading" id="4.3_참조된_데이터_처리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3 참조된 데이터 처리</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(35%) vector를 통째로 직렬화하기보다는, 커스텀 직렬화 함수를 작성해 vector에 저장된 데이터만 기록하게 해야 한다.</p>
</li>
<li data-line="2">
<p>(35%) 커스텀 함수는 이 데이터를 스트림상 RoboCat의 다른 데이터와 연이어 중간에 박아 넣는데, 이렇게 독립적인 데이터를 다른 데이터 중간에 끼워 넣는 것을 임베딩(embedding) 또는 인라이닝(inlining)이라 한다.</p>
</li>
<li data-line="4">
<p>(35%) 먼저 벡터의 길이를 기록하고, 그다음 벡터에 들어 있는 모든 데이터를 기록하는 식으로 직렬화를 진행한다.</p>
</li>
<li data-line="6">
<p>(35%) Write()에서 먼저 벡터의 길이부터 기록하는 것에 유의하자. 그래야만 대칭되는 Read()에서 나중에 읽어 들일 때 적절한 길이의 벡터를 먼저 할당해 두고 내용물을 읽어 들일 수 있기 때문이다.</p>
</li>
<li data-line="8">
<p>(35%) 특수화된 Read()와 Write()를 더 추가하면 더욱 다양한 형태의 컨테이너, 또는 포인터로 참조된 데이터를 지원할 수 있다.</p>
</li>
<li data-line="10">
<p>(35%) 어떤 데이터는 하나 이상의 포인터로 여러 곳에서 참조되는 경우가 있다.</p>
</li>
<li data-line="12">
<p>(35%) 개의 RoboCat 인스턴스가 같은 기지 객체를 참조하고 있다면 지금까지 만든 코드로는 이를 표현할 방법이 아직 없다. 임베딩 기법으로는 같은 기지 객체를 두 RoboCat이 제각기 복사하여 직렬화하게 된다. 원래 하나만 있어야 할 기지 객체가 복원 시 똑같은 내용으로 두 개 만들어지고 말 것이다!</p>
</li>
<li data-line="14">
<p>(35%) 데이터 구조 자체가 임베딩이 아예 불가능한 경우가 있다.</p>
</li>
<li data-line="16">
<p>(35%) 무한 재귀 호출로 스택 오버플로가 나기 십상이다.</p>
</li>
<li data-line="18">
<p>(35%) 여러 번 참조될 법한 객체에 고유 식별자 혹은 ID를 부여해 두었다가 이들 객체를 직렬화할 때 오로지 식별자 값만 직렬화하는 것이다.</p>
</li>
<li data-line="20">
<p>(35%) 객체를 사후에 링크(link), 즉 연결해 주는 방식이므로 이 절차를 링킹(linking)9이라 부른다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="4.3.1 임베딩(또는 인라이닝)" class="heading" id="4.3.1_임베딩(또는_인라이닝)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3.1 임베딩(또는 인라이닝)</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="4.3.2 링킹" class="heading" id="4.3.2_링킹"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3.2 링킹</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(36%) 꼼꼼하게 구현하려면 링킹 시스템과 이를 사용하는 게임 코드 모두 객체가 (아직) 없는 네트워크 ID를 수신하는 경우를 처리할 줄 알아야 한다. 패킷이 중도에 누락되기도 하므로, 미처 수신하지 못한 객체를 참조하는 멤버 변수를 가진 객체를 게임이 받기도 한다. 여러 방법으로 처리할 수 있는데, 전체 객체를 무시하는 방법, 일단 받을 수 있는 건 모두 받아 참조 가능한 건 모두 연결시킨 뒤 빠진 걸 널(null)로 처리하는 방법 등이 있다.</p>
</li>
<li data-line="2">
<p>(36%) 게임 월드가 대형화되어 수백 개의 객체가 움직이는데, 이들 객체의 움직임을 낱낱이 데이터로 바꿔 수백 명의 플레이어에게 실시간으로 보내려면 현존 최고 품질의 연결망에서도 대역폭이 모자랄 지경이다.</p>
</li>
<li data-line="4">
<p>(36%) 데이터 압축의 왕도는 바로 네트워크상 보낼 필요가 없는 정보를 제거하는 것에 있다.</p>
</li>
<li data-line="6">
<p>(36%) 여러 압축 알고리즘에서 쓰는 전략은 일반적인 경우를 상정해 보고 여기서 출발해 최적화할 때 취할 수 있는 이점을 이용하자는 것으로,</p>
</li>
<li data-line="8">
<p>(36%) mName 필드를 살펴보고 실제 몇 글자를 이름으로 쓰고 있는지 세어보는 커스텀 직렬화 코드가 있다면 공간을 절약할 수 있다.</p>
</li>
<li data-line="10">
<p>(36%) 엔트로피 인코딩(entropy encoding)은 정보 공학 주제 중 하나인데, 데이터 압축에 있어 출현하는 데이터의 예측 가능성 정도가 얼마나 높고 낮은가에 따라 압축률이 달라진다는 이론이다.</p>
</li>
<li data-line="12">
<p>(36%) 기댓값에 가까운 값을 지닌 패킷일수록 그렇지 않은 패킷보다 적은 정보(엔트로피)만 포함한다고 한다.</p>
</li>
<li data-line="14">
<p>(36%) 간단한 방법으로 제법 효율적인 엔트로피 인코딩을 할 수 있는 경우가 있다. 특정 값이 다른 값보다 빈번하게 등장하는 멤버 변수를 직렬화할 때가 그렇다.</p>
</li>
<li data-line="16">
<p>(36%) 3D 벡터 mPosition의 Y 좌표가 보통은 0이라는 사실이다. 코드를 고치면 비트 하나에 mPosition이 보통의 값인 0인지, 아니면 다른 값인지 표시할 수 있다.</p>
</li>
<li data-line="18">
<p>(36%) 높이를 기록하는 데 있어 최악의 경우엔 1비트가 늘어 33비트를 써야 하는 경우도 있음을 주목하자. 늘어난 1비트는 이 값이 일반적인 경우를 나타내는 기댓값인지 그렇지 않은지 나타내는 플래그이며, 나머지 32비트는 특수한 경우에 실제 값을 표현하는 데 쓰인다.</p>
</li>
<li data-line="20">
<p>(36%) 실제 사용될 비트 수의 평균치는 고양이가 보통 땅에 있는 경우가 많은지 그렇지 않은지를 따져 계산해 보아야 알 수 있다.</p>
</li>
<li data-line="22">
<p>(36%) 이런 실험을 통해 얻은 결과로 플레이 타임의 90%를 바닥에 붙어있었다는 지식을 얻었다고 가정해 보자. 기초적인 확률 공식으로 높이를 나타내는데 필요한 비트 수의 기대치를 계산할 수 있다.</p>
<p>P(바닥) × Bits(바닥) + P(공중) × Bits(공중) = 0.9 × 1 + 0.1 × 33 = 4.2</p>
<p>위의 가정에 따르면 결과적으로 Y 값을 직렬화하는 데 필요한 기대 비트 수가 32비트에서 4.2로 줄었다.</p>
</li>
<li data-line="28"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(37%) 고정소수점으로 만들고 나면 항상 40001보다 작은 정수에 필요한 비트 수만큼만 직렬화하면 된다. log2 40001은 15.3이므로, X와 Z에 각각 16비트만 있으면 직렬화할 수 있다.</p>
<ul>
<li data-line="29">Memo :40001 = 2 ^ x    (x는 필요한 비트수)<br>
x =log2 40001</li>
</ul>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="4.4 압축" class="heading" id="4.4_압축"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4 압축</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="4.4.1 희소 배열(sparse array) 압축" class="heading" id="4.4.1_희소_배열(sparse_array)_압축"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4.1 희소 배열(sparse array) 압축</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="4.4.2 엔트로피 인코딩" class="heading" id="4.4.2_엔트로피_인코딩"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4.2 엔트로피 인코딩</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(37%) 많은 경우를 처리하고 싶을 땐 기댓값에 대한 조회 테이블을 두고, 여러 개의 비트를 묶어 이 비트열이 뜻하는 숫자를 테이블에 대한 인덱스로 기록하는 식으로 간이 허프만 코딩(huffman coding)을 구현하면 될 것이다.</p>
</li>
<li data-line="2">
<p>(37%) 복잡하게는 널리 쓰이는 허프만 코딩,12 산술 코딩(arithmetic coding), 감마 코딩(gamma coding), RLE 인코딩(run length encoding) 등이 있다.</p>
</li>
<li data-line="4">
<p>(37%) 게임 시뮬레이션을 부동소수점으로 한다고 해서 float 하나를 나타내는 32비트 전부를 네트워크로 실어 보낼 필요는 없다.</p>
</li>
<li data-line="6">
<p>(37%) 흔히 쓰이는 유용한 방법으로, 보내려는 수치의 가능 범위 및 요구 정밀도를 파악한 다음 고정소수점 형식으로 변환하면 비트 수를 최소화하여 보낼 수 있다.</p>
</li>
<li data-line="8">
<p>(37%) 게임 플레이 테스트를 해 본 결과 클라이언트 측 좌표 이동은 0.1 단위 정도의 정밀도면 충분하다는 것도 알아냈다. 이때 클라이언트를 제어하는 서버상 객체의 위치 값이 정확할 필요가 없다는 얘기는 아니다. 받아서 표시하는 클라이언트 입장에서 0.1 단위 정밀도로 충분하다는 것이다.</p>
</li>
<li data-line="10">
<p>(37%) X 축에 가능한 값의 최대 개수를 산할 수 있다.</p>
<p>(최댓값 - 최솟값) / 정밀도 + 1 = (2000 - (-2000)) / 0.1 + 1 = 40001</p>
</li>
<li data-line="14">
<p>(37%) 어떤 정수 하나를 부동소수점 하나에 대응하게 매핑할 수 있으면, 직렬화 코드에서 X와 Z 값을 정수로 취급하여 기록할 수 있을 것이다.</p>
</li>
<li data-line="16">
<p>(37%) 게임 코드는 벡터의 각 요소를 32비트 꽉 찬 부동소수점으로 갖고 있지만, 네트워크상 전송할 때는 직렬화 코드가 이를 0~40000 사이의 부동소수점으로 변환하여 단 16비트만 사용하여 보낸다.</p>
</li>
<li data-line="18">
<p>(37%) 어떤 변수에 허용되는 값의 범위에 제약이 있다면, 더 적은 양의 비트로 그 정보를 표현할 수 있다. 이 기법은 어떤 자료형이든 그 내용에 대한 제약 사항을 알고 있으면 적용할 수 있다.</p>
</li>
<li data-line="20">
<p>(37%) 사원수는 네 개의 부동소수점 숫자로 구성된 자료형으로, 삼차원 공간에서 회전을 나타낼 때 유용하다.</p>
</li>
<li data-line="22">
<p>(37%) 절에서 중요하게 볼 내용은 바로 사원수로 회전을 표현할 때 정규화한다는 것으로 즉, 각 성분이 -1에서 1 사이 값이고 또한 각 성분을 제곱하여 모두 더한 값이 1이라는 사실이다.</p>
</li>
<li data-line="24">
<p>(37%) 제곱하여 더한 값이 1로 고정불변이므로, 사원수를 직렬화할 때는 네 성분 중 셋만 처리하고, 넷째 성분은 1비트로 부호만 표시하면 된다. 직렬화를 풀어 읽어 들일 때는 세 성분 값을 읽어 들여 제곱해 더한 다음, 더한 값을 1에서 빼면 넷째 성분을 살려낼 수 있다.</p>
</li>
<li data-line="26">
<p>(37%) 대개 16비트의 정밀도면 납득할 만한 수준인데, -1에서 1 사이 값을 65535가지의 값으로 표현한다.</p>
</li>
<li data-line="28">
<p>(37%) 아핀 변환 행렬을 직렬화할 때도 기하 압축을 적용하면 도움이 된다. 변환 행렬은 원래 float 16개로 구성되지만, 아핀(affine) 행렬이라면 이동(translation) 3개, 회전(rotation) 사원수 1개, 스케일(scale) 3개로 항상 쪼갤 수 있어야 하므로, 총 10개의 float만 사용하면 된다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="4.4.3 고정소수점" class="heading" id="4.4.3_고정소수점"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4.3 고정소수점</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="4.4.4 기하 압축" class="heading" id="4.4.4_기하_압축"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4.4 기하 압축</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(38%) 자료형마다 읽기와 쓰기를 두 개의 함수로 나누는 대신 하나로 합쳐 관리할 수 있다면 더 깔끔하지 않을까.</p>
</li>
<li data-line="2">
<p>(38%) MemoryStream을 상속받은 InputMemoryStream과 OutputMemoryStream은 Serialize() 가상 함수를 오버라이딩하는데, 데이터를 가리키는 포인터와 데이터 크기를 인자로 받는다. 각 함수는 클래스에 따라 읽기와 쓰기를 수행하는데, 클래스의 IsInput() 역시 오버라이딩하여 스트림이 읽기용인지 쓰기용인지 구분해 준다.</p>
</li>
<li data-line="4">
<p>(38%) 이 구현 방식에선 가상 함수 호출이 일어나 앞서 방식보다 다소 비효율적일 수 있다. 가상 함수 대신 템플릿을 잘 쓰면 성능을 만회할 수도</p>
</li>
<li data-line="6">
<p>(38%) 대부분 직렬화 코드가 하는 일엔 공통된 패턴이 있다. 객체의 클래스에 선언된 각 멤버 변수마다 그 값을 하나씩 직렬화한다는 패턴이다.</p>
</li>
<li data-line="8">
<p>(38%) C#이나 자바 같은 언어는 내장 리플렉션(reflection) 시스템이 있어서 런타임에 클래스 구조 정보를 조회할 수 있다. 그러나 C++에서는 클래스 멤버 정보를 런타임에 조회하는 것이 불가능하며, 관련 체계를 직접 구축해야 한다.</p>
</li>
<li data-line="10">
<p>(38%) MemberVariable 클래스는 복합 자료형에 들어 있는 하나의 멤버 변수를 나타낸다. 여기에 멤버 변수의 이름(디버깅용), 그 원시 자료형, 그리고 자신이 포함된 복합 자료형 위의 메모리 오프셋 정보를 저장해 둔다.</p>
</li>
<li data-line="12">
<p>(38%) 오프셋을 저장해 두는 게 아주 중요한데, 직렬화 코드가 이 오프셋 값을 주어진 객체의 기준 주소에 더해 멤버 변수가 위치한 메모리상 주소를 알아낼 수 있기 때문이다.</p>
</li>
<li data-line="14">
<p>(38%) OffsetOf() 매크로를 우리가 직접 정의하여 각 멤버 변수의 오프셋을 계산하는 데 사용하고 있음을 주목하자(대소문자 유의). C++ 표준 offsetof() 매크로를 쓰면 POD 클래스가 아닌 경우 오동작할 수 있다.</p>
</li>
<li data-line="16">
<p>(38%) 예외사항으로 클래스에 &amp;(참조) 단항 연산자를 정의한 경우, 클래스가 가상 클래스를 상속받은 경우, 멤버 변수를 레퍼런스로 갖는 경우에는 동작하지 않는다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="4.5 유지보수성" class="heading" id="4.5_유지보수성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.5 유지보수성</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="4.5.1 직렬화 읽기와 쓰기를 하나로 합치기" class="heading" id="4.5.1_직렬화_읽기와_쓰기를_하나로_합치기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.5.1 직렬화 읽기와 쓰기를 하나로 합치기</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="4.5.2 데이터 주도 직렬화" class="heading" id="4.5.2_데이터_주도_직렬화"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.5.2 데이터 주도 직렬화</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(39%) MemberVariable 클래스의 메타 정보를 확장하면 더 강력한 리플렉션을 구축할 수 있다. 예를 들어 각 변수의 정보를 생성할 때 사용할 비트 수도 지정하게 하고 그 값에 따라 자동으로 비트 압축을 처리하는 식이다.</p>
</li>
<li data-line="2">
<p>(39%) memcpy()를 사용해 구조체를 배열로 복사해 넣는 단순한 방법도 있지만, 제한적인 경우에만 쓸 수 있다.</p>
</li>
<li data-line="4">
<p>(39%) 이를 극복하기 위해 스트림을 연장 삼아 복잡한 데이터 구조를 직렬화하는 데, 원시 자료형뿐만 아니라 다른 구조체에 대한 참조 또한 전송하여 추후 링킹 기법으로 연결 정보를 재구축할 수 있다.</p>
</li>
<li data-line="6">
<p>(39%) 희소 데이터 구조체는 축약된 형식으로 직렬화할 수 있다.</p>
</li>
<li data-line="8">
<p>(39%) 엔트로피 인코딩을 쓰면 기댓값이 존재하는 멤버 변수를 손실 없이 압축할 수 있다.</p>
</li>
<li data-line="10">
<p>(39%) 정밀도를 약간 손실해도 무방하다면, 부동소수점 숫자를 미리 파악된 범위 내의 고정소수점 숫자로 변환하여 필요한 만큼의 정밀도로 그 값을 전송할 수 있다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="4.6 요약" class="heading" id="4.6_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.6 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="5장 객체 리플리케이션" class="heading" id="5장_객체_리플리케이션"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5장 객체 리플리케이션</h3><div class="heading-children"><div><ul>
<li data-line="0">(40%) 월드 상태를 객체 지향적으로 표현한다면 그 월드에 존재하는 모든 게임 객체 상태의 집합이 곧 월드 상태가 된다. 고로 월드 상태를 전송하는 작업은 결국 각 게임 객체마다 상태를 전송하는 작업으로 귀결된다.</li>
</ul></div><div class="heading-wrapper"><h4 data-heading="5.1 월드 상태" class="heading" id="5.1_월드_상태"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 월드 상태</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(40%) 객체의 상태를 한 호스트에서 다른 호스트로 복제 전달하는 행위를 일컬어 리플리케이션(replication)1이라 한다.</p>
</li>
<li data-line="2"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(40%) 직렬화에 앞서 객체를 리플리케이션하기 위해 호스트가 취해야 할 준비 절차는 다음과 같다.</p>
<ol>
<li data-line="4">
<p>해당 패킷에 ‘객체 상태를 담은 패킷’이라 표시하기</p>
</li>
<li data-line="6">
<p>리플리케이션할 객체에 고유 식별자 부여하기</p>
</li>
<li data-line="8">
<p>리플리케이션할 객체의 클래스를 식별하기</p>
</li>
</ol>
</li>
<li data-line="10">
<p>(40%) 패킷을 하나씩 보낼 때마다 호스트는 맨 앞에 패킷의 종류를 PacketType형으로 메모리 스트림에 기록한다.</p>
</li>
<li data-line="12">
<p>(40%) 데이터그램의 첫 바이트가 PT_Hello면 이 패킷이 인사 패킷임을 나타낸다. 마찬가지로 PT_Disconnect인 경우 연결 해제 절차를 요청한다고 해석할 수 있다.</p>
</li>
<li data-line="14">
<p>(40%) 송신 호스트는 직렬화해 보낼 객체를 수신 호스트가 식별할 방법을 제공해야 한다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="5.2 객체를 리플리케이션하기" class="heading" id="5.2_객체를_리플리케이션하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 객체를 리플리케이션하기</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(41%) 원격 호스트가 이 패킷을 받으면 식별자를 읽은 후 자신의 LinkingContext에서 참조된 객체를 조회한다. 수신 호스트에 객체가 이미 있다면 직렬화된 데이터를 그 안에다 풀어 넣는다. 객체를 찾을 수 없는 경우 새로 하나 생성한다.</p>
</li>
<li data-line="2">
<p>(41%) 원격 호스트가 객체를 생성하려면 객체의 클래스가 무엇인지 알 수 있는 정보가 필요하다.</p>
</li>
<li data-line="4">
<p>(41%) 단순하게 동적 캐스팅으로 클래스를 하나씩 확인해 보고 하드코딩해 둔 클래스 식별자를 도출하는 방법이 있는데,</p>
</li>
<li data-line="6">
<p>(41%) 첫째 여기서 dynamic_cast를 사용하는데, 이를 위해선 C++의 내장 RTTI가 활성화되어 있어야 한다.</p>
</li>
<li data-line="8">
<p>(41%) 더욱 문제 되는 건 여기서 게임 객체 시스템이 리플리케이션 시스템과 상호 종속이 심화된다는 점이다. 게임 플레이 관련 클래스를 추가할 때마다 네트워크 코드를 열어 이곳 WriteClassType() 코드와 CreateGameObjectFromStream() 코드에 if 문과 switch 문을 추가해 주어야 한다.</p>
</li>
<li data-line="10">
<p>(41%) 일반적으로 게임 코드가 네트워크 코드에 종속되는 건 크게 문제 되지 않지만, 반대로 네트워크 코드가 게임 코드에 종속되는 것만큼은 반드시 피해야 한다.</p>
</li>
<li data-line="12">
<p>(41%) 게임 플레이 코드와 네트워크 코드가 서로 종속되지 않게 하려면, 객체 식별 및 생성 루틴을 추상화하여 리플리케이션 시스템이 객체 생성 레지스트리를 이용하게 만들면 깔끔해진다.</p>
</li>
<li data-line="14">
<p>(41%) 객체 생성 레지스트리4란 클래스 식별자를 해당 클래스의 객체 생성용 함수에 매핑해 둔 것이다. 네트워크 모듈은 이 레지스트리를 사용해 생성 함수를 id로 찾고, 찾은 함수를 호출해 원하는 객체를 생성할 수 있다.</p>
</li>
<li data-line="16">
<p>(41%) 먼저 각 클래스에 고유 식별자를 부여하여 이를 정적 상수인 kClassId에 저장해 둔다.</p>
</li>
<li data-line="18">
<p>(41%) 다른 대안으로 고유성이 보장되도록 컴파일 타임에 클래스 ID를 자동 생성하는 도구를 사용할 수도 있다.</p>
</li>
<li data-line="20">
<p>(41%) C+ + 표준에선 구체적인 구현 방식을 플랫폼에 맡겨두고 있으므로, 컴파일러마다 문자열 리터럴을 정수로 표현하는 방법이 모두 동일하지는 않다.</p>
</li>
<li data-line="22">
<p>(41%) 클래스마다 식별자를 부여했다면, GameObject 클래스에 GetClassId() 가상 함수를 추가한다. 각 서브클래스는 이를 오버라이드하여 앞서 부여해둔 클래스 자신의 식별자를 리턴한다.</p>
</li>
<li data-line="24">
<p>(41%) 복잡하게 만들어 놓은 전처리 매크로를 보면 디버깅하기 힘들어서 대개 눈살이 찌푸려지지만, 잘만 쓰면 복사 붙여넣기를 하다가 생기는 오류를 줄일 수 있는 면도 있다.</p>
</li>
<li data-line="26">
<p>(41%) 만약 공통부분 코드를 고쳐야 할 필요가 있을 때, 전체 코드를 일일이 뒤져가며 고치는 대신 매크로 부분만 고쳐주면 되는 편리한 점도 있다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="5.2.1 객체 생성 레지스트리" class="heading" id="5.2.1_객체_생성_레지스트리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2.1 객체 생성 레지스트리</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(42%) 게임 시작 코드 적당한 위치에서 RegisterObjectCreation()을 호출하여 객체 생성 레지스트리에 식별자와 생성 함수로 채워주어야 한다.</p>
</li>
<li data-line="2">
<p>(42%) 이 시스템은 C++ RTTI와 비슷한 기능을 수작업으로 구현한 것이라 할 수 있다. 우리가 직접 구현하였으므로, typeid 연산자 같은 C++ 내장 RTTI를 이용하는 것보다 메모리의 사용 형태나 식별자 크기, 또는 컴파일러 호환성 등 여러 측면에 좀 더 세밀한 제어가 가능하다.</p>
</li>
<li data-line="4">
<p>(42%) 호스트가 패킷을 보낼 때 패킷에 PT_ReplicationData 표시를 한 다음, 아래 절차를 객체마다 반복해 주면 된다.</p>
</li>
<li data-line="6"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(42%) 1. 네트워크 식별자를 기록</p>
<ol start="2">
<li data-line="8">
<p>클래스 식별자를 기록</p>
</li>
<li data-line="10">
<p>직렬화 데이터를 기록</p>
</li>
</ol>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="5.2.2 한 패킷에 여러 객체 실어 보내기" class="heading" id="5.2.2_한_패킷에_여러_객체_실어_보내기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2.2 한 패킷에 여러 객체 실어 보내기</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="5.3 초간단 월드 상태 리플리케이션" class="heading" id="5.3_초간단_월드_상태_리플리케이션"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.3 초간단 월드 상태 리플리케이션</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(43%) ReplicateWorldState()는 출력 스트림에 객체의 컬렉션을 리플리케이션해 주는 public 함수다. 먼저 패킷에 ‘이것은 리플리케이션용’이라 표시해 놓고, 각 객체 데이터를 private인 ReplicateIntoStream() 함수로 하나씩 직렬화해서 기록한다</p>
</li>
<li data-line="2">
<p>(44%) 열거자를 직렬화할 땐 최적의 비트 수를 컴파일 타임에 결정할 수 있는데, 열거자에 나열된 원소를 추가하거나 삭제하면 컴파일러가 그 최댓값을 자동으로 판단할 수 있기 때문이다. 이를 위해 열거자의 맨 마지막 원소로 _MAX 같은 형태의 접미사를 붙인, 최대 개수 판단용 원소를 추가하는 것이 트릭이다</p>
</li>
<li data-line="4">
<p>(44%) 컴파일 타임에 값을 계산하기 위해 여기선 템플릿 메타프로그래밍(template metaprogramming)이란 신묘한 기법을 사용하는데, C+ + 템플릿이 하도 복잡하고 정교하다 보니 사실상 튜링 유니버설(turing universal)하다는 특징을 이용한 것이다. 이 말은 입력이 컴파일 타임에 결정되어 있기만 하면 템플릿으로 어떤 임의의 함수도 계산할 수 있다는 뜻이다.</p>
</li>
<li data-line="6">
<p>(44%) 이 템플릿은 매 주어진 tValue를 오른쪽으로 하나씩 시프트하면서 tBits 값을 1씩 증가시키는데, tValue가 마침내 0이 되면 기저 조건의 특수화 정의가 선택되어 최종 tBits 값을 Value 열거자 값으로 결정해 준다.</p>
</li>
<li data-line="8">
<p>(44%) 패킷의 처리를 끝내는 시점에선 클라이언트에는 있지만, 패킷 내에 포함되어 있지 않은 객체들을 골라 삭제해 준다.</p>
</li>
<li data-line="10">
<p>(44%) 월드 상태를 이렇게 보내고 받으면 간단하다는 장점은 있지만, 전체 월드 상태가 한 패킷에 들어갈 수 있을 만큼 작아야 한다는 제약이 생긴다. 보다 큰 월드를 지원하려면 다른 리플리케이션 방식을 써야 한다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="5.4 월드 상태의 변경" class="heading" id="5.4_월드_상태의_변경"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4 월드 상태의 변경</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(44%) 송신 측이 월드 상태의 변경점을 기록한 패킷을 보내고, 수신 측은 이 변경 내역을 토대로 자신의 월드 상태를 갱신해 주면 될 것이다.</p>
</li>
<li data-line="2">
<p>(44%) 월드 상태는 여러 객체 상태의 집합이므로, 월드 상태 델타는 여러 변경이 필요한 객체 상태의 델타를 포함하게 된다.</p>
</li>
<li data-line="4">
<p>(44%) 객체 상태 델타를 리플리케이션하는 것은 전체 객체 상태를 리플리케이션하는 것과 크게 다르지는 않은데, 객체마다 리플리케이션 동작의 종류를 패킷에 기록해 주는 정도의 차이는 있다</p>
</li>
<li data-line="6">
<p>(44%) 리플리케이션 헤더에는 객체의 네트워크 식별자, 리플리케이션 동작, 그리고 필요한 경우 클래스 식별자가 포함된다.</p>
</li>
<li data-line="8">
<p>(44%) 송신 측에서 객체 상태 델타를 리플리케이션할 땐 먼저 메모리 스트림을 만들어 PT_ReplicationData 패킷이라 표시한 다음, ReplicationHeader를 직렬화하고 마지막으로 각 데이터의 변경점을 기록한다. 이를 위해 관리자 클래스에 세 가지 서로 다른 용도의 멤버 함수가 있어야 하는데, 각각 생성, 갱신, 소멸을 리플리케이션하는 함수다</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="5.4.1 객체 상태 부분 리플리케이션" class="heading" id="5.4.1_객체_상태_부분_리플리케이션"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4.1 객체 상태 부분 리플리케이션</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(45%) 수신자가 목표 게임 객체를 찾지 못할 가능성도 있다. 이 경우에도 수신자가 패킷의 해당 부분을 읽어줘야 다음 내용을 처리할 수 있으므로, 일단 메모리 스트림을 읽어 들여 적절한 분량만큼 스트림을 전진시켜야 한다</p>
</li>
<li data-line="2">
<p>(45%) 작업이 너무 비효율적이거나, 객체를 이런 식으로 생성 삭제하는 것이 바람직하지 않은 경우엔 객체 리플리케이션 헤더에 직렬화된 데이터의 크기를 미리 기록해주는 방법이 있다.</p>
</li>
<li data-line="4">
<p>(45%) 월드와 객체 상태를 부분적으로 리플리케이션하는 기법은 오로지 수신자의 월드 상태가 어떤지 전송자가 정확하게 파악할 수 있는 경우에만 제대로 동작한다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="5.5 직렬화 객체로 RPC 수행" class="heading" id="5.5_직렬화_객체로_RPC_수행"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5 직렬화 객체로 RPC 수행</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="5.6 리플리케이션 시스템 개조하기" class="heading" id="5.6_리플리케이션_시스템_개조하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.6 리플리케이션 시스템 개조하기</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="5.7 요약" class="heading" id="5.7_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.7 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="6장 네트워크 토폴로지와 예제 게임" class="heading" id="6장_네트워크_토폴로지와_예제_게임"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6장 네트워크 토폴로지와 예제 게임</h3><div class="heading-children"><div><ul>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(47%) 클라이언트 B에 발생할 수 있는 네트워크 지연의 최대치는, 클라이언트 A의 RTT 절반2 + 서버의 처리 시간 + 클라이언트 B의 RTT 절반이 된다.</p>
<ul>
<li data-line="1">Memo :A의 요청을 서버가 받고, 처리후 B에 보내는 시간</li>
</ul>
</li>
<li data-line="3">
<p>(47%) 네트워크 토폴로지(network top ology)란 여러 컴퓨터가 네트워크상 연결되어 있는 양태를 말한다. 게임 분야에 한정하면 게임에 접속한 컴퓨터들을 어떤 구조로 연결할지 정해 그 플레이어들이 최신 상태를 공유하게끔 구조화하는 방식이라 하겠다.</p>
</li>
<li data-line="5">
<p>(47%) 클라이언트-서버(이하 CS) 토폴로지에선 게임 인스턴스 하나를 서버로 두며 나머지 게임 인스턴스는 그 서버에 접속하는 클라이언트가 된다. 각 클라이언트는 오로지 서버하고만 통신하는데, 서버는 이들 모든 클라이언트와의 통신을 전담한다.</p>
</li>
<li data-line="7">
<p>(47%) 클라이언트는 내려받기에 초당 c 바이트만, 업로드에 초당 b 바이트의 대역폭만 확보하면 된다.</p>
</li>
<li data-line="9">
<p>(47%) 대역폭을 따져서 n개의 클라이언트가 있고 각 클라이언트가 초당 b 바이트의 데이터를 보낸다 하면 초당 b·n 바이트를 수신하는 데 부족함이 없도록 서버의 대역폭을 확보해야 한다. 마찬가지로 서버가 매초 c 바이트의 데이터를 각 클라이언트에 보내려면 초당 c·n 바이트를 서버가 처리할 수 있어야 한다.</p>
</li>
<li data-line="11">
<p>(47%) 권한 집중이란 시뮬레이션을 동시에 여러 기계에서 진행할 때, 그중 어느 것이 올바른지 판단하는 권한을 서버에만 집중한다는 의미이다.</p>
</li>
<li data-line="13">
<p>(47%) 클라이언트는 자신의 시뮬레이션 내용이 서버와 다르다는 걸 발견하면 반드시 서버에 맞추어 자신의 게임 상태를 갱신해야 한다.</p>
</li>
<li data-line="15">
<p>(47%) 실뭉치를 던지고 싶다는 요청이 서버에 도달하는데 시간이 약간 걸리고, 서버가 여기에 대해 판정을 내린 후 그 결과를 모든 클라이언트에 보내는 데도 시간이 걸린다.</p>
</li>
<li data-line="17">
<p>(47%) 지연에 한몫하는 요소 중 하나는 바로 RTT(round trip time, 왕복 시간)로, RTT란 패킷을 송신한 후 원래 컴퓨터에 응답이 돌아올 때까지 걸린 시간(통상 밀리초 단위)을 말한다.</p>
</li>
<li data-line="19">
<p>(47%) 전용 서버란 게임을 진행하고 클라이언트와 통신하는 용도로만 별도로 띄우는 서버를 뜻한다.</p>
</li>
<li data-line="21">
<p>(47%) 보통 헤드리스(headless), 즉 화면에 그래픽 따위를 보여주지 않게 되어 있다.</p>
</li>
<li data-line="23">
<p>(47%) 플레이어가 자신이 서버를 띄운 머신을 가지고 클라이언트로 직접 게임에도 참여하는 방식을 말한다.</p>
</li>
<li data-line="25">
<p>(48%) 플레이어는 그 대신 자기 머신을 서버 겸 클라이언트로 사용하게 된다.</p>
</li>
<li data-line="27">
<p>(48%) 리스닝 서버 방식이 피어-투-피어 방식과 혼동될 때도 있는데, 엄밀히 말하자면 피어 호스팅(peer hosting) 방식이라 하겠다.</p>
</li>
<li data-line="29">
<p>(48%) 네트워크 장애가 있거나 열 받은 방장이 게임을 나가는 등 이유로 서버의 연결이 끊어져 버리는 경우 골치 아픈 일이 벌어진다.</p>
</li>
<li data-line="31">
<p>(48%) 리스닝 서버를 운영하는 플레이어가 이 정보를 악용해 치트를 시도할 가능성이 있다.</p>
</li>
<li data-line="33">
<p>(48%) 호스트 마이그레이션이 성사되려면 클라이언트-서버에 피어-투-피어 방식을 섞어 하이브리드 토폴로지로 구현해야 한다.</p>
</li>
<li data-line="35">
<p>(48%) 호스트 마이그레이션(host migration) 개념을 리스닝 서버에 탑재하는 게임도 있다. 리스닝 서버의 연결이 끊어지면, 클라이언트 중 하나가 새로 서버 역할을 맡는 것이다.</p>
</li>
<li data-line="37">
<p>(48%) 피어-투-피어(peer-to-peer, 이하 P2P) 토폴로지에선, 게임에 참여하는 머신이 동일 게임에 참여하는 다른 모든 머신과 서로 연결된다.</p>
</li>
<li data-line="39">
<p>(48%) P2P에서 연결의 개수는 클라이언트 수의 제곱에 비례한다. 즉, n개의 피어(peer)가 있을 때 각 피어는 O(n-1)의 연결을 맺어야 하고, 따라서 네트워크 전체에 O(n2)의 연결이 존재하게 된다.</p>
</li>
<li data-line="41">
<p>(48%) 보편적인 P2P 게임 구현 방식은 각 피어마다 입력을 서로 공유하여 각자가 이들 입력을 스스로 시뮬레이션하는 것이다.</p>
</li>
<li data-line="43">
<p>(48%) 클라이언트 사이에 중개자를 두는 클라이언트-서버 모델과는 다르게, P2P 게임에선 모든 피어가 다른 피어와 직접 통신한다. 즉, 두 피어 사이의 지연은 기껏해야 RTT의 절반이 된다는 뜻이다.</p>
</li>
<li data-line="45">
<p>(48%) 턴 간격의 추가 지연 시간이 발생하는데, 예를 들어 각 피어가 제1턴의 결과를 화면에 표시하는 와중에 대기열에 쌓인 명령들은 한 턴 건너 제3턴에 실행되는 식이다.</p>
</li>
<li data-line="47">
<p>(48%) 매치 메이킹 서비스는 대개 하나의 주소만 받아 접속 가능 게임 목록에 보여주므로, 여기에 맞추려면 피어 하나가 소위 마스터 피어로 자신을 등록하고, 새 플레이어는 항상 마스터를 통해서만 참가하게 해야 한다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="6.1.1 클라이언트-서버" class="heading" id="6.1.1_클라이언트-서버"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1 클라이언트-서버</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(49%) 게임에 참여하는 머신이 동일 게임에 참여하는 다른 모든 머신과 서로 연결된다</p>
</li>
<li data-line="2">
<p>(49%) 피어가 많이 접속할수록 요구되는 대역폭도 큰 폭으로 증가하게 된다. 클라이언트-서버와는 다르게 대역폭 요구 사항은 대칭적</p>
</li>
<li data-line="4">
<p>(49%) 보편적인 P2P 게임 구현 방식은 각 피어마다 입력을 서로 공유하여 각자가 이들 입력을 스스로 시뮬레이션하는 것</p>
</li>
<li data-line="6">
<p>(49%) P2P 토폴로지에서 입력 공유 모델이 보다 어울리는 이유 하나는 바로 지연이 상대적으로 덜하다는 것이다</p>
</li>
<li data-line="8">
<p>(49%) 클라이언트 사이에 중개자를 두는 클라이언트-서버 모델과는 다르게, P2P 게임에선 모든 피어가 다른 피어와 직접 통신한다. 즉, 두 피어 사이의 지연은 기껏해야 RTT의 절반이 된다는 뜻이다</p>
</li>
<li data-line="10">
<p>(49%) 각 피어가 제1턴의 결과를 화면에 표시하는 와중에 대기열에 쌓인 명령들은 한 턴 건너 제3턴에 실행되는 식</p>
</li>
<li data-line="12">
<p>(49%) 또 한 가지 중요한 점은, 게임 상태가 모든 피어 사이에서 일관되어야 한다는 것이다.</p>
</li>
<li data-line="14">
<p>(49%) 피어 간 게임 상태의 일관성 검사를 위해 체크섬을 도입하거나, 난수 발생기를 동기화하는 등 여러 가지가 있는데</p>
</li>
<li data-line="16">
<p>(49%) 매치 메이킹 서비스는 대개 하나의 주소만 받아 접속 가능 게임 목록에 보여주므로, 여기에 맞추려면 피어 하나가 소위 마스터 피어로 자신을 등록하고, 새 플레이어는 항상 마스터를 통해서만 참가하게 해야 한다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="6.1.2 피어-투-피어" class="heading" id="6.1.2_피어-투-피어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.2 피어-투-피어</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(48%) 서버 인스턴스의 mHealth만이 인증된 값이긴 하지만 각 클라이언트 또한 UI에 표시하기 위해 로컬에 값을 캐싱해 두어야 한다.</p>
</li>
<li data-line="2">
<p>(49%) 비록 서버 인스턴스의 mHealth만이 인증된 값이긴 하지만 각 클라이언트 또한 UI에 표시하기 위해 로컬에 값을 캐싱해 두어야 한다</p>
</li>
<li data-line="4">
<p>(49%) RoboCat 기반 클래스를 위에 두고 이를 상속받아 두 개의 클래스를 만든다. RoboCatServer와 RoboCatClient가 그것이다</p>
</li>
<li data-line="6">
<p>(49%) 먼저 서버는 mAddressToClientMap이라는 해시 맵에 전체 클라이언트 항목을 기억해 두어야 한다.</p>
</li>
<li data-line="8">
<p>(49%) 수신된 패킷을 읽어 들여 나중에 처리할 수 있게 대기열에 집어넣는 코드는 기반 클래스인 NetworkManager에 전부 구현되어 있다.</p>
</li>
<li data-line="10">
<p>(49%) 신규 클라이언트를 마중하는 데 있어 서버의 역할과 클라이언트의 역할이 다르므로, 기능의 구현도 NetworkManagerClient와 NetworkManagerServer에 분리한다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="6.2 클라이언트-서버 구현하기" class="heading" id="6.2_클라이언트-서버_구현하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2 클라이언트-서버 구현하기</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="6.2.1 서버 코드와 클라이언트 코드 분리하기" class="heading" id="6.2.1_서버_코드와_클라이언트_코드_분리하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.1 서버 코드와 클라이언트 코드 분리하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(50%) RoboCat 클래스의 계층 구조상, 이들 세 클래스는 각자 서로 다른 목적 파일에 생성된다. RoboCat 기반 클래스는 공용 라이브러리에, 그리고 RoboCatServer는 서버 실행 파일에, RoboCatClient는 클라이언트 실행 파일에 들어간다</p>
</li>
<li data-line="2">
<p>(50%) 로보캣 액션의 경우 수신하는 패킷이 두 종류밖에 없다. 웰컴 패킷과 상태 패킷이 그것인데, 상태 패킷은 리플리케이션 데이터를 담고 있다.</p>
</li>
<li data-line="4">
<p>(50%) 헬로 패킷을 보낼 때 클라이언트가 한 가지 신경 써야 할 것은 패킷을 너무 자주 보내지 않도록 해야 한다는 것이다. 이를 위해 마지막으로 헬로 패킷을 보낸 뒤 시간이 얼마나 지났는지를 검사한다</p>
</li>
<li data-line="6">
<p>(50%) 먼저 서버는 mAddressToClientMap이라는 해시 맵에 전체 클라이언트 항목을 기억해 두어야 한다.</p>
</li>
<li data-line="8">
<p>(50%) 세 가지 리플리케이션 명령이 있는데, 생성, 갱신, 소멸이 그것이다.</p>
</li>
<li data-line="10">
<p>(50%) 게임의 서버 모델이 권한 집중형이므로, 객체는 서버에서 클라이언트 쪽으로 한 방향으로만 리플리케이션된다.</p>
</li>
<li data-line="12">
<p>(50%) 이에 따라 입력 패킷의 필요성이 대두된다. 매 프레임마다 클라이언트는 자신의 입력 이벤트를 처리하는데, 입력 내용 중 서버에서 처리해야 할 것은 그 이벤트를 서버에 보낸다.</p>
</li>
<li data-line="14">
<p>(50%) 입력 패킷을 받아 입력 상태를 추출해 클라이언트 프록시(client proxy)에 저장해 둔다.</p>
</li>
<li data-line="16">
<p>(50%) InputState 클래스는 특정 프레임의 클라이언트의 입력을 스냅샷(snapshot), 즉 당시 상태대로 남겨둔 것이다.</p>
</li>
<li data-line="18">
<p>(50%) InputManager는 프레임당 한 번 InputState를 갱신하는데, 매 프레임 이를 서버에 보내는 건 실용적이지 못하다. 그보다는 여러 프레임에 걸친 InputState를 하나의 ‘이동 조작’으로 합쳐 주는 것이 바람직하다.</p>
</li>
<li data-line="20">
<p>(50%) Move 클래스는 InputState에 시간 변수를 추가한 간단한 래퍼 클래스에 불과하지만, 이렇게 개념을 분리해 두면 프레임 시각을 따져야 하는 코드를 구현할 때 깔끔하게 작성할 수 있다.</p>
</li>
<li data-line="22">
<p>(50%) NetworkManagerClient가 일정 시간마다 입력을 담아 보낼 패킷에 순서대로 이동 조작 목록을 기록하여 송신한다.</p>
</li>
<li data-line="24">
<p>(50%) SendInputPacket()은 클라이언트의 이동 조작을 한 번만 보내기 때문에 패킷 손실 시 대응 측면에선 약한 것이 사실이다.</p>
</li>
<li data-line="26">
<p>(50%) 같은 입력 패킷을 세 번 보내어 서버가 받을 수 있는 기회를 세 번으로 늘릴 것이다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="6.2.2 네트워크 관리자 및 신규 클라이언트 마중하기" class="heading" id="6.2.2_네트워크_관리자_및_신규_클라이언트_마중하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.2 네트워크 관리자 및 신규 클라이언트 마중하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(51%) 어떤 클라이언트에 정확히 어떤 변수를 보내야 할지 파악하고 있어야 하기 때문이다.</p>
</li>
<li data-line="2">
<p>(51%) 클라이언트 프록시는 각각 소켓 주소, 이름, 플레이어의 ID도 저장하고 있다.</p>
</li>
<li data-line="4">
<p>(51%) ProcessInput()과 SimulateMovement()를 호출할 때, 시간 변위를 서버의 프레임 간격을 기준으로 계산하지 않고, 이동 조작 데이터에서 가져오는 것을 반드시 눈여겨보자.</p>
</li>
<li data-line="6">
<p>(51%) 게임에 사용하는 물리 엔진이 고정된 프레임 주기를 요구한다면, 물리 프레임 주기는 다른 프레임 주기와 분리하여 고정해 둘 필요가 있다.</p>
<p>코드</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="6.2.3 입력 공유 및 클라이언트 프록시" class="heading" id="6.2.3_입력_공유_및_클라이언트_프록시"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.3 입력 공유 및 클라이언트 프록시</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(51%) 마스터 피어를 두는 목적은 게임에 참가하는 호스트 중 하나를 대표로 하여 그 IP 주소를 공지하기 위해서다</p>
</li>
<li data-line="2">
<p>(51%) 각 피어는 같은 코드를 사용한다. 덕분에 파일의 개수도 줄게 되고 게임에 참여하는 모든 플레이어가 같은 실행 파일로 게임을 구동하게 된다.</p>
</li>
<li data-line="4">
<p>(52%) 마스터 피어가 헬로 패킷을 받았으며, 신규 피어가 게임에 참가할 수 있다.</p>
</li>
<li data-line="6">
<p>(52%) 게임이 이미 진행되고 있거나, 게임의 인원 한도가 찼다는 뜻이다</p>
</li>
<li data-line="8">
<p>(52%) 마스터 피어가 아닌 호스트에 헬로 패킷을 보냈을 경우</p>
</li>
<li data-line="10">
<p>(52%) 신규 피어는 게임에 이미 접속된 다른 모든 피어에 자기소개 패킷 'INTR'을 보낼 의무가 있다.</p>
</li>
<li data-line="12">
<p>(52%) 각 피어가 저장하는 주소는 모두 수신 패킷에서 수집한 주소이므로, 하나 이상의 피어가 로컬 네트워크에 연결된 경우 잠재적인 문제가 야기된다.</p>
</li>
<li data-line="14">
<p>(52%) 랑데뷰 서버(rendezvous server</p>
</li>
<li data-line="16">
<p>(52%) 서버는 피어가 다른 피어에 처음 접속을 맺는 것을 도와주는 역할을 한다.</p>
</li>
<li data-line="18">
<p>(52%) 중앙에 릴레이 서버(relay server)를 두어 릴레이 서버가 모든 패킷을 피어 사이에서 중개하게 하는 것이다.</p>
</li>
<li data-line="20">
<p>(52%) 피어 하나가 다른 피어에 DDoS 공격을 하여 먹통을 만들거나 하는 행위를 막을 수 있다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="6.3 피어-투-피어 구현하기" class="heading" id="6.3_피어-투-피어_구현하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3 피어-투-피어 구현하기</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="6.3.1 신규 피어 마중하기 및 게임 시작하기" class="heading" id="6.3.1_신규_피어_마중하기_및_게임_시작하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3.1 신규 피어 마중하기 및 게임 시작하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(53%) 만일 어떤 피어가 여러 피어 중 특정 피어 하나에만 접속할 수 있다고 하면 어떻게 해야 할까</p>
</li>
<li data-line="2">
<p>(53%) 타이머 구동 시 마스터 피어와 다른 피어 사이의 레이턴시를 고려하지 않았기 때문이다.</p>
</li>
<li data-line="4">
<p>(53%) 피어의 타이머 시간에서 RTT의 절반(1/2 RTT)만큼 빼 주는 방법이 있다. 만일 마스터 피어에서 피어 A로 가는 RTT가 100밀리초라면, 피어 A의 타이머 3초 빼기 50밀리초로 맞추면, 시작 시간 동기화를 좀 더 잘 맞출 수 있게 된다.</p>
</li>
<li data-line="6">
<p>(53%) 구현을 간소화하고자 로보캣 RTS는 고정 30프레임으로 구동된다. 즉, 프레임당 시간 간격은 고정 33밀리초이다.</p>
</li>
<li data-line="8">
<p>(53%) ‘서브턴’</p>
</li>
<li data-line="10">
<p>(53%) 세 번의 서브턴을 거치면 턴이 꽉 찬 것으로 친다. 고로 각 턴은 100밀리초이며 1초에 10번의 턴을 수행한다</p>
</li>
<li data-line="12">
<p>(53%) 리플리케이션에 대해 이야기하자면 피어는 게임 월드 전체를 제각기 시뮬레이션하므로 게임 객체를 어떤 형태로든 전혀 리플리케이션할 필요가 없다. 그 대신 게임 플레이 도중 ‘턴’ 패킷만 서로 주고받는다</p>
</li>
<li data-line="14">
<p>(53%) ‘명령’과 ‘입력’을 명확히 구분 지어 기술할 필요가 있다</p>
</li>
<li data-line="16">
<p>(53%) 이동 또는 공격은 게임의 상태를 변화시키므로, 각각 명령을 생성해 처리한다.9</p>
</li>
<li data-line="18">
<p>(53%) 턴 x에 내려진 명령은 턴 x+2가 되어야만 실행된다.</p>
</li>
<li data-line="20">
<p>(53%) StaticReadAndCreate()는 메모리 비트 스트림에서 명령 종류를 나타내는 열거자 값을 읽은 다음 거기에 맞는 서브클래스의 인스턴스를 생성하고 그 Read()를 호출한다.</p>
</li>
<li data-line="22">
<p>(53%) TryAdvanceTurn()을 호출한 경우, x+1 턴의 모든 내용을 수신한 다음에만 전진을 수행한다. x+1 턴의 내용 중 일부를 아직 수신하지 못한 경우, 네트워크 관리자는 지연 상태로 들어간다.</p>
</li>
<li data-line="24">
<p>(53%) 그렇지만 만일 패킷 손실에 올바르게 대응하고자 한다면 지연 상태의 로직을 확장하여 어느 피어의 분량이 손실되었는지 판단한 다음, 해당 피어에 명령 데이터를 재전송해 달라고 요청해야 한다.</p>
</li>
<li data-line="26">
<p>(53%) 피어-투-피어 게임에선 각 피어가 독자적으로 시뮬레이션을 진행하므로, 이들 인스턴스를 전부 어떻게 동기화할지가 P2P 게임을 설계하는 데 있어 가장 어려운 문제이다.</p>
</li>
<li data-line="28">
<p>(53%) P2P 게임에선 특정 턴에 난수 발생기가 특정 숫자를 생성하게 규칙을 통일하면 여러 피어가 항상 같은 결과를 얻게 된다.</p>
</li>
<li data-line="30">
<p>(53%) 피어가 서로 동기화되려면, 각 피어가 같은 난수를 얻을 수 있게 다음 두 가지 작업이 필요하다.</p>
</li>
<li data-line="32">
<p>(53%) 각 피어의 난수 발생기에 같은 초깃값을 시드 값으로 먹여야 한다.</p>
</li>
<li data-line="34">
<p>(53%) 모든 피어는 한 턴에 정확히 같은 횟수로 난수 발생기를 호출해야 하며 정확히 같은 순서로 같은 코드 위치에서 호출해야 한다.</p>
</li>
<li data-line="36">
<p>(53%) C 표준에선 rand 함수가 어떤 유사 난수 발생 알고리즘을 쓸지 명시하고 있지 않다. 즉, 여러 플랫폼(또는 같은 플랫폼이라도 다른 컴파일러)마다 C 라이브러리의 난수 알고리즘 구현이 다를 수도 있다는 뜻이다.</p>
</li>
<li data-line="38">
<p>(53%) PRNG 알고리즘이 명시되지 않았기에 rand 함수가 뽑아주는 난수의 엔트로피, 즉 난수의 품질 역시 의구심이 들 수밖에 없다.</p>
</li>
<li data-line="40">
<p>(53%) 메르센 트위스터 알고리즘을</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="6.3.2 명령 공유와 락스텝 턴" class="heading" id="6.3.2_명령_공유와_락스텝_턴"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3.2 명령 공유와 락스텝 턴</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(54%) 100밀리초 턴 단위로 완료되는 동기화 관련 데이터도 같이 담아둔다</p>
</li>
<li data-line="2">
<p>(54%) 네트워크 관리자는 각 플레이어의 턴 데이터를 턴마다 분리해서 관리하며, 피어마다 수신된 데이터를 검증해 볼 수 있다.</p>
</li>
<li data-line="4">
<p>(54%) 피어가 턴 패킷을 만들어 이 패킷에 두 턴 뒤에 실행될 명령 전부를 넣어둔다는 부분에 주목하자.</p>
</li>
<li data-line="6">
<p>(54%) -2로 지정한 명령은 두 턴이 지나 0번 턴이 되면 실행된다. 시작한 뒤 처음 200밀리초 동안엔 어떤 명령도 실행되지 않는다는 뜻으로, 락스텝식 턴 메커니즘에선 이 같은 초기 지연은 감수해야만 하는 부분이다.</p>
</li>
<li data-line="8">
<p>(54%) 항상 전진이 이루어지는 것은 아닌데 왜냐하면, 락스텝 메커니즘을 채택하고 있으므로 모든 피어의 동기화가 완료된 뒤에야 비로소 턴을 전진할 수 있기 때문이다.</p>
</li>
<li data-line="10">
<p>(54%) RandGen을 처음 초기화할 땐 random_device 클래스를 이용해 시드 값을 먹인다. 그러면 플랫폼 전용 방식으로 추출하는 난수 값이 나온다.</p>
</li>
<li data-line="12">
<p>(54%) 여기에 더해, 매 턴이 끝나는 시점에서 각 피어는 턴 패킷을 만드는데, 이때 자신의 발생기로 난수를 하나 뽑아 턴 데이터에 넣는다. 여러 피어는 턴 데이터에 포함된 난수 값이 서로 간에 모두 같은지 확인하여, 혹시 턴이 진행되는 와중에 난수 발생기의 동기화가 깨진 피어가 있는지 검사할 수 있다.</p>
</li>
<li data-line="14">
<p>(54%) 게임 코드의 다른 부분에서 난수를 사용할 필요가 있다 해도, 절대 게임 상태용으로 쓰는 난수 발생기를 건드리지 않도록 주의하자.</p>
</li>
<li data-line="16">
<p>(54%) 동기화가 깨지는 원인 중에는 쉽게 파악하기 힘든 것도 많다. 예를 들어 부동소수점 연산의 구현은 결정론적13이긴 하지만 하드웨어 구현에 따라 미세하게 다를 수도 있다.</p>
</li>
<li data-line="18">
<p>(54%) 체크섬(checksum)을 이용하는 것이다.</p>
</li>
<li data-line="20">
<p>(54%) 우선 각 턴을 마칠 때마다 게임 상태의 체크섬을 계산한다. 그리고 턴 패킷에 이 체크섬을 실어 보내면, 모든 게임 인스턴스가 턴 종료 시에 서로 계산한 값이 모두 일치하는 결과에 도달하는지 검사한다.</p>
</li>
<li data-line="22">
<p>(54%) CRC(cyclic redundancy check, 순환 중복 검사)를 사용하는데, 이 알고리즘은 32비트 체크섬 값을 리턴한다.</p>
</li>
<li data-line="24">
<p>(54%) 기록은 객체의 네트워크 ID 순서대로 한다.</p>
</li>
<li data-line="26">
<p>(54%) 객체가 관련 데이터를 기록하고 나면, 스트림 버퍼를 통째로 CRC 계산한다.</p>
</li>
<li data-line="28">
<p>(54%) ComputeGlobalCRC() 함수 관련하여 고려할 사항이 몇 가지 있다. 먼저, 모든 게임 객체의 모든 프로퍼티를 스트림에 기록할 필요가 없다는 것이다.</p>
</li>
<li data-line="30">
<p>(54%) CRC 계산은 이렇게 전체가 아니라 부분적으로만 해도 되는데, 실은 CRC를 계산하려는 목적이라면 스트림에 데이터 전체를 굳이 기록하지 않아도 된다. 오히려 데이터를 스트림으로 복사하는 작업이 CRC 값을 즉석에서 계산하는 것보다 느릴 수도 있다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="6.3.3 동기화 유지하기" class="heading" id="6.3.3_동기화_유지하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3.3 동기화 유지하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(55%) 네트워크 토폴로지를 어떤 것으로 선택하느냐는 네트워크 게임을 만들 때 선행되어야 할 가장 중요한 의사결정 중 하나이다.</p>
</li>
<li data-line="2">
<p>(55%) 서버에서 클라이언트 쪽으로만 객체 리플리케이션 데이터가 전달됨을 뜻한다.</p>
</li>
<li data-line="4">
<p>(55%) 각 피어는 락스텝을 맞추기 위해 턴 패킷을 매 100밀리초 턴이 끝날 때마다 송신한다. 턴 패킷에 포함된 명령은 대기열에 예약되어 두 번의 턴이 지난 후에 실행된다. 각 피어는 이후 턴의 데이터가 모두 수신되기 전까지 수행을 멈추었다가 모두 받고서야 진행한다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="6.4 요약" class="heading" id="6.4_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="7장 레이턴시, 지터링, 신뢰성" class="heading" id="7장_레이턴시,_지터링,_신뢰성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7장 레이턴시, 지터링, 신뢰성</h3><div class="heading-children"><div><ul>
<li data-line="0">
<p>(56%) 컴퓨터 게임에서의 레이턴시란 관측 가능한 사건의 원인이 발생한 후 그 효과가 실제 관측되는 데까지 걸리는 시간을 말한다.</p>
</li>
<li data-line="2">
<p>(56%) 예를 들면, RTS 게임에선 마우스 클릭 후 유닛이 명령에 반응하는 시간, VR(virtual reality, 가상 현실) 게임에선 헤드마운트를 쓴 사용자가 머리를 돌릴 때 실제 디스플레이가 그 방향을 보여주는 데까지 걸리는 시간이 되겠다.</p>
</li>
<li data-line="4">
<p>(56%) 격투 게임이나 FPS같이 반사 신경이 필요한 액션 게임도 민감한 레이턴시 기준을 요구한다. 이들 게임에서 레이턴시를 16에서 150밀리초 내로 유지하지 못하면 플레이어는 프레임 레이트가 아무리 높아도 게임이 지척거리고 반응이 둔하다고 느끼게 된다.</p>
</li>
<li data-line="6">
<p>(56%) VR에선 사용자가 시뮬레이션에 이질감을 느끼지 않도록 레이턴시를 대개 20밀리초 이하로 유지할 필요가 있다.</p>
</li>
<li data-line="8">
<p>(56%) RTS 장르는 500밀리초까지 레이턴시가 있다 해도 게임 체험이 크게 훼손되지 않는다.</p>
</li>
<li data-line="10">
<p>(56%) 입력 샘플링 레이턴시.</p>
</li>
<li data-line="12">
<p>(56%) 사용자가 버튼을 누른 후 게임이 그것을 감지하는데 걸리는 시간도 제법 크다.</p>
</li>
<li data-line="14">
<p>(56%) 시점을 회전하는 입력의 경우엔 프레임 초반에 한 번 체크해 두고, 나중에 프레임 말미에 한 번 더 체크해서 적당히 그 중간을 회전 값으로 삼아 렌더링하는 방법을 생각해 볼 수 있겠다.</p>
</li>
<li data-line="16">
<p>(56%) 일반적인 경우엔 버튼 입력으로부터 게임에 반영되는 데까지 대략 한 프레임의 절반 정도의 레이턴시가 있다고 보면 된다.</p>
</li>
<li data-line="18">
<p>(56%) 렌더링 파이프라인 레이턴시. CPU가 일련의 렌더링 명령을 내린다 해서 GPU가 곧바로 그리기를 수행하는 것은 아니다. 대신 드라이버는 명령 버퍼에 렌더링 명령을 넣어두고, 이후 적당한 시점에 GPU가 이들 명령을 처리하게 된다.</p>
</li>
<li data-line="20">
<p>(56%) 멀티스레드 렌더링 파이프라인 레이턴시. 멀티스레드로 돌아가는 게임의 경우 렌더링 파이프라인에 레이턴시가 더 심하게 발생할 수 있다.</p>
</li>
<li data-line="22">
<p>(56%) 수직 동기화(V-Sync). 화면이 갈라진 것처럼 렌더링되는 현상을 막기 위해, 흔히 비디오 카드가 수직 동기화 시간에만 이미지를 표시하게 하는 방법을 흔히 사용한다.</p>
</li>
<li data-line="24">
<p>(56%) 모니터가 앞 프레임의 일부와 뒷 프레임의 일부를 동시에 표시하느라 화면이 갈라지는 현상을 막을 수 있다.</p>
</li>
<li data-line="26">
<p>(56%) 렌더링 등이 오래 걸려 단 1밀리초라도 초과하게 되면 그 시점을 놓쳐 다음번 비디오 카드의 수직 동기화까지 고스란히 기다려야 한다.</p>
</li>
<li data-line="28">
<p>(56%) 스크린 티어링(screen tearing), 즉 화면이 갈라지는 것처럼 보이는 현상은 모니터가 이미지를 스크린에 뿌리는 중도에 GPU가 프론트 버퍼를 갱신할 때 발생한다.</p>
</li>
<li data-line="30">
<p>(56%) • 픽셀 반응 시간. LCD 디스플레이를 구성하는 픽셀의 밝기와 색상이 변하는데도 약간의 시간이 소요된다. 이런 현상은 대개 9밀리초 이하로 나타나지만, 오래된 디스플레이의 경우 프레임 시간의 절반 정도의 레이턴시로 이어질 수 있다.</p>
</li>
<li data-line="32">
<p>(56%) • 디스플레이 랙.2 대부분 HDTV나 LCD 모니터는 입력 화상을 실제로 디스플레이하기 전에 소정의 영상 처리를 거친다. 이러한 처리로는 인터레이싱 제거(de-interlacing), HDCP 따위의 DRM 처리, 여기에 더해 비디오 스케일링이나 노이즈 제거, 밝기 조정, 이미지 필터링 및 각종 이미지 효과 등 다양한 처리가 일어난다.</p>
</li>
<li data-line="34">
<p>(56%) 처리 지연(processing delay)</p>
</li>
<li data-line="36">
<p>(56%) 발신 주소를 알아내고 적절한 경로를 결정하는데 걸리는 시간을 처리 지연 시간이라 한다. 처리 지연 시간에는 라우터의 부가 기능에 따른 시간도 포함되는데 NAT, 즉 네트워크 주소 변환이나 암호화에 시간이 걸릴 수 있다.</p>
</li>
<li data-line="38">
<p>(56%) 전송 지연(transmission delay)</p>
</li>
<li data-line="40">
<p>(56%) 라우터가 패킷을 전달하려면 링크 계층 인터페이스를 거쳐 물리적 매체로 패킷을 전달해야 한다. 링크 계층 프로토콜은 매체에 기록하는 비트 수의 평균 빈도를 조절하는데, 예를 들어 1메가비트 이더넷 연결의 경우 이더넷 케이블에 초당 백만 개의 비트를 기록할 수 있다.</p>
</li>
<li data-line="42">
<p>(56%) 물리적 매체에 비트를 기록하는 데 걸리는 시간을 일컬어 전송 지연이라 한다.</p>
</li>
<li data-line="44">
<p>(56%) 큐잉 지연(queueing delay)</p>
</li>
<li data-line="46">
<p>(56%) 라우터의 처리 용량보다 많은 패킷이 도착하면 라우터는 패킷을 수신 대기열에 집어넣고 나중에 처리한다. 마찬가지로 NIC도 한 번에 한 패킷만 출력할 수 있으므로, 패킷을 보내려는 해당 NIC가 작업 중이면 일단 패킷을 발신 대기열에 넣어 두게 된다. 이렇게 대기열에 머무르는 시간을 큐잉 지연이라 한다.</p>
</li>
<li data-line="48">
<p>(56%) 전파 지연(propagation delay)</p>
</li>
<li data-line="50">
<p>(56%) 패킷을 보낼 때 미터 당 최소 0.3나노초의 시간이 소요된다.</p>
</li>
<li data-line="52">
<p>(56%) 매체를 타고 전파되는데 필요한 시간을 가리켜 전파 지연이라 한다.</p>
</li>
<li data-line="54">
<p>(56%) 전송 지연은 대개 사용자가 연결된 링크 계층의 종류에 따라 좌우된다. 인터넷 백본망에 가까울수록 대역폭이 증가하는 것이 보통이며 반대로 멀어질수록, 즉 변두리 지역에 있으면 전송 지연의 정도가 점점 커진다.</p>
</li>
<li data-line="56">
<p>(56%) 처리 지연은 보통 그리 심각한 문제가 되지는 않는데, 요즈음 출시되는 라우터의 처리 속도가 그만큼 매우 빠르기 때문이다.</p>
</li>
<li data-line="58">
<p>(56%) 패킷을 가능한 가장 큰 크기로 보내는 것도 도움이 되는데, 헤더의 바이트 수를 줄일 수 있기 때문이다.</p>
</li>
<li data-line="60">
<p>(56%) 큐잉 지연은 패킷의 발신 및 처리를 기다리다가 발생한다. 처리 지연과 전송 지연을 최소화하면 자연스럽게 큐잉 지연도 최소화할 수 있다.</p>
</li>
<li data-line="62">
<p>(56%) 이를 위해 도움이 되는 사실 하나는, 보통 라우터는 패킷의 헤더만 살펴보고 처리하므로, 많은 수의 작은 패킷을 보낼 때보다 적은 수의 큰 패킷을 보낼 때 큐잉 지연을 줄일 수 있다는 것이다.</p>
</li>
</ul></div><div class="heading-wrapper"><h4 data-heading="7.1 레이턴시" class="heading" id="7.1_레이턴시"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1 레이턴시</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(57%) 전파 지연은 호스트 사이의 선로 길이에 좌우되므로, 최적화하는 가장 좋은 방법은 호스트를 가까이 두는 것이다.</p>
</li>
<li data-line="2">
<p>(57%) 주의할 점은 물리적인 거리가 가깝다고 해서 항상 전파 지연이 최소화되는 것은 아니라는 점이다. 지역 대 지역을 연결하는 직통 회선이 없어서 라우터가 우회 경로로 보내야 하는 경우도 있다.</p>
</li>
<li data-line="4">
<p>(57%) 라이엇 게임즈가 자사의 유명 타이틀 리그 오브 레전드에서 겪었던 상황이 바로 그것으로, 미국 내 여기저기에 게임 서버를 흩어두면 안 되었기 때문에 정반대의 전략으로 자사 전용의 네트워크 인프라를 구축했다.</p>
</li>
<li data-line="6">
<p>(57%) 왕복 시간(round trip time) 또는 RTT라는 용어로 정리하겠다.</p>
</li>
<li data-line="8">
<p>(57%) 호스트가 패킷을 발신하여 상대 호스트에 패킷이 도착한 다음, 응답 패킷을 원래 호스트가 되돌려 받는 데까지 걸리는 시간을 RTT라 정의한다.</p>
</li>
<li data-line="10">
<p>(57%) 양방향 처리, 대기열, 발신, 전파 지연뿐만 아니라 원격 호스트의 프레임 레이트도 반영되는데, 프레임 레이트에 따라 얼마나 빨리 응답 패킷을 보낼 수 있는지가 달라지기 때문이다.</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="7.1.1 네트워크가 원인이 아닌 레이턴시" class="heading" id="7.1.1_네트워크가_원인이_아닌_레이턴시"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.1 네트워크가 원인이 아닌 레이턴시</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="7.1.2 네트워크 레이턴시" class="heading" id="7.1.2_네트워크_레이턴시"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2 네트워크 레이턴시</h5><div class="heading-children"><div><ul>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(57%) 라우터가 동적으로 로드 밸런싱하여 트래픽을 조절하는 와중에, 그리고 크게 혼잡한 지역을 우회하는 와중에 이들 지연의 정도가 달라진다. 트래픽이 많은 시간대에 경로 변경이 많이 일어나게 되므로 RTT 값이 심하게 요동친다.</p>
<ul>
<li data-line="1">Memo :라우팅 결과로 경로의 길이가 짧아지거나 or 길어지는경우</li>
</ul>
</li>
<li data-line="3">
<p>(57%) 네트워크 코드를 작성할 때 RTT가 항상 일정하다고 가정해서는 안 된다. 어떤 두 호스트 사이의 RTT 값은 일정한 평균 지연 수치를 기준으로 오르락내리락하는 것이 보통이다.</p>
</li>
<li data-line="5">
<p>(57%) RTT의 기댓값으로부터 편차를 발생시키는데, 이러한 편차를 일컬어 지터링(jittering)이라 한다.</p>
</li>
<li data-line="7">
<p>(57%) 처리 지연. 네트워크 지연 요소 중 가장 영향이 미미한 만큼, 지터링에도 큰 영향을 미치지는 않는다.</p>
</li>
<li data-line="9">
<p>(57%) 전송 지연 및 전파 지연. 패킷이 타고 가는 경로에 따라 이 두 가지 지연 요소가 변동될 수 있다.</p>
</li>
<li data-line="11">
<p>(57%) 큐잉 지연. 라우터가 처리할 패킷의 숫자에 따라 큐잉 지연 정도가 변동된다. 즉, 라우터에 도착하는 패킷의 수가 달라지면 큐잉 지연의 정도도 달라진다는 것이다.</p>
</li>
<li data-line="13">
<p>(57%) 지터링은 RTT 대응 알고리즘에 부정적인 영향을 끼치며, 심할 때는 지터링 때문에 패킷이 도착하는 순서가 완전히 뒤바뀌기도 한다.</p>
</li>
<li data-line="15">
<p>(57%) 패킷 순서가 뒤바뀌는 것으로 인한 오류를 방지하려면, 패킷이 순서대로 전달되도록 보장하는 신뢰성 프로토콜인 TCP를 사용하거나, 패킷 순서를 맞춰주는 사설 시스템을 구현하여야 한다.</p>
</li>
<li data-line="17">
<p>(57%) 복잡한 동작을 매 프레임마다 하지 않고 적당히 합쳐 여러 프레임에 걸치도록 처리하면 프레임 레이트로 인한 지터링을 줄일 수 있다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="7.2 지터링" class="heading" id="7.2_지터링"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.2 지터링</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(57%) 패킷이 목적지에 도달하는데 시간이 너무 오래 걸려 버리거나, 아예 도달하지 못하는 경우를 패킷 손실이라 한다.</p>
</li>
<li data-line="2">
<p>(57%) 물리 매체에 문제 발생.</p>
</li>
<li data-line="4">
<p>(57%) 데이터 손상이 발생한 경우 링크 계층에서 체크섬을 검사하다 손상을 발견하게 되며, 손상된 프레임은 폐기된다.</p>
</li>
<li data-line="6">
<p>(57%) 링크 계층에 문제 발생.</p>
</li>
<li data-line="8">
<p>(57%) 어떤 경우엔, 링크 계층 채널이 꽉 차면 보내야 할 프레임 일부를 소각해 버릴 때가 있다. 링크 계층은 원래 신뢰성을 보장하지 않으므로, 이것이 잘못되었다 볼 수는 없다.</p>
</li>
<li data-line="10">
<p>(57%) 네트워크 계층에 문제 발생.</p>
</li>
<li data-line="12">
<p>(57%) 라우터가 처리할 수 있는 것보다 빠른 속도로 패킷이 도착하면 라우터는 이를 수신 대기열에 넣는다. 대기열의 용량에는 한계가 있으므로, 수용 가능 패킷 수를 넘어서면 대기열 내의 패킷 또는 새로 받은 패킷을 버리게 된다.</p>
</li>
<li data-line="14">
<p>(57%) 아울러 패킷의 개수를 최소한으로 줄이자. 라우터는 대개 패킷의 크기보다는 패킷의 개수로 대기열 용량을 결정하는 경우가 많다.</p>
</li>
<li data-line="16">
<p>(57%) 어떤 라우터는 수신 대역폭에 따라 발신자별로 대기열 공간을 할당하는 것도 있다. 이 경우엔 오히려 크기가 작은 패킷이 유리하다. 만일 공간이 부족하여 7개 패킷 중 하나가 버려져도, 나머지 6개는 대기열에 성공적으로 들어갈 수 있기 때문이다.</p>
</li>
<li data-line="18">
<p>(57%) 확실한 방법은 데이터센터의 라우터 및 가장 혼잡한 경로 상의 라우터 종류를 파악해 두는 것이다.</p>
</li>
<li data-line="20">
<p>(57%) 대기열이 가득 차는 경우, 라우터가 무조건 새로 받은 패킷을 버리는 것은 아니며 그 대신 이미 대기열에 들어 있는 패킷을 버릴 수도 있다. 새로 받은 패킷이 우선순위가 더 높거나, 대기열에 있는 것보다 중요하다고 판단된 경우 그렇다.</p>
</li>
<li data-line="22">
<p>(57%) TCP 패킷에 앞서 UDP를 먼저 폐기하는데, TCP 패킷은 폐기해도 발신자가 자동으로 재발신하기 때문에 폐기하는 의미가 없다는 점에 기인한 것이다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="7.3 패킷 손실" class="heading" id="7.3_패킷_손실"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.3 패킷 손실</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(58%) TCP에 내장된 신뢰성 시스템에 의존할 것인가, 아니면 UDP 위에 신뢰성 시스템을 직접 구축할 것인가, 하는 문제에 대한 답을 내리는 것으로, 이들 전송 계층 각각의 이점과 비용을 고려해 볼 필요가 있다.</p>
</li>
<li data-line="2">
<p>(58%) TCP의 가장 큰 장점은 오랜 시간 검증되어 견고하면서도 안정적인 신뢰성 시스템이 구현되어 있다는 것이다. 엔지니어링 수고를 추가로 들이지 않고도 데이터가 확실히 전달되도록 보장할 뿐만 아니라 그 순서 역시 올바르게 유지한다. 부가적인 장점으로 복잡다단한 혼잡 통제 기능을 갖추고 있어, 중도의 라우터를 압도하지 않도록 패킷 전송량을 제한하면서 데이터 전송률을 제어하기도 한다.</p>
</li>
<li data-line="4">
<p>(58%) TCP의 단점은 보내는 모든 데이터에 이처럼 예외 없이 신뢰성을 보장하며 순서 역시 보장하여 전송한다는 것이다.</p>
</li>
<li data-line="6">
<p>(58%) 중요도가 낮은 데이터를 기다리느라 중요도가 높은 데이터가 지연됨.</p>
</li>
<li data-line="8">
<p>(58%) 폭발음 패킷을 놓쳐도 플레이어 A 입장에선 크게 신경 쓸 것이 없는데, 심지어 폭발이 일어났는지 아예 몰라도 큰 상관이 없을 것이다. 그렇지만 TCP는 모든 패킷을 순서대로 처리해야 하므로, TCP 모듈은 손실된 폭발음 패킷을 서버로부터 다시 받기 전까지 이미 수신해 둔 사격 패킷을 제때 먼저 처리해 주지 않을 것이다.</p>
</li>
<li data-line="10">
<p>(58%) 순서가 보장되어야 하는 별개의 두 스트림이 서로 간섭함.</p>
</li>
<li data-line="12">
<p>(58%) 누락된 채팅 메시지를 기다리느라 헤드샷 패킷이 처리가 안 되고 있더라는 사실을 플레이어가 알아채면 납득하기 어려워할 터이다. 그렇지만 TCP만 사용하는 게임에서 이 같은 일이 곧잘 일어난다.</p>
</li>
<li data-line="14">
<p>(58%) 오래된 게임 상태를 재전송.</p>
</li>
<li data-line="16">
<p>(58%) 플레이어 B가 최종 위치 x=100에 근접하는 동안, 서버는 x=0 근처의 오래된 예전 위치를 재전송하게 된다는 뜻이다.</p>
</li>
<li data-line="18">
<p>(58%) 혼잡 제어 기능 덕에 패킷 손실이 줄어들기는 하지만 플랫폼마다 이를 제어하는 방법이 제각각이며 예상한 것보다 패킷을 느리게 보내는 결과가 종종 나타나기도 한다.</p>
</li>
<li data-line="20">
<p>(58%) 네이글 알고리즘의 영향이 큰 비중을 차지하는데, 네이글 알고리즘은 패킷을 0.5초 정도 모았다가 보내곤 하기 때문이다.</p>
</li>
<li data-line="22">
<p>(58%) 사실 TCP를 전송 프로토콜로 채택하는 게임에선 보통 네이글 알고리즘을 비활성화시켜 이러한 문제를 피하려 하는데, 반대급부로 패킷 수를 줄여주는 장점도 포기해야 한다.</p>
</li>
<li data-line="24">
<p>(58%) TCP는 연결을 관리하고 재전송에 필요한 데이터를 추적하기 위해 많은 리소스를 할당한다.</p>
</li>
<li data-line="26">
<p>(58%) UDP는 TCP와 달리, 여타의 신뢰성 보장 메커니즘 또는 흐름 제어 기능을 내장하고 있지 않다. 대신에 마치 빈 도화지처럼 원하는 종류의 사설 신뢰성 메커니즘을 게임에 맞게 구현할 수 있는 여지가 있다.</p>
</li>
<li data-line="28">
<p>(58%) 전달을 보장할 데이터와 그렇지 않은 데이터를 구분하거나, 신뢰성이 필요한 여러 별개의 스트림을 서로 엮어서 보내는 것도 구현할 수 있다.</p>
</li>
<li data-line="30">
<p>(58%) 손실된 패킷을 재전송할 때, 오래된 데이터를 있는 그대로 보내는 대신 최신 데이터로 업데이트해 보내는 것도 가능하다. 메모리를 직접 관리하고, 네트워크 계층 패킷에 데이터를 어떻게 묶을지도 얼마든지 직접 설계할 수 있다.</p>
</li>
<li data-line="32">
<p>(58%) UDP는 패킷이 손실될 위험이 아무래도 큰데 앞서 언급한 것처럼 라우터가 혼잡할 때 UDP 패킷부터 폐기하게 설정되어 있기 때문이다.</p>
</li>
<li data-line="34">
<p>(58%) 대부분은 어느 프로토콜을 쓸 것인지 정하는 문제는 하나의 질문으로 정리된다. 그것은 바로 게임의 모든 데이터 전달이 보장되어야 하는가, 그리고 순서가 완전히 보장되어야 하는가이다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="7.4 신뢰성: TCP냐 UDP냐" class="heading" id="7.4_신뢰성:_TCP냐_UDP냐"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.4 신뢰성: TCP냐 UDP냐</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(58%) 게임에 UDP 프로토콜이 더 적합하다면, 신뢰성 메커니즘을 구현해야 한다. 그러한 시스템의 첫째 요구 사항은 바로 패킷이 목적지에 도착했는지 아닌지를 알아내는 것이다.</p>
</li>
<li data-line="2">
<p>(58%) 패킷 배달 통지(packet delivery notification) 모듈을 만들어야 하는데, 이 모듈의 역할은 상위 코드 대신 패킷을 원격 호스트에 보내고 패킷이 배달되었는지를 상위 코드에 나중에 알려주는 것이다.</p>
</li>
<li data-line="4">
<p>(58%) 배달 통지 모듈은 재전송까지는 수행하지 않으며, 상위 코드에서 꼭 필요로 하는 경우에만 재전송을 수행한다.</p>
</li>
<li data-line="6">
<p>(58%) 패킷을 발신할 때 패킷마다 고유한 꼬리표(tag)를 붙여, 배달 상태 목록에 항목을 추가하고 이 항목을 윗단 모듈에 제공하여 수신 여부를 추적할 수 있게 해 준다.</p>
</li>
<li data-line="8">
<p>(58%) 수신 측에선 들어오는 패킷을 받아들일지 살펴보고, 받아들이기로 한 패킷에 대해 확인응답을 보내준다.</p>
</li>
<li data-line="10">
<p>(58%) 송신 측에선 확인응답을 받아 윗단 모듈에 패킷이 수신되었음을, 혹은 누락되었음을 알려준다.</p>
</li>
<li data-line="12">
<p>(58%) UDP 신뢰성 메커니즘에 보너스가 하나 있다면, 누락이 될지언정 패킷 순서가 뒤바뀌는 일은 없다는 것이다.</p>
</li>
<li data-line="14">
<p>(58%) 만일 수신 호스트가 새로운 패킷을 받은 후 뒤늦게 오래된 패킷을 받으면, 배달 통지 관리자는 패킷이 손실된 것으로 치고 무시해 버린다.</p>
</li>
<li data-line="16"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>(59%) 확인응답이 빠진 중도 패킷에 대해선 송신 측에서 인지하고 필요 시 재전송할 것임</p>
<ul>
<li data-line="17">Memo :재전송시 sequence number 관리는 어떻게?? 재전송 패킷, 다음 패킷 수신때마다 number가 계속 점프할듯</li>
</ul>
</li>
<li data-line="19">
<p>(59%) 배달 통지 관리자는 보내는 패킷마다 고유한 꼬리표를 붙여, 수신 호스트가 어느 패킷을 받았는지 그 꼬리표로 확인응답 가능하게 해 주어야 한다.</p>
</li>
<li data-line="21">
<p>(59%) 그저 발신한 패킷을 서로 구별할 수 있는 고유 식별자 역할만 한다.</p>
</li>
<li data-line="23">
<p>(59%) 일단 배달 통지 관리자가 패킷에 고유 번호로 꼬리표를 달고 나면, 패킷의 페이로드를 채우고 원격 호스트에 전달하는 것은 응용프로그램의 몫이다.</p>
</li>
<li data-line="25">
<p>(59%) 시퀀스 번호가 기다리고 있던 것보다 낮으므로 이미 지나가 버린 것임. 조용히 폐기처리</p>
</li>
<li data-line="27">
<p>(59%) // 기다리고 있던 것보다 뒤의 패킷이 먼저 도착하였음, 즉 패킷 손실이 발생하였음<br>
// 중간의 모든 패킷은 누락된 것으로 처리하고 이 패킷 다음 것을 기다리도록 함</p>
</li>
<li data-line="30">
<p>(59%) 배달 통지 관리자는 순서가 뒤바뀐 패킷을 걸러낸다. 수신 측 호스트가 받을 것으로 기대하는, 즉 지금 것 바로 다음의 패킷 시퀀스 번호는 mNextExpectedSequenceNumber 멤버 변수에 담아둔다.</p>
</li>
<li data-line="32">
<p>(59%) 패킷이 매번 발신될 때마다 시퀀스 번호가 연이어 증가하므로, 들어오는 패킷이 어떤 시퀀스 번호일지 수신 호스트 입장에서 쉽게 예상할 수 있다.</p>
</li>
<li data-line="34">
<p>(59%) 수신된 시퀀스 번호가 예상 시퀀스 번호와 정확히 일치함.</p>
</li>
<li data-line="36">
<p>(59%) 이 경우 응용프로그램이 패킷을 받았다고 확인응답하고 처리해 주어야 한다.</p>
</li>
<li data-line="38">
<p>(59%) 수신된 시퀀스 번호가 예상 시퀀스 번호보다 작음.</p>
</li>
<li data-line="40">
<p>(59%) 아마도 최근에 받은 패킷보다 오래된 패킷이 도착한 것일 터이다. 순서가 뒤바뀐 것이므로 호스트는 이 패킷을 처리해선 안 된다. 패킷을 받았다고 확인응답해서도 안 되는데, 호스트는 오로지 자신이 처리한 패킷에 대해서만 확인응답해야 하기 때문이다.</p>
</li>
<li data-line="42">
<p>(59%) mNextExpectedSequenceNumber가 PacketSequenceNumber의 최댓값에 근접해 있고, 방금 수신한 번호가 최솟값에 가깝다면, 시퀀스 번호가 오버플로되어 그런 것일 수 있다.</p>
</li>
<li data-line="44">
<p>(59%) 수신된 시퀀스 번호가 예상 시퀀스 번호보다 큼.</p>
</li>
<li data-line="46">
<p>(59%) 중도에 하나 이상의 패킷이 누락되었거나 지연된 경우이다. 받을 것으로 예상한 패킷보다 나중에 발신된 패킷이 먼저 도착하여, 그 시퀀스 번호가 기대한 번호보다 큰 것이다.</p>
</li>
<li data-line="48">
<p>(59%) 단지 순서가 꼬이지 않게 해 주고 패킷 손실이 발생했을 때 이를 알려줄 뿐이다.</p>
</li>
<li data-line="50">
<p>(59%) ProcessSequenceNumber()는 직접 확인응답을 보내지는 않는다. 대신 AddPendingAck() 함수를 호출해 확인응답을 보낼 시퀀스 번호를 기억해 둔다.</p>
</li>
<li data-line="52">
<p>(59%) 효율성을 높이기 위해 이렇게 하는데, 호스트가 다른 호스트로부터 많은 패킷을 받을 때 패킷마다 일일이 확인응답을 보내면 비효율적이기 때문이다.</p>
</li>
<li data-line="54">
<p>(59%) 배달 통지 관리자가 보내게 될 확인응답은 그 시퀀스 번호가 연속적일 수도 있지만 그렇지 않은 것이 뒤섞여 있을 수도 있다. 이를 효율적으로 추적하고 직렬화하기 위해 연속된 범위를 하나의 AckRange 객체로, 그리고 여러 범위 객체를 mPendingAcks에 vector로 모아둔다.</p>
</li>
<li data-line="56">
<p>(59%) AckRange 객체는 시작과 끝이 연속적인 시퀀스 범위를 나타낸다.</p>
</li>
<li data-line="58">
<p>(60%) 개수를 직렬화하는 대신 기댓값 1로 엔트로피 인코딩을 시도하여 최적화를 도모한다.</p>
</li>
<li data-line="60">
<p>(60%) 내보낼 패킷에 먼저 자신의 시퀀스 번호를 기록한 후, WritePendingAcks()를 호출하여 지금까지 모아둔 확인응답을 기록한다.</p>
</li>
<li data-line="62">
<p>(60%) 왜 하나만 기록하냐면 패킷 손실이란 어디까지나 예외 상황이지 규칙적으로 발생한다고는 볼 수 없으므로, 대부분의 경우 범위는 하나에 국한될 것이기 때문이다.</p>
</li>
<li data-line="64">
<p>(60%) 모아둔 범위 목록을 전부 다 기록해 버릴 수도 있겠지만, 그러면 또 몇 개의 범위가 있는지 기록해야 하는 등 패킷의 덩치가 커질 것이다.</p>
</li>
<li data-line="66">
<p>(60%) 게임의 트래픽 패턴을 분석해 보는 일이 중요한데, 이를 통해 극단적인 경우에 대응할 만큼 유연하되 일반적인 경우에 최적화된 시스템을 설계할 수 있기 때문이다.</p>
</li>
<li data-line="68">
<p>(60%) 확인응답이 오지 않았다고 해서 데이터 패킷이 꼭 사라진 것은 아니니 주의하자. 데이터는 잘 도착했는데, 확인응답을 담은 패킷이 오다가 사라진 것일 수도 있다. 보내는 호스트 입장에선 이 두 가지 경우를 구별하기가 어렵다.</p>
</li>
<li data-line="70">
<p>(60%) 클라이언트 모듈이 확인응답이 없다 보니 신뢰성 데이터를 재전송하긴 하지만 수신 측 호스트가 이미 가지고 있을 수도 있다. 이 경우에 중복을 확인하고 방지하는 것은 상위 모듈의 책임이다.</p>
</li>
<li data-line="72">
<p>(60%) 호스트는 데이터 패킷을 보내고 나서, 그 패킷에 대한 확인응답을 기다렸다 처리해야 한다. 기다리던 확인응답이 도착하면 배달 통지 관리자는 패킷이 잘 도착한 것으로 판단하고, 배달 여부를 궁금해하는 원래 모듈에 알려준다. 확인응답이 도착하지 않으면 패킷이 사라진 것으로 간주하고, 마찬가지로 윗단 모듈에 알려준다.</p>
</li>
<li data-line="74">
<p>(60%) // 패킷의 시퀀스 번호가 확인응답의 시퀀스 번호보다 작으면,<br>
// 확인응답을 받지 못한 것이므로 아마 누락되었을 것임</p>
</li>
<li data-line="77">
<p>(60%) // 일부 응답이 어떤 연유에선지 제거되었음(시간 초과 가능성)</p>
</li>
<li data-line="79">
<p>(60%) 확인응답은 순서대로 도착하므로, 주어진 범위보다 작은 시퀀스 번호의 패킷은 모두 누락되었다고 가정할 수 있다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="7.5 패킷 배달 통지" class="heading" id="7.5_패킷_배달_통지"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.5 패킷 배달 통지</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="7.5.1 외부로 나가는 패킷에 꼬리표 달기" class="heading" id="7.5.1_외부로_나가는_패킷에_꼬리표_달기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.5.1 외부로 나가는 패킷에 꼬리표 달기</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="7.5.2 패킷을 받고 확인응답하기" class="heading" id="7.5.2_패킷을_받고_확인응답하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.5.2 패킷을 받고 확인응답하기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(61%) 수신 측 호스트가 응답 패킷을 보낼 준비가 되면 내보낼 패킷에 먼저 자신의 시퀀스 번호를 기록한 후, WritePendingAcks()를 호출하여 지금까지 모아둔 확인응답을 기록한다</p>
</li>
<li data-line="2">
<p>(61%) 왜 하나만 기록하냐면 패킷 손실이란 어디까지나 예외 상황이지 규칙적으로 발생한다고는 볼 수 없으므로, 대부분의 경우 범위는 하나에 국한될 것이기 때문이다.</p>
</li>
<li data-line="4">
<p>(61%) 게임의 트래픽 패턴을 분석해 보는 일이 중요한데, 이를 통해 극단적인 경우에 대응할 만큼 유연하되 일반적인 경우에 최적화된 시스템을 설계할 수 있기 때문이다.</p>
</li>
<li data-line="6">
<p>(61%) 클라이언트 모듈이 확인응답이 없다 보니 신뢰성 데이터를 재전송하긴 하지만 수신 측 호스트가 이미 가지고 있을 수도 있다. 이 경우에 중복을 확인하고 방지하는 것은 상위 모듈의 책임이다.</p>
</li>
<li data-line="8">
<p>(61%) // 사본을 만든 다음, 목록에서 일단 제거함<br>
// 핸들링 도중 살아있는 패킷이 무엇인지 찾아볼 때 이 패킷이 보여서는 안 되기 때문</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h5 data-heading="7.5.3 확인응답 처리 및 배달 여부 알리기" class="heading" id="7.5.3_확인응답_처리_및_배달_여부_알리기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.5.3 확인응답 처리 및 배달 여부 알리기</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(62%) 확인응답은 순서대로 도착하므로, 주어진 범위보다 작은 시퀀스 번호의 패킷은 모두 누락되었다고 가정할 수 있다. 따라서 이들을 배달하는 데 실패했다고 보고한다</p>
</li>
<li data-line="2">
<p>(62%) 그런 다음 주어진 범위 내의 패킷은 모두 배달에 성공했다고 보고한다. 한 번에 여러 개의 패킷이 동시에 배달 중일 수 있지만 그렇다고 해서 모든 InFlightPacket을 일일이 확인해야 하는 건 아니다. mInFlightPackets은 deque이므로 거기에 들어가는 InFlightPacket은 모두 시퀀스 번호의 순서대로 들어가 있다</p>
</li>
<li data-line="4">
<p>(62%) 마지막 else if절은 예외 사항 하나를 처리하기 위해 필요한데, 검사하려는 패킷이 AckRange 범위 내에 포함되긴 하지만 중간을 건너뛴 경우이다. 그 앞의 패킷들은 어쩌다 보니 이전 처리에서 누락되었다고 보고가 이미 되어버린 상태이다. 이때는 그냥 패킷의 시퀀스 번호를 건너뛰고, 나머지 패킷에 대해서만 배달 성공으로 보고한다</p>
</li>
<li data-line="6">
<p>(62%) 바로 확인응답이 도달하는데 시간이 너무 오래 걸려서 그렇다</p>
</li>
<li data-line="8">
<p>(62%) 트래픽이 드문드문하면 여러 패킷이 연속 AckRange로 묶이지 않아, 결과적으로 중간중간 이가 빠지는 패킷을 찾기가 힘든데, 이때 시간 초과를 검사하면 이를 찾는 데 도움이 된다</p>
</li>
<li data-line="10">
<p>(62%) InFlightPacket이 발신된 시각을 GetTimeDispatched() 멤버 함수로 얻어온다</p>
</li>
<li data-line="12">
<p>(62%) 손실율이 너무 크다면 관련 모듈에 이를 알려 송신 빈도를 줄이게끔 조치하거나, UI 모듈을 통해 플레이어에게 네트워크 연결에 문제가 있음을 직접 알려줄 수 있다.</p>
</li>
<li data-line="14">
<p>(62%) 항상 WriteSequenceNumber()에서 증가시키는 mDispatchedPacketCount 값과 일치해야 한다.</p>
</li>
<li data-line="16">
<p>(62%) unordered_map을 순회하는 것은 비효율적이며 캐시 미스(cache miss)를 자주 유발한다</p>
</li>
<li data-line="18">
<p>(62%) 변수가 몇 개 더 필요하다 해도 map보다는 vector를 정렬해 쓰는 게 좋겠다.</p>
</li>
<li data-line="20">
<p>(62%) 배달 통지 관리자로 패킷 상태를 추적하려는 모듈은 TransmissionData를 상속받아 이들 가상 함수를 구현한다. 그다음 패킷의 메모리 스트림에 데이터를 기록한 뒤, TransmissionData 서브클래스를 생성하여 SetTransmissionData()로 InFlightPacket에 부착한다</p>
</li>
<li data-line="22">
<p>(62%) 나중에 원래 모듈에 배달 통지 관리자가 패킷 배달 성공/실패 여부를 알려줄 때, 패킷에 부착된 TransmissionData 인스턴스 및 부가 정보를 고스란히 이용할 수 있다</p>
</li>
<li data-line="24">
<p>(62%) 해당 상황을 어떻게 다루면 좋을지 판단하는데 이 정보를 이용한다. 어떤 데이터를 다시 보내야 한다면 그렇게 해 주면 된다</p>
</li>
<li data-line="26">
<p>(62%) 서버는 클라이언트마다 하나씩 총 10개의 배달 통지 관리자를 가지고 있어야 한다. 반대로 클라이언트는 자신이 연결된 서버 한 대를 위한 관리자 하나만 가지고 있으면 된다.</p>
</li>
<li data-line="28">
<p>(62%) 여기서 만든 배달 통지 관리자로 데이터를 전송할 때 신뢰성을 확보하고 싶으면, 단순히 목적지에 도착하지 못한 데이터를 재전송해 주면 된다</p>
</li>
<li data-line="30">
<p>(62%) HandleDeliveryFailed()가 호출되면 새 패킷을 만들어 데이터를 다시 보낸다</p>
</li>
<li data-line="32">
<p>(62%) 누락된 데이터를 그대로 다시 보내는 대신 새로운 데이터로 교체하여 보내서, TCP보다 개선된 신뢰성을 제공한다는 것이다.</p>
</li>
<li data-line="34">
<p>(62%) 스타시즈: 트라이브스의 고스트 관리자에서 착안한 것이다</p>
</li>
<li data-line="36">
<p>(62%) ReplicateCreate(), ReplicateUpdate(), ReplicateDestroy()를 호출하여 각각 원격 객체를 생성, 갱신, 소멸할 수 있었다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="7.6 객체 리플리케이션 신뢰성" class="heading" id="7.6_객체_리플리케이션_신뢰성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.6 객체 리플리케이션 신뢰성</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(63%) 데이터 전송에 신뢰성을 확보하려면 데이터를 싣고 간 패킷이 누락되었다는 걸 리플리케이션 관리자가 알아챈 순간 다시 보낼 수 있어야 한다</p>
</li>
<li data-line="2">
<p>(63%) 게임 코드는 리플리케이션 관리자를 주기적으로 폴링하여, 미리 준비된 패킷을 관리자에게 들이밀고 혹시 여기에 쓰고 싶은 데이터가 있는지 확인해야 한다</p>
</li>
<li data-line="4">
<p>(63%) 게임 시스템은 예상 대역폭, 패킷 손실율 및 기타 휴리스틱 정보를 토대로 리플리케이션 관리자에게 패킷을 들이미는 빈도를 정한다.</p>
</li>
<li data-line="6">
<p>(63%) 변경된 데이터가 있을 때 게임 시스템이 패킷을 직접 만들지 않고, 리플리케이션 관리자에 변경 사실만 알려주면 관리자가 그다음 차례에 데이터 기록 및 패킷 생성까지도 전담하게 하는 것이다</p>
</li>
<li data-line="8">
<p>(63%) 리플리케이션 명령, 대상 객체 포인터, 기록한 상태 비트 등을 모아 InFlightPacket 레코드에 TransmissionData 항목으로 부착해 둘 수 있다.</p>
</li>
<li data-line="10">
<p>(63%) 만일 리플리케이션 관리자가 패킷이 누락되었음을 알게 되면, 패킷에 부착된 레코드를 토대로 원래 패킷을 작성할 때 썼던 명령 및 객체을 알아내어 같은 명령, 객체, 상태 비트 조합으로 새로운 데이터를 담은 패킷을 새로 작성할 수 있다.</p>
</li>
<li data-line="12">
<p>(63%) 신선도가 떨어질 소지가 있는 원래 데이터 대신 리플리케이션 관리자가 새 데이터를 기준으로 패킷을 만들 수 있기 때문이다</p>
</li>
<li data-line="14">
<p>(63%) 게임 시스템은 이를 이용해 각 게임 객체마다 일괄 생성, 일괄 갱신, 일괄 소멸 요청을 넣는다</p>
</li>
<li data-line="16">
<p>(63%) 모든 프로퍼티가 리플리케이션되도록 초기 상태 비트를 설정한다</p>
</li>
<li data-line="18">
<p>(63%) BatchStateDirty()를 호출하면 객체의 식별자에 매핑해 둔 명령의 상태 비트가 갱신되어 나중에 리플리케이션 관리자가 어떤 부분이 바뀌었는지 알 수 있다</p>
</li>
</ul></div><div class="heading-wrapper"><h5 data-heading="7.6.1 이미 전송 중인 최신 상태의 재전송을 막아 최적화하기" class="heading" id="7.6.1_이미_전송_중인_최신_상태의_재전송을_막아_최적화하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.6.1 이미 전송 중인 최신 상태의 재전송을 막아 최적화하기</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="7.7 실제와 유사한 환경을 꾸며 테스트하기" class="heading" id="7.7_실제와_유사한_환경을_꾸며_테스트하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.7 실제와 유사한 환경을 꾸며 테스트하기</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="7.8 요약" class="heading" id="7.8_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.8 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="8장 레이턴시 대응 강화" class="heading" id="8장_레이턴시_대응_강화"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8장 레이턴시 대응 강화</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="8.1 더미 터미널 클라이언트" class="heading" id="8.1_더미_터미널_클라이언트"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1 더미 터미널 클라이언트</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="8.2 클라이언트 측 보간" class="heading" id="8.2_클라이언트_측_보간"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2 클라이언트 측 보간</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="8.3 클라이언트 측 예측" class="heading" id="8.3_클라이언트_측_예측"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3 클라이언트 측 예측</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="8.3.1 데드 레커닝" class="heading" id="8.3.1_데드_레커닝"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.1 데드 레커닝</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="8.3.2 클라이언트 이동 예측 및 이동 조작 되새김" class="heading" id="8.3.2_클라이언트_이동_예측_및_이동_조작_되새김"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.2 클라이언트 이동 예측 및 이동 조작 되새김</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="8.3.3 레이턴시를 교묘하게 감추기" class="heading" id="8.3.3_레이턴시를_교묘하게_감추기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.3 레이턴시를 교묘하게 감추기</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="8.4 서버 측 되감기" class="heading" id="8.4_서버_측_되감기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.4 서버 측 되감기</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="8.5 요약" class="heading" id="8.5_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.5 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="9장 규모 확장에 대응하기" class="heading" id="9장_규모_확장에_대응하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9장 규모 확장에 대응하기</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="9.1 객체 스코프 내지 연관성" class="heading" id="9.1_객체_스코프_내지_연관성"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1 객체 스코프 내지 연관성</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="9.1.1 스태틱 존" class="heading" id="9.1.1_스태틱_존"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1 스태틱 존</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="9.1.2 시야 절두체 사용" class="heading" id="9.1.2_시야_절두체_사용"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.2 시야 절두체 사용</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="9.1.3 기타 가시성 기법" class="heading" id="9.1.3_기타_가시성_기법"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.3 기타 가시성 기법</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="9.1.4 보이지 않아도 스코프에 포함되어야 하는 경우" class="heading" id="9.1.4_보이지_않아도_스코프에_포함되어야_하는_경우"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.4 보이지 않아도 스코프에 포함되어야 하는 경우</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="9.2 서버 파티셔닝" class="heading" id="9.2_서버_파티셔닝"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2 서버 파티셔닝</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="9.3 인스턴싱" class="heading" id="9.3_인스턴싱"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3 인스턴싱</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="9.4 우선순위와 빈도" class="heading" id="9.4_우선순위와_빈도"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.4 우선순위와 빈도</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="9.5 요약" class="heading" id="9.5_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.5 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="10장 보안" class="heading" id="10장_보안"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10장 보안</h3><div class="heading-children"><div><ul>
<li data-line="0">
<p>(74%) 전송 중인 데이터가 고스란히 노출되는 특성상, 전달 경로 중도의 머신 하나가 특정 패킷 데이터 전체를 들여다보는 것을 막을 방법이 없다.</p>
</li>
<li data-line="2">
<p>(74%) 패킷 심층 분석(deep packet inspection)</p>
</li>
<li data-line="4">
<p>(74%) 패킷의 내용을 보고 우선순위를 정한다는 것이다. 이때 패킷의 내용을 읽어 안에 무엇이 들어 있는지 검사하는데, P2P 파일 공유 데이터라면 우선순위를 낮추고, 인터넷 전화(VoIP) 패킷이라면 높이고 하는 식이다.</p>
</li>
<li data-line="6">
<p>(74%) 패킷 스니핑(packet sniffing)은 일반적 네트워크 동작 수행 외의 목적으로 패킷 데이터를 읽어 들이는 행위이다.</p>
</li>
<li data-line="8">
<p>(74%) 중간자 공격(man-in-the-middle attack)이란 발신지에서 목적지로 가는 경로 도중 한 지점의 컴퓨터가 양쪽에 대한 사전 정보 없이 패킷을 감청하는 것을 말한다.</p>
</li>
<li data-line="10">
<p>(74%) 악의를 가진 사용자가 네트워크로 오가는 모든 데이터에 접근할 수 있다고 가정해야 한다.</p>
</li>
<li data-line="12">
<p>(74%) 중간자 공격을 막는 일반적인 방법은 바로 모든 데이터를 암호화하여 보내는 것이다.</p>
</li>
<li data-line="14">
<p>(74%) 금전적 목적을 가지고 정보를 탈취하려는 의도에서 3자가 노리는 먹잇감이 바로 이러한 신용 카드나 로그인 정보이기 때문이다.</p>
</li>
<li data-line="16">
<p>(74%) 공유 키 암호화(public key cryptography)를 써서 기밀 정보를 암호화하는 것이 바람직하다. 앨버트와 벤저민이</p>
</li>
<li data-line="18">
<p>(74%) 서버에 로그인하려면 로그인 아이디와 암호를 서버의 공유 키로 암호화해서 보낸다. 이 로그인 패킷은 서버의 사설 키로만 해독할 수 있으며, 사설 키는 오로지 서버만이 알고 있어야 한다.</p>
</li>
<li data-line="20">
<p>(74%) RSA 시스템은 세미프라임(semiprime)이라는 매우 큰 숫자에 기반하는데, 세미프라임은 두 소수의 곱이라는 뜻이다.</p>
</li>
<li data-line="22">
<p>(74%) RSA의 사설 키는 세미프라임을 소인수 분해한 것에 기반한다. 이 체계로 구해진 숫자의 정수 해를 다항 시간 내에 구할 수 있는 알고리즘은 존재하지 않는 것으로 알려져 있으며, 커다란 두 소수의 곱으로 구해진 1024비트나 2048비트 세미프라임을 단순 파해법으로 구하는 건 현재 지구상의 가장 강력한 슈퍼컴퓨터로도 불가능하다.</p>
</li>
<li data-line="24">
<p>(75%) 양자 컴퓨터 알고리즘인 쇼어 알고리즘(Shor’s algorithm)으로 정수를 양자 다항 시간 내에 소인수 분해할 수 있다.</p>
</li>
<li data-line="26">
<p>(75%) 다른 시나리오는 다항 시간 내에 소인수 분해를 할 수 있는 알고리즘이 일반 컴퓨터용으로 개발되는 것이다.</p>
</li>
<li data-line="28">
<p>(75%) RSA는 이미 잘 구축된 암호 시스템이므로, 이걸 직접 새로 구현하려 시도하는 건 재능의 낭비라 하겠다. 그 대신 OpenSSL처럼 믿을만한 오픈 소스 RSA를 쓰는 것을 추천한다.</p>
</li>
<li data-line="30">
<p>(75%) 모든 네트워크 게임은 호스트 머신에서 수행하는 패킷 스니핑에 노출되어 있다고 보아야 한다.</p>
</li>
<li data-line="32">
<p>(75%) 사용자가 자신의 호스트 머신에서 스니핑을 시도하면 데이터를 암호화해 봤자 스니핑을 번거롭게 할 뿐 완벽한 대책은 되지 못한다.</p>
</li>
<li data-line="34">
<p>(75%) 실행 파일상 코드 어딘가엔 분명히 수신한 데이터를 해독하는 부분이 있을 것이다. 그 해독 체계만 간파하면 패킷 데이터는 이제 암호화되어 있지 않은 것이나 진배없다.</p>
</li>
<li data-line="36">
<p>(75%) 복호화 코드를 리버스 엔지니어링해 클라이언트 어딘가에 저장된 사설 키를 찾아내는 데에는 시간이 걸린다. 그러므로 잠재적인 치터가 분석하기 어렵도록 암호화를 하는 편이 낫다.</p>
</li>
<li data-line="38">
<p>(75%) 호스트상 패킷 스니핑을 시도하는 플레이어가 알아내려는 것이 과연 무엇인가를 고민해 보는 것도 도움이 된다.</p>
</li>
<li data-line="40">
<p>(75%) 일반적으로 호스트 머신의 플레이어는 정보 노출형 치트를 시도하는데, 통상적인 수단으로는 알아낼 수 없는 정보를 편취하려는 의도이다. 이러한 치트를 억제하는 데 흔히 쓰는 방법은 각 호스트에 내려주는 정보의 양을 제한하는 것이다.</p>
</li>
<li data-line="42">
<p>(75%) 일반적으로 치트를 하려는 플레이어는 클라이언트에 보내는 어떤 데이터라도 들여다볼 수 있다고 가정해야 한다. 따라서 어떤 호스트에 데이터를 보낼 때 그 호스트와 관련된 것만, 그리고 꼭 필요한 것만 추려서 보내면 잠재적인 치트 시도를 최소화할 수 있다.</p>
</li>
</ul></div><div class="heading-wrapper"><h4 data-heading="10.1 패킷 스니핑" class="heading" id="10.1_패킷_스니핑"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1 패킷 스니핑</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="10.1.1 중간자 공격" class="heading" id="10.1.1_중간자_공격"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1.1 중간자 공격</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="10.1.2 호스트 머신상 패킷 스니핑" class="heading" id="10.1.2_호스트_머신상_패킷_스니핑"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1.2 호스트 머신상 패킷 스니핑</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(75%) 입력 검증은 단순한 전제에서 출발하는데, 네트워크로 받은 패킷의 액션을 맹목적으로 수행하지 않는다는 것이다. 그에 앞서 해당 액션이 해당 시점에 유효한 것인지부터 먼저 검사한다.</p>
</li>
<li data-line="2">
<p>(75%) 유효하지 않은 액션이 발각되면 즉각 해당 플레이어에게 응분의 조치를 취하고 싶은 충동이 들 수도 있다. 하지만 레이턴시나 패킷 손실로 인해 입력이 꼬이는 경우도 고려해야 한다.</p>
</li>
<li data-line="4">
<p>(75%) 플레이어 A가 침묵 주문에 당했다고 하면 서버는 침묵 상태에 해당하는 갱신 패킷을 플레이어 A에 보낼 것이다. 그렇지만 이 패킷이 미처 전달되기 전에 플레이어 A가 어떤 주문을 시전해 버린 경우도 있을 수 있다</p>
</li>
<li data-line="6">
<p>(75%) 권한 집중형 서버 모델에선 게임 상태 전체를 꿰고 있는 건 서버밖에 없다. 서버가 어떤 클라이언트한테 대미지를 입었다고 전하면 클라이언트로선 이것이 올바른지 어떤지 검증하기가 참 애매하다.</p>
</li>
<li data-line="8">
<p>(75%) 서버가 고의로 잘못된 데이터를 보내지 못하게 막는 간단하면서도 궁극적인 해결책은 바로 플레이어에게 게임의 호스트 권한을 아예 주지 않는 것이다.</p>
</li>
<li data-line="10">
<p>(75%) 표준 CS 모델에선 클라이언트 B가 공을 A에게 던지면 이 정보는 클라이언트 B에서 서버로 전달되고, 다음 서버에서 클라이언트 A로 전달될 것이다. 검증 계층을 추가하여, 클라리언트 B가 공을 던지는 동시에 다른 모든 클라이언트에게 패킷을 보내 자신이 공을 던졌다고 알려준다. 그러면 클라이언트 A가 B의 공을 맞았다는 패킷을 서버에게 받을 때, 클라이언트 B가 진짜로 던진 사실이 있는지를 검증할 수 있다.</p>
</li>
<li data-line="12">
<p>(75%) 하지만</p>
</li>
<li data-line="14">
<p>(75%) 첫째로 각 클라이언트가 서버에는 접속할 수 있지만, 다른 클라이언트에는 접근할 수 없는 경우가 있다. NAT 투과나 방화벽 등이 이러한 문제의 주범이다.</p>
</li>
<li data-line="16">
<p>(75%) 둘째로 클라이언트가 서로 모두 연결할 수 있다 해도 P2P 패킷이 서버 패킷보다 빨리 도착한다는 보장이 없다.</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="10.2 입력 검증" class="heading" id="10.2_입력_검증"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2 입력 검증</h4><div class="heading-children"><div><ul>
<li data-line="0">
<p>(76%) 소프트웨어 치트 감지란, 게임 프로세스 내 또는 프로세스 외부에 별도의 소프트웨어를 구동하여 게임의 무결성을 능동적으로 감시하는 기법이다.</p>
</li>
<li data-line="2">
<p>(76%) 어떤 치트는 게임 프로세스에 후킹을 시도하며, 또 어떤 것은 게임 프로세스가 사용하는 메모리를 덮어쓰는 것도 있다.</p>
</li>
<li data-line="4">
<p>(76%) 락스텝 P2P 모델의 각 피어는 게임 상태 전체를 알고 있다. 따라서 각 피어의 메모리에는 게임 내 모든 유닛 위치 등 세세한 정보가 모두 들어 있다. 즉, 전장의 안개는 로컬 실행 파일에 구현되어 있으므로 치트 프로그램으로 제거하는 것도 얼마든지 가능하다.</p>
</li>
<li data-line="6">
<p>(76%) 맵핵(map hacking)</p>
</li>
<li data-line="8">
<p>(76%) 맵핵을 감지하기가 어려운 이유는 마땅히 감지할 방법이 없어서인데, 맵핵을 쓰더라도 다른 피어가 수신할 데이터에는 어떤 자취도 남기지 않기 때문이다.</p>
</li>
<li data-line="10">
<p>(76%) VAC는 밴(ban), 즉 차단당한 유저의 목록을 게임마다 유지한다. 밴 당한 유저가 VAC를 사용하는 서버에 접속하려 하면 서버는 접속을 거부해 버린다.</p>
</li>
<li data-line="12">
<p>(76%) 개략적으로 VAC는 런타임에서 이미 알려진 치트 프로그램을 검색한다. VAC가 치트 프로그램을 감지하는 데엔 여러 방법이 있는데, 그중 하나로 게임 프로세스의 메모리를 검사하는 기법이 있다.</p>
</li>
<li data-line="14">
<p>(76%) VAC는 밴 당할 유저의 목록을 만들어 두고 미래 적당한 시점으로 미루어 두었다가 한꺼번에 적용한다. 이런 식으로 해당 치트를 쓰는 플레이어를 최대한 많이 감지해 두었다가 나중에 모조리 밴 시켜 버리는 것이다.</p>
</li>
<li data-line="16">
<p>(76%) 순수 서버(pure server</p>
</li>
<li data-line="18">
<p>(76%) 밴 웨이브(ban wave)</p>
</li>
<li data-line="20">
<p>(76%) 밸브의 소스 엔진 채택 게임에만 적용되는 기능인데, 유저 접속 시 서버가 유저의 콘텐츠를 검사한다. 클라이언트는 서버에 접속하기 위해 갖고 있는 게임 관련 파일 전부에 대한 체크섬을 계산해 제출해야 한다. 만일 불일치가 있는 경우 서버는 클라이언트를 튕겨버린다.</p>
</li>
<li data-line="22">
<p>(76%) 워든(Warden)은 블리자드 엔터테인먼트에서 만들어 자사 게임 전체에 적용하고 있는 소프트웨어 치트 감지 프로그램이다.</p>
</li>
<li data-line="24">
<p>(76%) 치트가 발견되면 워든 서버로 정보를 보내어 미래 적당한 시점에 해당 유저를 밴 웨이브로 제재한다.</p>
</li>
<li data-line="26">
<p>(76%) 워든의 강력한 특징 중 하나는 게임이 실행되는 도중 워든이 자체 업데이트를 수행할 수 있다는 것이다. 이는 중요한 전술적 강점을 부여하는데, 치트 방지 솔루션의 새 패치가 공표되면 얼마간은 치트 유저가 치트 사용을 자제하는 경향이 있기 때문이다.</p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h4 data-heading="10.3 소프트웨어 치트 감지" class="heading" id="10.3_소프트웨어_치트_감지"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.3 소프트웨어 치트 감지</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="10.3.1 VAC" class="heading" id="10.3.1_VAC"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.3.1 VAC</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="10.3.2 워든" class="heading" id="10.3.2_워든"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.3.2 워든</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(76%) 디도스(DDoS, distributed denial-of-service, 분산 서비스 거부) 공격의 목적은 완료할 수 없는 요청을 서버에 무수히 날려 압도시킴으로써, 선량한 사용자의 접속을 차단하거나 서비스를 이용하지 못하게 하려는 것이다.</p>
</li>
<li data-line="2">
<p>(76%) 서버가 압도되는 이유로는 네트워크 연결이 감당할 수 없는 데이터를 수신해서, 또는 요청 분량을 서버의 CPU가 처리할 수 없어서 등이 있다.</p>
</li>
<li data-line="4">
<p>(76%) 깨졌거나 부적절한 패킷을 악의적인 사용자가 서버로 보내는 경우도 고려해야 한다. 이 같은 짓을 하는 이유는 몇 가지가 있을 것이다. 그중엔 단순하게 서버를 다운시켜보고 싶은 의도도 있겠지만, 보다 사악한 의도로 패킷을 통해 버퍼 오버플로를 일으켜 악성 코드를 실행시키거나 그와 유사한 공격을 시도하려는 것이다.</p>
</li>
<li data-line="6">
<p>(76%) 퍼즈 테스팅(fuzz testing)</p>
</li>
<li data-line="8">
<p>(76%) 일반적으로 퍼즈 테스팅이란 통상의 유닛 테스트나 QA 테스트 과정에서 발견하기 어려운 결함을 발견하기 위해 사용한다.</p>
</li>
<li data-line="10">
<p>(76%) 구조화되지 않은 대량의 데이터를 서버에 전송하는 것으로 네트워크 게임의 퍼즈 테스팅을 수행할 수 있다. 테스트 목적은 서버에 이러한 데이터를 보냈을 때 크래시가 나는지를 확인하고, 그 와중에 발견된 버그를 수정하는 데 있다.</p>
</li>
<li data-line="12">
<p>(76%) 수신된 시그니처를 바이트 단위로 비교하거나 해시를 검사하는 코드는 잠재적으로 타이밍 공격(timing attack) 또는 소요 시간 분석 공격에 취약하다. 이 공격은 고의로 잘못된 데이터를 보내어 보고 그것이 거부되는 데까지 걸리는 시간을 측정하여 특정 해시 알고리즘이나 암호화 시스템의 구현 내역에 대한 힌트를 얻는 데 사용된다.</p>
</li>
<li data-line="14">
<p>(76%) 특정 인덱스의 배열 원소가 일치하지 않는다면, 그 이후로는 더 이상 볼 필요가 없기 때문이다. 하지만 이렇게 미리 리턴해 버리는 코드가 바로 시간 분석 공격의 목표가 된다.</p>
</li>
<li data-line="16">
<p>(77%) 여기에 대한 보완책은 Compare() 함수를 다시 작성하여, 일치 여부 및 불일치 지점에 상관없이 같은 수행 시간이 걸리도록 만드는 것이다. 이러한 비교 작업에 있어선 비트 XOR 연산이 제격인데, 두 값이 일치하면 0이 되기 때문이다.</p>
</li>
<li data-line="18">
<p>(78%) 디도스(DDoS, distributed denial-of-service, 분산 서비스 거부) 공격의 목적은 완료할 수 없는 요청을 서버에 무수히 날려 압도시킴으로써, 선량한 사용자의 접속을 차단하거나 서비스를 이용하지 못하게 하려는 것이다</p>
</li>
<li data-line="20">
<p>(78%) 깨졌거나 부적절한 패킷을 악의적인 사용자가 서버로 보내는 경우도 고려해야 한다</p>
</li>
<li data-line="22">
<p>(78%) 단순하게 서버를 다운시켜보고 싶은 의도도 있겠지만, 보다 사악한 의도로 패킷을 통해 버퍼 오버플로를 일으켜 악성 코드를 실행시키거나 그와 유사한 공격을 시도하려는 것이다.</p>
</li>
<li data-line="24">
<p>(78%) 악성 데이터로부터 서버를 지키려면 퍼즈 테스팅(fuzz testing)이라는 자동화 테스트를 수행하는 것이 최선의 방책이다.</p>
</li>
<li data-line="26">
<p>(78%) 구조화되지 않은 대량의 데이터를 서버에 전송하는 것으로 네트워크 게임의 퍼즈 테스팅을 수행할 수 있다</p>
</li>
<li data-line="28">
<p>(78%) 좀 더 많은 버그를 찾으려면 무작위 데이터 외에 어느 정도 구조화된 데이터를 보내는 것도 도움이 된다</p>
</li>
<li data-line="30">
<p>(78%) 수신된 시그니처를 바이트 단위로 비교하거나 해시를 검사하는 코드는 잠재적으로 타이밍 공격(timing attack) 또는 소요 시간 분석 공격에 취약하다</p>
</li>
<li data-line="32">
<p>(78%) 이렇게 미리 리턴해 버리는 코드가 바로 시간 분석 공격의 목표가 된다</p>
</li>
<li data-line="34">
<p>(78%) 비교 작업에 있어선 비트 XOR 연산이 제격인데, 두 값이 일치하면 0이 되기 때문이다</p>
</li>
<li data-line="36">
<p>(78%) MMORPG와 같이 대규모 월드를 공유하는 게임에서 특히 그렇다. 침입자의 목적은 주로 유저 데이터를 훔치는 것으로, 신용 카드 번호나 암호 등이 타깃이다.</p>
</li>
<li data-line="38">
<p>(78%) 잠재적인 침입 가능성을 줄일 수 있는 방지책이 여럿 있는데, 그중 가장 최선은 서버의 모든 소프트웨어를 최신 보안 패치로 업데이트하는 것이다</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="10.4 서버 보안" class="heading" id="10.4_서버_보안"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.4 서버 보안</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="10.4.1 디도스 공격" class="heading" id="10.4.1_디도스_공격"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.4.1 디도스 공격</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="10.4.2 악성 데이터" class="heading" id="10.4.2_악성_데이터"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.4.2 악성 데이터</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="10.4.3 소요 시간 분석 공격" class="heading" id="10.4.3_소요_시간_분석_공격"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.4.3 소요 시간 분석 공격</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="10.4.4 침입" class="heading" id="10.4.4_침입"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.4.4 침입</h5><div class="heading-children"><div><ul>
<li data-line="0">
<p>(79%) 서버에서 구동되는 소프트웨어나 서비스의 숫자를 줄이면 잠재적인 침입 지점의 숫자 또한 줄어든다.</p>
</li>
<li data-line="2">
<p>(79%) 중앙 서버에 접근할 수 있는 개인 컴퓨터를 먼저 뚫어 교두보로 삼는 것이다. 그리고 이 컴퓨터를 통해 서버 시스템에 침투해 들어간다.</p>
</li>
<li data-line="4">
<p>(79%) 스피어 피싱 공격(spear phishing attack</p>
</li>
<li data-line="6">
<p>(79%) 서버에 저장하는 민감한 정보는 최대한 안전하게 보관해야 한다. 그러면 침입이 발생하더라도 게임 서비스와 플레이어가 입는 피해를 제한할 수 있다</p>
</li>
<li data-line="8">
<p>(79%) 사용자 암호는 블로우피시(Blowfish) 기반 bcrypt 등 적절한 암호 해시 알고리즘으로 해시해 두어야 하며, 단순 해시 알고리즘인 SHA-256, MD5, DES 등을 사용해서는 안 된다</p>
</li>
<li data-line="10">
<p>(79%) 조직에 불만을 가졌거나, 불순한 의도를 가진 직원이 제일 위험하다.</p>
</li>
<li data-line="12">
<p>(79%) 게임 상태에 관련된 데이터라면 보내는 양을 제한하는 것도 유용하다</p>
</li>
<li data-line="14">
<p>(79%) 패킷이 중간자 공격에 노출될 수 있으므로 암호나 결제 정보 등 민감한 정보는 반드시 암호화해야 한다</p>
</li>
<li data-line="16">
<p>(79%) 허용되지 않는 동작을 시도하는 유저를 막으려면 입력 검증도 중요하다.</p>
</li>
<li data-line="18">
<p>(79%) 이 솔루션은 게임이 실행되는 동안 능동적으로 메모리를 검사하여, 이미 파악된 치트 프로그램이 구동되고 있는지 확인한다</p>
</li>
<li data-line="20">
<p>(79%) 퍼즈 테스팅 기법</p>
</li>
</ul></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="10.5 요약" class="heading" id="10.5_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.5 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="11장 상용 엔진 사례" class="heading" id="11장_상용_엔진_사례"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11장 상용 엔진 사례</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="11.1 언리얼 엔진 4" class="heading" id="11.1_언리얼_엔진_4"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.1 언리얼 엔진 4</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="11.1.1 소켓과 기본 네트워킹" class="heading" id="11.1.1_소켓과_기본_네트워킹"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.1.1 소켓과 기본 네트워킹</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.1.2 게임 객체와 토폴로지" class="heading" id="11.1.2_게임_객체와_토폴로지"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.1.2 게임 객체와 토폴로지</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.1.3 액터 리플리케이션" class="heading" id="11.1.3_액터_리플리케이션"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.1.3 액터 리플리케이션</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.1.4 원격 프로시저 호출" class="heading" id="11.1.4_원격_프로시저_호출"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.1.4 원격 프로시저 호출</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="11.2 유니티" class="heading" id="11.2_유니티"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.2 유니티</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="11.2.1 전송 계층 API" class="heading" id="11.2.1_전송_계층_API"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.2.1 전송 계층 API</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.2.2 게임 객체와 토폴로지" class="heading" id="11.2.2_게임_객체와_토폴로지"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.2.2 게임 객체와 토폴로지</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.2.3 객체 스폰과 리플리케이션" class="heading" id="11.2.3_객체_스폰과_리플리케이션"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.2.3 객체 스폰과 리플리케이션</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.2.4 원격 프로시저 호출" class="heading" id="11.2.4_원격_프로시저_호출"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.2.4 원격 프로시저 호출</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="11.2.5 매치메이킹" class="heading" id="11.2.5_매치메이킹"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.2.5 매치메이킹</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="11.3 요약" class="heading" id="11.3_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11.3 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="12장 게임 서비스 플랫폼" class="heading" id="12장_게임_서비스_플랫폼"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12장 게임 서비스 플랫폼</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="12.1 게임 서비스 플랫폼 선택하기" class="heading" id="12.1_게임_서비스_플랫폼_선택하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.1 게임 서비스 플랫폼 선택하기</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.2 기본 셋업" class="heading" id="12.2_기본_셋업"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.2 기본 셋업</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="12.2.1 초기화, 구동, 마무리" class="heading" id="12.2.1_초기화,_구동,_마무리"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.2.1 초기화, 구동, 마무리</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="12.2.2 유저 ID 및 이름" class="heading" id="12.2.2_유저_ID_및_이름"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.2.2 유저 ID 및 이름</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="12.3 로비 및 매치메이킹" class="heading" id="12.3_로비_및_매치메이킹"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.3 로비 및 매치메이킹</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.4 네트워킹" class="heading" id="12.4_네트워킹"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.4 네트워킹</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.5 플레이어 통계" class="heading" id="12.5_플레이어_통계"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.5 플레이어 통계</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.6 플레이어 도전과제" class="heading" id="12.6_플레이어_도전과제"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.6 플레이어 도전과제</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.7 리더보드" class="heading" id="12.7_리더보드"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.7 리더보드</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.8 기타 서비스" class="heading" id="12.8_기타_서비스"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.8 기타 서비스</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="12.9 요약" class="heading" id="12.9_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12.9 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="13장 클라우드에 전용 서버 호스팅하기" class="heading" id="13장_클라우드에_전용_서버_호스팅하기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13장 클라우드에 전용 서버 호스팅하기</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="13.1 클라우드, 꼭 사용해야 할까" class="heading" id="13.1_클라우드,_꼭_사용해야_할까"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.1 클라우드, 꼭 사용해야 할까</h4><div class="heading-children"></div></div><div class="heading-wrapper"><h4 data-heading="13.2 필수 도구" class="heading" id="13.2_필수_도구"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.2 필수 도구</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="13.2.1 REST" class="heading" id="13.2.1_REST"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.2.1 REST</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="13.2.2 JSON" class="heading" id="13.2.2_JSON"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.2.2 JSON</h5><div class="heading-children"><div class="heading-wrapper"><h6 data-heading="13.2.3 Node.js" class="heading" id="13.2.3_Node.js"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.2.3 Node.js</h6><div class="heading-children"></div></div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="13.3 용어 및 개요" class="heading" id="13.3_용어_및_개요"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.3 용어 및 개요</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="13.3.1 서버 게임 인스턴스" class="heading" id="13.3.1_서버_게임_인스턴스"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.3.1 서버 게임 인스턴스</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="13.3.2 게임 서버 프로세스" class="heading" id="13.3.2_게임_서버_프로세스"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.3.2 게임 서버 프로세스</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="13.3.3 게임 서버 머신" class="heading" id="13.3.3_게임_서버_머신"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.3.3 게임 서버 머신</h5><div class="heading-children"></div></div><div class="heading-wrapper"><h5 data-heading="13.3.4 하드웨어" class="heading" id="13.3.4_하드웨어"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.3.4 하드웨어</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="13.4 로컬 서버 프로세스 관리자" class="heading" id="13.4_로컬_서버_프로세스_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.4 로컬 서버 프로세스 관리자</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="13.4.1 프로세스 모니터링" class="heading" id="13.4.1_프로세스_모니터링"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.4.1 프로세스 모니터링</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="13.5 가상 머신 관리자" class="heading" id="13.5_가상_머신_관리자"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.5 가상 머신 관리자</h4><div class="heading-children"><div class="heading-wrapper"><h5 data-heading="13.5.1 가상 머신 모니터링" class="heading" id="13.5.1_가상_머신_모니터링"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.5.1 가상 머신 모니터링</h5><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h4 data-heading="13.6 요약" class="heading" id="13.6_요약"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>13.6 요약</h4><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h3 data-heading="부록A 모던 C++ 기초" class="heading" id="부록A_모던_C++_기초"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>부록A 모던 C++ 기초</h3><div class="heading-children"></div></div></div></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">멀티플레이어 게임 프로그래밍</div></div><div class="canvas-node" style="z-index: 6; transform: translate(-2400px, 1460px); width: 450px; height: 200px; --canvas-node-width: 450px; --canvas-node-height: 200px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><div class="markdown-preview-sizer markdown-preview-section"><div><p>css 태그를 이요할 경우, 웹웹 페이지 미리 보기 가능</p></div><div><pre><code>&lt;center&gt;&lt;iframe width="800" height="500" src="https://lefthanddeveloper.tistory.com/20"&gt;&lt;/iframe&gt;&lt;/center&gt;
</code><button class="copy-code-button">복사</button></pre></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div></div><div class="canvas-node" style="z-index: 7; transform: translate(-3780px, -740px); width: 760px; height: 959px; --canvas-node-width: 760px; --canvas-node-height: 959px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><div class="markdown-preview-sizer markdown-preview-section"><div class="heading-wrapper"><h1 data-heading="필요 플로그인 : Link Embeded" class="heading" id="필요_플로그인_:_Link_Embeded">필요 플로그인 : Link Embeded</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="테스트1" class="heading" id="테스트1"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>테스트1</h2><div class="heading-children"><div><div style="
    border: 1px solid var(--background-modifier-border);
    overflow: hidden;
    border-radius: var(--radius-s);
    box-shadow: rgba(0, 0, 0, 0.06) 0px 1px 3px;
  ">
  <div class="w __if _lc _sm _od _alsd _alcd _lh14 _xm _xi _ts _dm">
    <div class="wf">
      <div class="wc">
        <div class="e" style="padding-bottom: 100%">
          <div class="em">
            <a href="https://ansohxxn.github.io/unitydocs/debug/" target="_blank" rel="noopener" data-do-not-bind-click="" class="c" style="
                background-image: url('data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLW1pY3Jvc29mdCIgd2lkdGg9IjgwcHgiICBoZWlnaHQ9IjgwcHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCkiPjxjaXJjbGUgY3g9IjgxLjczNDEzMzYxMTY0OTQxIiBjeT0iNzQuMzUwNDU3MTYwMzQ4ODIiIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0MC4wMDEgNDkuOTk5OSA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49IjBzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9Ijc0LjM1MDQ1NzE2MDM0ODgyIiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM0OC4zNTIgNTAuMDAwMSA1MC4wMDAxKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMDYyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iNjUuMzA3MzM3Mjk0NjAzNiIgY3k9Ijg2Ljk1NTE4MTMwMDQ1MTQ3IiBmaWxsPSIjZjhiMjZhIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTQuMjM2IDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMTI1cyI+PC9hbmltYXRlVHJhbnNmb3JtPgo8L2NpcmNsZT48Y2lyY2xlIGN4PSI1NS4yMjEwNDc2ODg4MDIwNyIgY3k9Ijg5LjY1Nzc5NDQ1NDk1MjQxIiBmaWxsPSIjYWJiZDgxIiByPSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzNTcuOTU4IDUwLjAwMDIgNTAuMDAwMikiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjE4NzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjQ0Ljc3ODk1MjMxMTE5NzkzIiBjeT0iODkuNjU3Nzk0NDU0OTUyNDEiIGZpbGw9IiM4NDliODciIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDM1OS43NiA1MC4wMDY0IDUwLjAwNjQpIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4yNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMzQuNjkyNjYyNzA1Mzk2NDE1IiBjeT0iODYuOTU1MTgxMzAwNDUxNDciIGZpbGw9IiNlMTViNjQiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDAuMTgzNTUyIDUwIDUwKSI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGNhbGNNb2RlPSJzcGxpbmUiIHZhbHVlcz0iMCA1MCA1MDszNjAgNTAgNTAiIHRpbWVzPSIwOzEiIGtleVNwbGluZXM9IjAuNSAwIDAuNSAxIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgZHVyPSIxLjVzIiBiZWdpbj0iLTAuMzEyNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KPC9jaXJjbGU+PGNpcmNsZSBjeD0iMjUuNjQ5NTQyODM5NjUxMTc2IiBjeT0iODEuNzM0MTMzNjExNjQ5NDEiIGZpbGw9IiNmNDdlNjAiIHI9IjUiIHRyYW5zZm9ybT0icm90YXRlKDEuODY0NTcgNTAgNTApIj4KICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9InNwbGluZSIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiIGJlZ2luPSItMC4zNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxjaXJjbGUgY3g9IjE4LjI2NTg2NjM4ODM1MDYiIGN5PSI3NC4zNTA0NTcxNjAzNDg4NCIgZmlsbD0iI2Y4YjI2YSIgcj0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoNS40NTEyNiA1MCA1MCkiPgogIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MzYwIDUwIDUwIiB0aW1lcz0iMDsxIiBrZXlTcGxpbmVzPSIwLjUgMCAwLjUgMSIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGR1cj0iMS41cyIgYmVnaW49Ii0wLjQzNzVzIj48L2FuaW1hdGVUcmFuc2Zvcm0+CjwvY2lyY2xlPjxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0icm90YXRlIiBjYWxjTW9kZT0ic3BsaW5lIiB2YWx1ZXM9IjAgNTAgNTA7MCA1MCA1MCIgdGltZXM9IjA7MSIga2V5U3BsaW5lcz0iMC41IDAgMC41IDEiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBkdXI9IjEuNXMiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PC9zdmc+');
              "></a>
          </div>
        </div>
      </div>
      <div class="wt">
        <div class="t _f0 _ffsa _fsn _fwn">
          <div class="th _f1p _fsn _fwb">
            <a href="https://ansohxxn.github.io/unitydocs/debug/" target="_blank" rel="noopener" class="thl">Fetching</a>
          </div>
          <div class="td">Fetching https://ansohxxn.github.io/unitydocs/debug/</div>
          <div class="tf _f1m">
            <div class="tc">
              <a href="https://ansohxxn.github.io/unitydocs/debug/" target="_blank" rel="noopener" class="tw _f1m"><span class="twt">https://ansohxxn.github.io/unitydocs/debug/</span><span class="twd">https://ansohxxn.github.io/unitydocs/debug/</span></a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div></div></div></div><div class="heading-wrapper"><h2 data-heading="테스트2" class="heading" id="테스트2"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>테스트2</h2><div class="heading-children"><div><div style="
    border: 1px solid var(--background-modifier-border);
    overflow: hidden;
    border-radius: var(--radius-s);
    box-shadow: rgba(0, 0, 0, 0.06) 0px 1px 3px;
  ">
  <div class="w __if _lc _sm _od _alsd _alcd _lh14 _xm _xi _ts _dm">
    <div class="wf">
      <div class="wc">
        <div class="e" style="padding-bottom: 100%">
          <div class="em">
            <a href="https://docs.unity3d.com/kr/2021.3/Manual/animeditor-AnimationCurves.html" target="_blank" rel="noopener" data-do-not-bind-click="" class="c" style="
                background-image: url('https://docs.unity3d.com/kr/2021.3/uploads/Main/AnimationEditorBouncingCube.gif');
              "></a>
          </div>
        </div>
      </div>
      <div class="wt">
        <div class="t _f0 _ffsa _fsn _fwn">
          <div class="th _f1p _fsn _fwb">
            <a href="https://docs.unity3d.com/kr/2021.3/Manual/animeditor-AnimationCurves.html" target="_blank" rel="noopener" class="thl">애니메이션 커브 사용 - Unity 매뉴얼</a>
          </div>
          <div class="td">Animation Clip 에서 모든 애니메이션화 프로퍼티에는 Animation Curve 가 있어서 Animation Clip에서 그 프로퍼티의 시간에 따른 변화를 조절할 수 있습니다. Animation View 의 프로퍼티 리스트 영역(왼쪽)에는 현재 애니메이션화 프로퍼티가 모두 표시되어 있습니다. 애니메이션 뷰의 도프시트 모드에서 각 프로퍼티의 애니메이션화 값은 선형 트랙으로 보이나, 커브 모드에선 프로퍼티의 변화값을 그래프의 선으로 시각화해서 볼 수 있습니다. 어떤 모드를 사용하든지 커브는 있으며, 도프시트는 키프레임이 발생할 때의 데이터를 단순화해서 보여줄 뿐입니다.</div>
          <div class="tf _f1m">
            <div class="tc">
              <a href="https://docs.unity3d.com/kr/2021.3/Manual/animeditor-AnimationCurves.html" target="_blank" rel="noopener" class="tw _f1m"><span class="twt">https://docs.unity3d.com/kr/2021.3/Manual/animeditor-AnimationCurves.html</span><span class="twd">https://docs.unity3d.com/kr/2021.3/Manual/animeditor-AnimationCurves.html</span></a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div></div></div></div><div class="heading-wrapper"><h2 data-heading="테스트3" class="heading" id="테스트3"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>테스트3</h2><div class="heading-children"><div><div style="
    border: 1px solid var(--background-modifier-border);
    overflow: hidden;
    border-radius: var(--radius-s);
    box-shadow: rgba(0, 0, 0, 0.06) 0px 1px 3px;
  ">
  <div class="w __if _lc _sm _od _alsd _alcd _lh14 _xm _xi _ts _dm">
    <div class="wf">
      <div class="wc">
        <div class="e" style="padding-bottom: 100%">
          <div class="em">
            <a href="https://lefthanddeveloper.tistory.com/20" target="_blank" rel="noopener" data-do-not-bind-click="" class="c" style="
                background-image: url('https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7a7AY%2Fbtrn1qJOiqf%2FJ0dAV2cZC8JD5eBDBSwaAK%2Fimg.png');
              "></a>
          </div>
        </div>
      </div>
      <div class="wt">
        <div class="t _f0 _ffsa _fsn _fwn">
          <div class="th _f1p _fsn _fwb">
            <a href="https://lefthanddeveloper.tistory.com/20" target="_blank" rel="noopener" class="thl">[유니티] 왜 이제 알았을까 요놈 Animation Curve</a>
          </div>
          <div class="td">최근 개발 중 쪼~~끔 수학 머리를 사용해서 수학 공식을 생각해서 특정 기능을 개발해야하는 순간이 있었는데 수학에 너무 약하기 때문에 고심하고 있을 때 지인 개발자께서 Animation Curve를 사용해보라는 제안을 하셨습니다. Animatin Curve는 존재 자체만 알고있었지 실제로 써본 적이 없었는데 이번에 써보면 너허어어어어무나 유용한 친구인 것을 깨닫게 되었습니다. 보통 수학 공식으로 결과값을 도출 해 내야 하는 경우에 Animation Curve를 쓰면 너무 유용할 것 같습니다. 아래 코드는 AnimationCurve를 사용해서 sphere의 움직임을 wave 처럼 움직이게 한 아주 심플한 예제 코드입니다. using UnityEngine; namespace AnimationCurvePrac…</div>
          <div class="tf _f1m">
            <div class="tc">
              <a href="https://lefthanddeveloper.tistory.com/20" target="_blank" rel="noopener" class="tw _f1m"><span class="twt">https://lefthanddeveloper.tistory.com/20</span><span class="twd">https://lefthanddeveloper.tistory.com/20</span></a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div></div></div></div></div></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div></div><div class="canvas-node" style="z-index: 8; transform: translate(-1799px, 1344px); width: 659px; height: 633px; --canvas-node-width: 659px; --canvas-node-height: 633px;"><div class="canvas-node-container"><div class="canvas-node-content media-embed image-embed is-loaded"><img src="lib/media/pasted-image-20240323231237.png" draggable="false"></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">Pasted image 20240323231237.png</div></div><div class="canvas-node" style="z-index: 9; transform: translate(-3920px, -2000px); width: 2450px; height: 841px; --canvas-node-width: 2450px; --canvas-node-height: 841px;"><div class="canvas-node-container"><div class="canvas-node-content media-embed image-embed is-loaded"><img src="lib/media/pasted-image-20240323230925.png" draggable="false"></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">Pasted image 20240323230925.png</div></div><div class="canvas-node" style="z-index: 10; transform: translate(820px, -660px); width: 920px; height: 640px; --canvas-node-width: 920px; --canvas-node-height: 640px;"><div class="canvas-node-container"><div class="canvas-node-content node-insert-event"></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">https://docs.unity3d.com/kr/2021.3/Manual/animeditor-AnimationCurves.html</div></div><div class="canvas-node" style="z-index: 11; transform: translate(820px, -780px); width: 250px; height: 60px; --canvas-node-width: 250px; --canvas-node-height: 60px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><div class="markdown-preview-sizer markdown-preview-section"><div><p>웹 페이지 추가</p></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div></div><div class="canvas-node" style="z-index: 12; transform: translate(-420px, -660px); width: 863px; height: 1456px; --canvas-node-width: 863px; --canvas-node-height: 1456px;"><div class="canvas-node-container"><div class="canvas-node-content media-embed image-embed is-loaded"><img src="lib/media/pasted-image-20240323230251.png" draggable="false"></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">Pasted image 20240323230251.png</div></div><div class="canvas-node" style="z-index: 13; transform: translate(820px, 220px); width: 320px; height: 60px; --canvas-node-width: 320px; --canvas-node-height: 60px;"><div class="canvas-node-container"><div class="canvas-node-content markdown-embed"><div class="markdown-embed-content node-insert-event"><div class="markdown-preview-view markdown-rendered"><div class="markdown-preview-sizer markdown-preview-section"><div><p>웹 페이지 추가 - 동영상 URL 첨부</p></div></div></div></div><div class="markdown-embed-content node-insert-event" style="display: none;"></div></div><div class="canvas-node-content-blocker"></div></div></div><div class="canvas-node" style="z-index: 14; transform: translate(820px, 344px); width: 920px; height: 552px; --canvas-node-width: 920px; --canvas-node-height: 552px;"><div class="canvas-node-container"><div class="canvas-node-content node-insert-event"></div><div class="canvas-node-content-blocker"></div></div><div class="canvas-node-label">https://www.youtube.com/watch?v=WEkdq34oCAU</div></div><div class="canvas-path-label-wrapper" style="transform: translate(1280px, 557.5px);"><div class="canvas-path-label" contenteditable="false" data-placeholder="텍스트 추가...">커브테스트</div></div><div class="canvas-path-label-wrapper" style="transform: translate(-1496.75px, -560px);"><div class="canvas-path-label" contenteditable="false" data-placeholder="텍스트 추가...">## 이미지 첨부 테스트
- 보관소의 미디어 추가 메뉴 이용</div></div><div class="canvas-path-label-wrapper" style="transform: translate(-1080.25px, 124.75px);"><div class="canvas-path-label" contenteditable="false" data-placeholder="텍스트 추가...">다른 문서 첨부</div></div><div class="canvas-path-label-wrapper" style="transform: translate(-2519.75px, -430.5px);"><div class="canvas-path-label" contenteditable="false" data-placeholder="텍스트 추가...">카드 생성 후, 웹 주소 임베디드</div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="githubio\html_uploadtest.html#Github_업로드_테스트"><div class="tree-item-contents heading-link" heading-name="Github 업로드 테스트"><span class="tree-item-title">Github 업로드 테스트</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#필요한_파일"><div class="tree-item-contents heading-link" heading-name="필요한 파일"><span class="tree-item-title">필요한 파일</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#업로드시"><div class="tree-item-contents heading-link" heading-name="업로드시"><span class="tree-item-title">업로드시</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#BookInfo"><div class="tree-item-contents heading-link" heading-name="BookInfo"><span class="tree-item-title">BookInfo</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#독후감"><div class="tree-item-contents heading-link" heading-name="독후감"><span class="tree-item-title">독후감</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#하이라이트"><div class="tree-item-contents heading-link" heading-name="하이라이트"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">하이라이트</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#1장_네트워크_게임의_개요"><div class="tree-item-contents heading-link" heading-name="1장 네트워크 게임의 개요"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1장 네트워크 게임의 개요</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#1.1_멀티플레이어_게임의_간추린_역사"><div class="tree-item-contents heading-link" heading-name="1.1 멀티플레이어 게임의 간추린 역사"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 멀티플레이어 게임의 간추린 역사</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.1_로컬_멀티플레이어_게임"><div class="tree-item-contents heading-link" heading-name="1.1.1 로컬 멀티플레이어 게임"><span class="tree-item-title">1.1.1 로컬 멀티플레이어 게임</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.2_초기_네트워크_멀티플레이어_게임"><div class="tree-item-contents heading-link" heading-name="1.1.2 초기 네트워크 멀티플레이어 게임"><span class="tree-item-title">1.1.2 초기 네트워크 멀티플레이어 게임</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.3_MUD:_멀티_유저_던전"><div class="tree-item-contents heading-link" heading-name="1.1.3 MUD: 멀티 유저 던전"><span class="tree-item-title">1.1.3 MUD: 멀티 유저 던전</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.4_랜_게임"><div class="tree-item-contents heading-link" heading-name="1.1.4 랜 게임"><span class="tree-item-title">1.1.4 랜 게임</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.5_온라인_게임"><div class="tree-item-contents heading-link" heading-name="1.1.5 온라인 게임"><span class="tree-item-title">1.1.5 온라인 게임</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.6_MMO_게임"><div class="tree-item-contents heading-link" heading-name="1.1.6 MMO 게임"><span class="tree-item-title">1.1.6 MMO 게임</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.1.7_모바일_네트워크_게임"><div class="tree-item-contents heading-link" heading-name="1.1.7 모바일 네트워크 게임"><span class="tree-item-title">1.1.7 모바일 네트워크 게임</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#1.2_스타시즈:_트라이브스"><div class="tree-item-contents heading-link" heading-name="1.2 스타시즈: 트라이브스"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.2 스타시즈: 트라이브스</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.1_플랫폼_패킷_모듈"><div class="tree-item-contents heading-link" heading-name="1.2.1 플랫폼 패킷 모듈"><span class="tree-item-title">1.2.1 플랫폼 패킷 모듈</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.2_연결_관리자"><div class="tree-item-contents heading-link" heading-name="1.2.2 연결 관리자"><span class="tree-item-title">1.2.2 연결 관리자</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.3_스트림_관리자"><div class="tree-item-contents heading-link" heading-name="1.2.3 스트림 관리자"><span class="tree-item-title">1.2.3 스트림 관리자</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.4_이벤트_관리자"><div class="tree-item-contents heading-link" heading-name="1.2.4 이벤트 관리자"><span class="tree-item-title">1.2.4 이벤트 관리자</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.5_고스트_관리자"><div class="tree-item-contents heading-link" heading-name="1.2.5 고스트 관리자"><span class="tree-item-title">1.2.5 고스트 관리자</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.6_이동_관리자"><div class="tree-item-contents heading-link" heading-name="1.2.6 이동 관리자"><span class="tree-item-title">1.2.6 이동 관리자</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.2.7_기타_시스템"><div class="tree-item-contents heading-link" heading-name="1.2.7 기타 시스템"><span class="tree-item-title">1.2.7 기타 시스템</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#1.3_에이지_오브_엠파이어"><div class="tree-item-contents heading-link" heading-name="1.3 에이지 오브 엠파이어"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.3 에이지 오브 엠파이어</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.3.1_턴_타이머"><div class="tree-item-contents heading-link" heading-name="1.3.1 턴 타이머"><span class="tree-item-title">1.3.1 턴 타이머</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#1.3.2_동기화"><div class="tree-item-contents heading-link" heading-name="1.3.2 동기화"><span class="tree-item-title">1.3.2 동기화</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#1.4_요약"><div class="tree-item-contents heading-link" heading-name="1.4 요약"><span class="tree-item-title">1.4 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#2장_인터넷"><div class="tree-item-contents heading-link" heading-name="2장 인터넷"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2장 인터넷</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.1_패킷_스위칭의_기원"><div class="tree-item-contents heading-link" heading-name="2.1 패킷 스위칭의 기원"><span class="tree-item-title">2.1 패킷 스위칭의 기원</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.2_TCP/IP_스택의_계층_구조"><div class="tree-item-contents heading-link" heading-name="2.2 TCP/IP 스택의 계층 구조"><span class="tree-item-title">2.2 TCP/IP 스택의 계층 구조</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.3_물리_계층"><div class="tree-item-contents heading-link" heading-name="2.3 물리 계층"><span class="tree-item-title">2.3 물리 계층</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.4_링크_계층"><div class="tree-item-contents heading-link" heading-name="2.4 링크 계층"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.4 링크 계층</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="6"><a class="tree-link" href="githubio\html_uploadtest.html#2.4.1_이더넷/802.3"><div class="tree-item-contents heading-link" heading-name="2.4.1 이더넷/802.3"><span class="tree-item-title">2.4.1 이더넷/802.3</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.5_네트워크_계층"><div class="tree-item-contents heading-link" heading-name="2.5 네트워크 계층"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.5 네트워크 계층</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.5.1_IPv4"><div class="tree-item-contents heading-link" heading-name="2.5.1 IPv4"><span class="tree-item-title">2.5.1 IPv4</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.5.2_IPv6"><div class="tree-item-contents heading-link" heading-name="2.5.2 IPv6"><span class="tree-item-title">2.5.2 IPv6</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.6_전송_계층"><div class="tree-item-contents heading-link" heading-name="2.6 전송 계층"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.6 전송 계층</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.6.1_UDP"><div class="tree-item-contents heading-link" heading-name="2.6.1 UDP"><span class="tree-item-title">2.6.1 UDP</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.6.2_TCP"><div class="tree-item-contents heading-link" heading-name="2.6.2 TCP"><span class="tree-item-title">2.6.2 TCP</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.7_응용_계층"><div class="tree-item-contents heading-link" heading-name="2.7 응용 계층"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.7 응용 계층</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.7.1_DHCP"><div class="tree-item-contents heading-link" heading-name="2.7.1 DHCP"><span class="tree-item-title">2.7.1 DHCP</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.7.2_DNS"><div class="tree-item-contents heading-link" heading-name="2.7.2 DNS"><span class="tree-item-title">2.7.2 DNS</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.8_NAT"><div class="tree-item-contents heading-link" heading-name="2.8 NAT"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.8 NAT</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#2.8.1_NAT_투과"><div class="tree-item-contents heading-link" heading-name="2.8.1 NAT 투과"><span class="tree-item-title">2.8.1 NAT 투과</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#2.9_요약"><div class="tree-item-contents heading-link" heading-name="2.9 요약"><span class="tree-item-title">2.9 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#3장_버클리_소켓"><div class="tree-item-contents heading-link" heading-name="3장 버클리 소켓"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3장 버클리 소켓</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.1_소켓_만들기"><div class="tree-item-contents heading-link" heading-name="3.1 소켓 만들기"><span class="tree-item-title">3.1 소켓 만들기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.2_운영체제별_API_차이"><div class="tree-item-contents heading-link" heading-name="3.2 운영체제별 API 차이"><span class="tree-item-title">3.2 운영체제별 API 차이</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.3_소켓_주소"><div class="tree-item-contents heading-link" heading-name="3.3 소켓 주소"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.3 소켓 주소</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.3.1_자료형_안전성"><div class="tree-item-contents heading-link" heading-name="3.3.1 자료형 안전성"><span class="tree-item-title">3.3.1 자료형 안전성</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.3.2_문자열로_sockaddr_초기화하기"><div class="tree-item-contents heading-link" heading-name="3.3.2 문자열로 sockaddr 초기화하기"><span class="tree-item-title">3.3.2 문자열로 sockaddr 초기화하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.3.3_소켓_바인딩하기"><div class="tree-item-contents heading-link" heading-name="3.3.3 소켓 바인딩하기"><span class="tree-item-title">3.3.3 소켓 바인딩하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.4_UDP_소켓"><div class="tree-item-contents heading-link" heading-name="3.4 UDP 소켓"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.4 UDP 소켓</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.4.1_자료형_안전성을_보강한_UDP_소켓"><div class="tree-item-contents heading-link" heading-name="3.4.1 자료형 안전성을 보강한 UDP 소켓"><span class="tree-item-title">3.4.1 자료형 안전성을 보강한 UDP 소켓</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.5_TCP_소켓"><div class="tree-item-contents heading-link" heading-name="3.5 TCP 소켓"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.5 TCP 소켓</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.5.1_연결된_소켓으로_데이터_보내고_받기"><div class="tree-item-contents heading-link" heading-name="3.5.1 연결된 소켓으로 데이터 보내고 받기"><span class="tree-item-title">3.5.1 연결된 소켓으로 데이터 보내고 받기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.5.2_자료형_안전성을_보강한_TCP_소켓"><div class="tree-item-contents heading-link" heading-name="3.5.2 자료형 안전성을 보강한 TCP 소켓"><span class="tree-item-title">3.5.2 자료형 안전성을 보강한 TCP 소켓</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.6_블로킹_I/O와_논블로킹_I/O"><div class="tree-item-contents heading-link" heading-name="3.6 블로킹 I/O와 논블로킹 I/O"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.6 블로킹 I/O와 논블로킹 I/O</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.6.1_멀티스레딩"><div class="tree-item-contents heading-link" heading-name="3.6.1 멀티스레딩"><span class="tree-item-title">3.6.1 멀티스레딩</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.6.2_논블로킹_I/O"><div class="tree-item-contents heading-link" heading-name="3.6.2 논블로킹 I/O"><span class="tree-item-title">3.6.2 논블로킹 I/O</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#3.6.3_select()_함수"><div class="tree-item-contents heading-link" heading-name="3.6.3 select() 함수"><span class="tree-item-title">3.6.3 select() 함수</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.7_소켓_부가_옵션"><div class="tree-item-contents heading-link" heading-name="3.7 소켓 부가 옵션"><span class="tree-item-title">3.7 소켓 부가 옵션</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#3.8_요약"><div class="tree-item-contents heading-link" heading-name="3.8 요약"><span class="tree-item-title">3.8 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#4장_객체_직렬화"><div class="tree-item-contents heading-link" heading-name="4장 객체 직렬화"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4장 객체 직렬화</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#4.1_직렬화가_필요한_이유"><div class="tree-item-contents heading-link" heading-name="4.1 직렬화가 필요한 이유"><span class="tree-item-title">4.1 직렬화가 필요한 이유</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#4.2_스트림"><div class="tree-item-contents heading-link" heading-name="4.2 스트림"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2 스트림</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.2.1_메모리_스트림"><div class="tree-item-contents heading-link" heading-name="4.2.1 메모리 스트림"><span class="tree-item-title">4.2.1 메모리 스트림</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.2.2_엔디언_호환성"><div class="tree-item-contents heading-link" heading-name="4.2.2 엔디언 호환성"><span class="tree-item-title">4.2.2 엔디언 호환성</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.2.3_비트_스트림"><div class="tree-item-contents heading-link" heading-name="4.2.3 비트 스트림"><span class="tree-item-title">4.2.3 비트 스트림</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#4.3_참조된_데이터_처리"><div class="tree-item-contents heading-link" heading-name="4.3 참조된 데이터 처리"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.3 참조된 데이터 처리</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.3.1_임베딩(또는_인라이닝)"><div class="tree-item-contents heading-link" heading-name="4.3.1 임베딩(또는 인라이닝)"><span class="tree-item-title">4.3.1 임베딩(또는 인라이닝)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.3.2_링킹"><div class="tree-item-contents heading-link" heading-name="4.3.2 링킹"><span class="tree-item-title">4.3.2 링킹</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#4.4_압축"><div class="tree-item-contents heading-link" heading-name="4.4 압축"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.4 압축</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.4.1_희소_배열(sparse_array)_압축"><div class="tree-item-contents heading-link" heading-name="4.4.1 희소 배열(sparse array) 압축"><span class="tree-item-title">4.4.1 희소 배열(sparse array) 압축</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.4.2_엔트로피_인코딩"><div class="tree-item-contents heading-link" heading-name="4.4.2 엔트로피 인코딩"><span class="tree-item-title">4.4.2 엔트로피 인코딩</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.4.3_고정소수점"><div class="tree-item-contents heading-link" heading-name="4.4.3 고정소수점"><span class="tree-item-title">4.4.3 고정소수점</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.4.4_기하_압축"><div class="tree-item-contents heading-link" heading-name="4.4.4 기하 압축"><span class="tree-item-title">4.4.4 기하 압축</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#4.5_유지보수성"><div class="tree-item-contents heading-link" heading-name="4.5 유지보수성"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.5 유지보수성</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.5.1_직렬화_읽기와_쓰기를_하나로_합치기"><div class="tree-item-contents heading-link" heading-name="4.5.1 직렬화 읽기와 쓰기를 하나로 합치기"><span class="tree-item-title">4.5.1 직렬화 읽기와 쓰기를 하나로 합치기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#4.5.2_데이터_주도_직렬화"><div class="tree-item-contents heading-link" heading-name="4.5.2 데이터 주도 직렬화"><span class="tree-item-title">4.5.2 데이터 주도 직렬화</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#4.6_요약"><div class="tree-item-contents heading-link" heading-name="4.6 요약"><span class="tree-item-title">4.6 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#5장_객체_리플리케이션"><div class="tree-item-contents heading-link" heading-name="5장 객체 리플리케이션"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5장 객체 리플리케이션</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.1_월드_상태"><div class="tree-item-contents heading-link" heading-name="5.1 월드 상태"><span class="tree-item-title">5.1 월드 상태</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.2_객체를_리플리케이션하기"><div class="tree-item-contents heading-link" heading-name="5.2 객체를 리플리케이션하기"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.2 객체를 리플리케이션하기</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#5.2.1_객체_생성_레지스트리"><div class="tree-item-contents heading-link" heading-name="5.2.1 객체 생성 레지스트리"><span class="tree-item-title">5.2.1 객체 생성 레지스트리</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#5.2.2_한_패킷에_여러_객체_실어_보내기"><div class="tree-item-contents heading-link" heading-name="5.2.2 한 패킷에 여러 객체 실어 보내기"><span class="tree-item-title">5.2.2 한 패킷에 여러 객체 실어 보내기</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.3_초간단_월드_상태_리플리케이션"><div class="tree-item-contents heading-link" heading-name="5.3 초간단 월드 상태 리플리케이션"><span class="tree-item-title">5.3 초간단 월드 상태 리플리케이션</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.4_월드_상태의_변경"><div class="tree-item-contents heading-link" heading-name="5.4 월드 상태의 변경"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.4 월드 상태의 변경</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#5.4.1_객체_상태_부분_리플리케이션"><div class="tree-item-contents heading-link" heading-name="5.4.1 객체 상태 부분 리플리케이션"><span class="tree-item-title">5.4.1 객체 상태 부분 리플리케이션</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.5_직렬화_객체로_RPC_수행"><div class="tree-item-contents heading-link" heading-name="5.5 직렬화 객체로 RPC 수행"><span class="tree-item-title">5.5 직렬화 객체로 RPC 수행</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.6_리플리케이션_시스템_개조하기"><div class="tree-item-contents heading-link" heading-name="5.6 리플리케이션 시스템 개조하기"><span class="tree-item-title">5.6 리플리케이션 시스템 개조하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#5.7_요약"><div class="tree-item-contents heading-link" heading-name="5.7 요약"><span class="tree-item-title">5.7 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#6장_네트워크_토폴로지와_예제_게임"><div class="tree-item-contents heading-link" heading-name="6장 네트워크 토폴로지와 예제 게임"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6장 네트워크 토폴로지와 예제 게임</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.1.1_클라이언트-서버"><div class="tree-item-contents heading-link" heading-name="6.1.1 클라이언트-서버"><span class="tree-item-title">6.1.1 클라이언트-서버</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.1.2_피어-투-피어"><div class="tree-item-contents heading-link" heading-name="6.1.2 피어-투-피어"><span class="tree-item-title">6.1.2 피어-투-피어</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#6.2_클라이언트-서버_구현하기"><div class="tree-item-contents heading-link" heading-name="6.2 클라이언트-서버 구현하기"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2 클라이언트-서버 구현하기</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.2.1_서버_코드와_클라이언트_코드_분리하기"><div class="tree-item-contents heading-link" heading-name="6.2.1 서버 코드와 클라이언트 코드 분리하기"><span class="tree-item-title">6.2.1 서버 코드와 클라이언트 코드 분리하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.2.2_네트워크_관리자_및_신규_클라이언트_마중하기"><div class="tree-item-contents heading-link" heading-name="6.2.2 네트워크 관리자 및 신규 클라이언트 마중하기"><span class="tree-item-title">6.2.2 네트워크 관리자 및 신규 클라이언트 마중하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.2.3_입력_공유_및_클라이언트_프록시"><div class="tree-item-contents heading-link" heading-name="6.2.3 입력 공유 및 클라이언트 프록시"><span class="tree-item-title">6.2.3 입력 공유 및 클라이언트 프록시</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#6.3_피어-투-피어_구현하기"><div class="tree-item-contents heading-link" heading-name="6.3 피어-투-피어 구현하기"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.3 피어-투-피어 구현하기</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.3.1_신규_피어_마중하기_및_게임_시작하기"><div class="tree-item-contents heading-link" heading-name="6.3.1 신규 피어 마중하기 및 게임 시작하기"><span class="tree-item-title">6.3.1 신규 피어 마중하기 및 게임 시작하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.3.2_명령_공유와_락스텝_턴"><div class="tree-item-contents heading-link" heading-name="6.3.2 명령 공유와 락스텝 턴"><span class="tree-item-title">6.3.2 명령 공유와 락스텝 턴</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#6.3.3_동기화_유지하기"><div class="tree-item-contents heading-link" heading-name="6.3.3 동기화 유지하기"><span class="tree-item-title">6.3.3 동기화 유지하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#6.4_요약"><div class="tree-item-contents heading-link" heading-name="6.4 요약"><span class="tree-item-title">6.4 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#7장_레이턴시,_지터링,_신뢰성"><div class="tree-item-contents heading-link" heading-name="7장 레이턴시, 지터링, 신뢰성"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7장 레이턴시, 지터링, 신뢰성</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.1_레이턴시"><div class="tree-item-contents heading-link" heading-name="7.1 레이턴시"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.1 레이턴시</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#7.1.1_네트워크가_원인이_아닌_레이턴시"><div class="tree-item-contents heading-link" heading-name="7.1.1 네트워크가 원인이 아닌 레이턴시"><span class="tree-item-title">7.1.1 네트워크가 원인이 아닌 레이턴시</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#7.1.2_네트워크_레이턴시"><div class="tree-item-contents heading-link" heading-name="7.1.2 네트워크 레이턴시"><span class="tree-item-title">7.1.2 네트워크 레이턴시</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.2_지터링"><div class="tree-item-contents heading-link" heading-name="7.2 지터링"><span class="tree-item-title">7.2 지터링</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.3_패킷_손실"><div class="tree-item-contents heading-link" heading-name="7.3 패킷 손실"><span class="tree-item-title">7.3 패킷 손실</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.4_신뢰성:_TCP냐_UDP냐"><div class="tree-item-contents heading-link" heading-name="7.4 신뢰성: TCP냐 UDP냐"><span class="tree-item-title">7.4 신뢰성: TCP냐 UDP냐</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.5_패킷_배달_통지"><div class="tree-item-contents heading-link" heading-name="7.5 패킷 배달 통지"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.5 패킷 배달 통지</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#7.5.1_외부로_나가는_패킷에_꼬리표_달기"><div class="tree-item-contents heading-link" heading-name="7.5.1 외부로 나가는 패킷에 꼬리표 달기"><span class="tree-item-title">7.5.1 외부로 나가는 패킷에 꼬리표 달기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#7.5.2_패킷을_받고_확인응답하기"><div class="tree-item-contents heading-link" heading-name="7.5.2 패킷을 받고 확인응답하기"><span class="tree-item-title">7.5.2 패킷을 받고 확인응답하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#7.5.3_확인응답_처리_및_배달_여부_알리기"><div class="tree-item-contents heading-link" heading-name="7.5.3 확인응답 처리 및 배달 여부 알리기"><span class="tree-item-title">7.5.3 확인응답 처리 및 배달 여부 알리기</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.6_객체_리플리케이션_신뢰성"><div class="tree-item-contents heading-link" heading-name="7.6 객체 리플리케이션 신뢰성"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.6 객체 리플리케이션 신뢰성</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#7.6.1_이미_전송_중인_최신_상태의_재전송을_막아_최적화하기"><div class="tree-item-contents heading-link" heading-name="7.6.1 이미 전송 중인 최신 상태의 재전송을 막아 최적화하기"><span class="tree-item-title">7.6.1 이미 전송 중인 최신 상태의 재전송을 막아 최적화하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.7_실제와_유사한_환경을_꾸며_테스트하기"><div class="tree-item-contents heading-link" heading-name="7.7 실제와 유사한 환경을 꾸며 테스트하기"><span class="tree-item-title">7.7 실제와 유사한 환경을 꾸며 테스트하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#7.8_요약"><div class="tree-item-contents heading-link" heading-name="7.8 요약"><span class="tree-item-title">7.8 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#8장_레이턴시_대응_강화"><div class="tree-item-contents heading-link" heading-name="8장 레이턴시 대응 강화"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8장 레이턴시 대응 강화</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#8.1_더미_터미널_클라이언트"><div class="tree-item-contents heading-link" heading-name="8.1 더미 터미널 클라이언트"><span class="tree-item-title">8.1 더미 터미널 클라이언트</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#8.2_클라이언트_측_보간"><div class="tree-item-contents heading-link" heading-name="8.2 클라이언트 측 보간"><span class="tree-item-title">8.2 클라이언트 측 보간</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#8.3_클라이언트_측_예측"><div class="tree-item-contents heading-link" heading-name="8.3 클라이언트 측 예측"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.3 클라이언트 측 예측</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#8.3.1_데드_레커닝"><div class="tree-item-contents heading-link" heading-name="8.3.1 데드 레커닝"><span class="tree-item-title">8.3.1 데드 레커닝</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#8.3.2_클라이언트_이동_예측_및_이동_조작_되새김"><div class="tree-item-contents heading-link" heading-name="8.3.2 클라이언트 이동 예측 및 이동 조작 되새김"><span class="tree-item-title">8.3.2 클라이언트 이동 예측 및 이동 조작 되새김</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#8.3.3_레이턴시를_교묘하게_감추기"><div class="tree-item-contents heading-link" heading-name="8.3.3 레이턴시를 교묘하게 감추기"><span class="tree-item-title">8.3.3 레이턴시를 교묘하게 감추기</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#8.4_서버_측_되감기"><div class="tree-item-contents heading-link" heading-name="8.4 서버 측 되감기"><span class="tree-item-title">8.4 서버 측 되감기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#8.5_요약"><div class="tree-item-contents heading-link" heading-name="8.5 요약"><span class="tree-item-title">8.5 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#9장_규모_확장에_대응하기"><div class="tree-item-contents heading-link" heading-name="9장 규모 확장에 대응하기"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9장 규모 확장에 대응하기</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#9.1_객체_스코프_내지_연관성"><div class="tree-item-contents heading-link" heading-name="9.1 객체 스코프 내지 연관성"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.1 객체 스코프 내지 연관성</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#9.1.1_스태틱_존"><div class="tree-item-contents heading-link" heading-name="9.1.1 스태틱 존"><span class="tree-item-title">9.1.1 스태틱 존</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#9.1.2_시야_절두체_사용"><div class="tree-item-contents heading-link" heading-name="9.1.2 시야 절두체 사용"><span class="tree-item-title">9.1.2 시야 절두체 사용</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#9.1.3_기타_가시성_기법"><div class="tree-item-contents heading-link" heading-name="9.1.3 기타 가시성 기법"><span class="tree-item-title">9.1.3 기타 가시성 기법</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#9.1.4_보이지_않아도_스코프에_포함되어야_하는_경우"><div class="tree-item-contents heading-link" heading-name="9.1.4 보이지 않아도 스코프에 포함되어야 하는 경우"><span class="tree-item-title">9.1.4 보이지 않아도 스코프에 포함되어야 하는 경우</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#9.2_서버_파티셔닝"><div class="tree-item-contents heading-link" heading-name="9.2 서버 파티셔닝"><span class="tree-item-title">9.2 서버 파티셔닝</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#9.3_인스턴싱"><div class="tree-item-contents heading-link" heading-name="9.3 인스턴싱"><span class="tree-item-title">9.3 인스턴싱</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#9.4_우선순위와_빈도"><div class="tree-item-contents heading-link" heading-name="9.4 우선순위와 빈도"><span class="tree-item-title">9.4 우선순위와 빈도</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#9.5_요약"><div class="tree-item-contents heading-link" heading-name="9.5 요약"><span class="tree-item-title">9.5 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#10장_보안"><div class="tree-item-contents heading-link" heading-name="10장 보안"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10장 보안</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#10.1_패킷_스니핑"><div class="tree-item-contents heading-link" heading-name="10.1 패킷 스니핑"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.1 패킷 스니핑</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.1.1_중간자_공격"><div class="tree-item-contents heading-link" heading-name="10.1.1 중간자 공격"><span class="tree-item-title">10.1.1 중간자 공격</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.1.2_호스트_머신상_패킷_스니핑"><div class="tree-item-contents heading-link" heading-name="10.1.2 호스트 머신상 패킷 스니핑"><span class="tree-item-title">10.1.2 호스트 머신상 패킷 스니핑</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#10.2_입력_검증"><div class="tree-item-contents heading-link" heading-name="10.2 입력 검증"><span class="tree-item-title">10.2 입력 검증</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#10.3_소프트웨어_치트_감지"><div class="tree-item-contents heading-link" heading-name="10.3 소프트웨어 치트 감지"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.3 소프트웨어 치트 감지</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.3.1_VAC"><div class="tree-item-contents heading-link" heading-name="10.3.1 VAC"><span class="tree-item-title">10.3.1 VAC</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.3.2_워든"><div class="tree-item-contents heading-link" heading-name="10.3.2 워든"><span class="tree-item-title">10.3.2 워든</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#10.4_서버_보안"><div class="tree-item-contents heading-link" heading-name="10.4 서버 보안"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.4 서버 보안</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.4.1_디도스_공격"><div class="tree-item-contents heading-link" heading-name="10.4.1 디도스 공격"><span class="tree-item-title">10.4.1 디도스 공격</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.4.2_악성_데이터"><div class="tree-item-contents heading-link" heading-name="10.4.2 악성 데이터"><span class="tree-item-title">10.4.2 악성 데이터</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.4.3_소요_시간_분석_공격"><div class="tree-item-contents heading-link" heading-name="10.4.3 소요 시간 분석 공격"><span class="tree-item-title">10.4.3 소요 시간 분석 공격</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#10.4.4_침입"><div class="tree-item-contents heading-link" heading-name="10.4.4 침입"><span class="tree-item-title">10.4.4 침입</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#10.5_요약"><div class="tree-item-contents heading-link" heading-name="10.5 요약"><span class="tree-item-title">10.5 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#11장_상용_엔진_사례"><div class="tree-item-contents heading-link" heading-name="11장 상용 엔진 사례"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">11장 상용 엔진 사례</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#11.1_언리얼_엔진_4"><div class="tree-item-contents heading-link" heading-name="11.1 언리얼 엔진 4"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">11.1 언리얼 엔진 4</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.1.1_소켓과_기본_네트워킹"><div class="tree-item-contents heading-link" heading-name="11.1.1 소켓과 기본 네트워킹"><span class="tree-item-title">11.1.1 소켓과 기본 네트워킹</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.1.2_게임_객체와_토폴로지"><div class="tree-item-contents heading-link" heading-name="11.1.2 게임 객체와 토폴로지"><span class="tree-item-title">11.1.2 게임 객체와 토폴로지</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.1.3_액터_리플리케이션"><div class="tree-item-contents heading-link" heading-name="11.1.3 액터 리플리케이션"><span class="tree-item-title">11.1.3 액터 리플리케이션</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.1.4_원격_프로시저_호출"><div class="tree-item-contents heading-link" heading-name="11.1.4 원격 프로시저 호출"><span class="tree-item-title">11.1.4 원격 프로시저 호출</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#11.2_유니티"><div class="tree-item-contents heading-link" heading-name="11.2 유니티"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">11.2 유니티</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.2.1_전송_계층_API"><div class="tree-item-contents heading-link" heading-name="11.2.1 전송 계층 API"><span class="tree-item-title">11.2.1 전송 계층 API</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.2.2_게임_객체와_토폴로지"><div class="tree-item-contents heading-link" heading-name="11.2.2 게임 객체와 토폴로지"><span class="tree-item-title">11.2.2 게임 객체와 토폴로지</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.2.3_객체_스폰과_리플리케이션"><div class="tree-item-contents heading-link" heading-name="11.2.3 객체 스폰과 리플리케이션"><span class="tree-item-title">11.2.3 객체 스폰과 리플리케이션</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.2.4_원격_프로시저_호출"><div class="tree-item-contents heading-link" heading-name="11.2.4 원격 프로시저 호출"><span class="tree-item-title">11.2.4 원격 프로시저 호출</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#11.2.5_매치메이킹"><div class="tree-item-contents heading-link" heading-name="11.2.5 매치메이킹"><span class="tree-item-title">11.2.5 매치메이킹</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#11.3_요약"><div class="tree-item-contents heading-link" heading-name="11.3 요약"><span class="tree-item-title">11.3 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#12장_게임_서비스_플랫폼"><div class="tree-item-contents heading-link" heading-name="12장 게임 서비스 플랫폼"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">12장 게임 서비스 플랫폼</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.1_게임_서비스_플랫폼_선택하기"><div class="tree-item-contents heading-link" heading-name="12.1 게임 서비스 플랫폼 선택하기"><span class="tree-item-title">12.1 게임 서비스 플랫폼 선택하기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.2_기본_셋업"><div class="tree-item-contents heading-link" heading-name="12.2 기본 셋업"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">12.2 기본 셋업</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#12.2.1_초기화,_구동,_마무리"><div class="tree-item-contents heading-link" heading-name="12.2.1 초기화, 구동, 마무리"><span class="tree-item-title">12.2.1 초기화, 구동, 마무리</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#12.2.2_유저_ID_및_이름"><div class="tree-item-contents heading-link" heading-name="12.2.2 유저 ID 및 이름"><span class="tree-item-title">12.2.2 유저 ID 및 이름</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.3_로비_및_매치메이킹"><div class="tree-item-contents heading-link" heading-name="12.3 로비 및 매치메이킹"><span class="tree-item-title">12.3 로비 및 매치메이킹</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.4_네트워킹"><div class="tree-item-contents heading-link" heading-name="12.4 네트워킹"><span class="tree-item-title">12.4 네트워킹</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.5_플레이어_통계"><div class="tree-item-contents heading-link" heading-name="12.5 플레이어 통계"><span class="tree-item-title">12.5 플레이어 통계</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.6_플레이어_도전과제"><div class="tree-item-contents heading-link" heading-name="12.6 플레이어 도전과제"><span class="tree-item-title">12.6 플레이어 도전과제</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.7_리더보드"><div class="tree-item-contents heading-link" heading-name="12.7 리더보드"><span class="tree-item-title">12.7 리더보드</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.8_기타_서비스"><div class="tree-item-contents heading-link" heading-name="12.8 기타 서비스"><span class="tree-item-title">12.8 기타 서비스</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#12.9_요약"><div class="tree-item-contents heading-link" heading-name="12.9 요약"><span class="tree-item-title">12.9 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#13장_클라우드에_전용_서버_호스팅하기"><div class="tree-item-contents heading-link" heading-name="13장 클라우드에 전용 서버 호스팅하기"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">13장 클라우드에 전용 서버 호스팅하기</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#13.1_클라우드,_꼭_사용해야_할까"><div class="tree-item-contents heading-link" heading-name="13.1 클라우드, 꼭 사용해야 할까"><span class="tree-item-title">13.1 클라우드, 꼭 사용해야 할까</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#13.2_필수_도구"><div class="tree-item-contents heading-link" heading-name="13.2 필수 도구"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">13.2 필수 도구</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.2.1_REST"><div class="tree-item-contents heading-link" heading-name="13.2.1 REST"><span class="tree-item-title">13.2.1 REST</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.2.2_JSON"><div class="tree-item-contents heading-link" heading-name="13.2.2 JSON"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">13.2.2 JSON</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="6"><a class="tree-link" href="githubio\html_uploadtest.html#13.2.3_Node.js"><div class="tree-item-contents heading-link" heading-name="13.2.3 Node.js"><span class="tree-item-title">13.2.3 Node.js</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#13.3_용어_및_개요"><div class="tree-item-contents heading-link" heading-name="13.3 용어 및 개요"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">13.3 용어 및 개요</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.3.1_서버_게임_인스턴스"><div class="tree-item-contents heading-link" heading-name="13.3.1 서버 게임 인스턴스"><span class="tree-item-title">13.3.1 서버 게임 인스턴스</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.3.2_게임_서버_프로세스"><div class="tree-item-contents heading-link" heading-name="13.3.2 게임 서버 프로세스"><span class="tree-item-title">13.3.2 게임 서버 프로세스</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.3.3_게임_서버_머신"><div class="tree-item-contents heading-link" heading-name="13.3.3 게임 서버 머신"><span class="tree-item-title">13.3.3 게임 서버 머신</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.3.4_하드웨어"><div class="tree-item-contents heading-link" heading-name="13.3.4 하드웨어"><span class="tree-item-title">13.3.4 하드웨어</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#13.4_로컬_서버_프로세스_관리자"><div class="tree-item-contents heading-link" heading-name="13.4 로컬 서버 프로세스 관리자"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">13.4 로컬 서버 프로세스 관리자</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.4.1_프로세스_모니터링"><div class="tree-item-contents heading-link" heading-name="13.4.1 프로세스 모니터링"><span class="tree-item-title">13.4.1 프로세스 모니터링</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#13.5_가상_머신_관리자"><div class="tree-item-contents heading-link" heading-name="13.5 가상 머신 관리자"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">13.5 가상 머신 관리자</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="githubio\html_uploadtest.html#13.5.1_가상_머신_모니터링"><div class="tree-item-contents heading-link" heading-name="13.5.1 가상 머신 모니터링"><span class="tree-item-title">13.5.1 가상 머신 모니터링</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="githubio\html_uploadtest.html#13.6_요약"><div class="tree-item-contents heading-link" heading-name="13.6 요약"><span class="tree-item-title">13.6 요약</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="githubio\html_uploadtest.html#부록A_모던_C++_기초"><div class="tree-item-contents heading-link" heading-name="부록A 모던 C++ 기초"><span class="tree-item-title">부록A 모던 C++ 기초</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="githubio\html_uploadtest.html#필요_플로그인_:_Link_Embeded"><div class="tree-item-contents heading-link" heading-name="필요 플로그인 : Link Embeded"><span class="tree-item-title">필요 플로그인 : Link Embeded</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#테스트1"><div class="tree-item-contents heading-link" heading-name="테스트1"><span class="tree-item-title">테스트1</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#테스트2"><div class="tree-item-contents heading-link" heading-name="테스트2"><span class="tree-item-title">테스트2</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="githubio\html_uploadtest.html#테스트3"><div class="tree-item-contents heading-link" heading-name="테스트3"><span class="tree-item-title">테스트3</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>